# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class SystemAdministrationMonitoringAlarmsAndEventsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def bulk_update_alarms_set_status(self, new_status, **kwargs):  # noqa: E501
        """Bulk update the status of zero or more Alarms.  # noqa: E501

        Bulk update the status of zero or more Alarms that match the specified filters. The new_status value can be OPEN, ACKNOWLEDGED, SUPPRESSED, or RESOLVED. If new_status is SUPPRESSED, the suppress_duration query parameter must also be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_update_alarms_set_status(new_status, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str new_status: Status (required)
        :param int after: Timestamp in milliseconds since epoch
        :param int before: Timestamp in milliseconds since epoch
        :param str cursor: Cursor for pagination
        :param str event_type: Event Type Filter
        :param str feature_name: Feature Name
        :param str id: Alarm ID
        :param str intent_path: Intent Path for entity ID
        :param str node_id: Node ID
        :param str node_resource_type: Node Resource Type
        :param int page_size: Page Size for pagination
        :param str severity: Severity
        :param bool sort_ascending: Represents order of sorting the values
        :param str sort_by: Key for sorting on this column
        :param str status: Status
        :param int suppress_duration: Duration in hours for which Alarm should be suppressed
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_update_alarms_set_status_with_http_info(new_status, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_update_alarms_set_status_with_http_info(new_status, **kwargs)  # noqa: E501
            return data

    def bulk_update_alarms_set_status_with_http_info(self, new_status, **kwargs):  # noqa: E501
        """Bulk update the status of zero or more Alarms.  # noqa: E501

        Bulk update the status of zero or more Alarms that match the specified filters. The new_status value can be OPEN, ACKNOWLEDGED, SUPPRESSED, or RESOLVED. If new_status is SUPPRESSED, the suppress_duration query parameter must also be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_update_alarms_set_status_with_http_info(new_status, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str new_status: Status (required)
        :param int after: Timestamp in milliseconds since epoch
        :param int before: Timestamp in milliseconds since epoch
        :param str cursor: Cursor for pagination
        :param str event_type: Event Type Filter
        :param str feature_name: Feature Name
        :param str id: Alarm ID
        :param str intent_path: Intent Path for entity ID
        :param str node_id: Node ID
        :param str node_resource_type: Node Resource Type
        :param int page_size: Page Size for pagination
        :param str severity: Severity
        :param bool sort_ascending: Represents order of sorting the values
        :param str sort_by: Key for sorting on this column
        :param str status: Status
        :param int suppress_duration: Duration in hours for which Alarm should be suppressed
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['new_status', 'after', 'before', 'cursor', 'event_type', 'feature_name', 'id', 'intent_path', 'node_id', 'node_resource_type', 'page_size', 'severity', 'sort_ascending', 'sort_by', 'status', 'suppress_duration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_update_alarms_set_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'new_status' is set
        if ('new_status' not in params or
                params['new_status'] is None):
            raise ValueError("Missing the required parameter `new_status` when calling `bulk_update_alarms_set_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'event_type' in params:
            query_params.append(('event_type', params['event_type']))  # noqa: E501
        if 'feature_name' in params:
            query_params.append(('feature_name', params['feature_name']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'intent_path' in params:
            query_params.append(('intent_path', params['intent_path']))  # noqa: E501
        if 'new_status' in params:
            query_params.append(('new_status', params['new_status']))  # noqa: E501
        if 'node_id' in params:
            query_params.append(('node_id', params['node_id']))  # noqa: E501
        if 'node_resource_type' in params:
            query_params.append(('node_resource_type', params['node_resource_type']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'severity' in params:
            query_params.append(('severity', params['severity']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'suppress_duration' in params:
            query_params.append(('suppress_duration', params['suppress_duration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/alarms?action=set_status', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alarm(self, alarm_id, **kwargs):  # noqa: E501
        """Get Alarm identified by alarm-id.  # noqa: E501

        Returns alarm associated with alarm-id. If HTTP status 404 is returned, this means the specified alarm-id is invalid or the alarm with alarm-id has been deleted. An alarm is deleted by the system if it is RESOLVED and older than eight days. The system can also delete the remaining RESOLVED alarms sooner to free system resources when too many alarms are being generated. When this happens the oldest day's RESOLVED alarms are deleted first.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alarm(alarm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str alarm_id: (required)
        :return: Alarm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alarm_with_http_info(alarm_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alarm_with_http_info(alarm_id, **kwargs)  # noqa: E501
            return data

    def get_alarm_with_http_info(self, alarm_id, **kwargs):  # noqa: E501
        """Get Alarm identified by alarm-id.  # noqa: E501

        Returns alarm associated with alarm-id. If HTTP status 404 is returned, this means the specified alarm-id is invalid or the alarm with alarm-id has been deleted. An alarm is deleted by the system if it is RESOLVED and older than eight days. The system can also delete the remaining RESOLVED alarms sooner to free system resources when too many alarms are being generated. When this happens the oldest day's RESOLVED alarms are deleted first.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alarm_with_http_info(alarm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str alarm_id: (required)
        :return: Alarm
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alarm_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alarm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'alarm_id' is set
        if ('alarm_id' not in params or
                params['alarm_id'] is None):
            raise ValueError("Missing the required parameter `alarm_id` when calling `get_alarm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'alarm_id' in params:
            path_params['alarm-id'] = params['alarm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/alarms/{alarm-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Alarm',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alarms(self, **kwargs):  # noqa: E501
        """Get the list of all Alarms currently known to the system.  # noqa: E501

        Returns a list of all Alarms currently known to the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alarms(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int after: Timestamp in milliseconds since epoch
        :param int before: Timestamp in milliseconds since epoch
        :param str cursor: Cursor for pagination
        :param str event_type: Event Type Filter
        :param str feature_name: Feature Name
        :param str id: Alarm ID
        :param str intent_path: Intent Path for entity ID
        :param str node_id: Node ID
        :param str node_resource_type: Node Resource Type
        :param int page_size: Page Size for pagination
        :param str severity: Severity
        :param bool sort_ascending: Represents order of sorting the values
        :param str sort_by: Key for sorting on this column
        :param str status: Status
        :return: AlarmsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alarms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_alarms_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_alarms_with_http_info(self, **kwargs):  # noqa: E501
        """Get the list of all Alarms currently known to the system.  # noqa: E501

        Returns a list of all Alarms currently known to the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alarms_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int after: Timestamp in milliseconds since epoch
        :param int before: Timestamp in milliseconds since epoch
        :param str cursor: Cursor for pagination
        :param str event_type: Event Type Filter
        :param str feature_name: Feature Name
        :param str id: Alarm ID
        :param str intent_path: Intent Path for entity ID
        :param str node_id: Node ID
        :param str node_resource_type: Node Resource Type
        :param int page_size: Page Size for pagination
        :param str severity: Severity
        :param bool sort_ascending: Represents order of sorting the values
        :param str sort_by: Key for sorting on this column
        :param str status: Status
        :return: AlarmsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['after', 'before', 'cursor', 'event_type', 'feature_name', 'id', 'intent_path', 'node_id', 'node_resource_type', 'page_size', 'severity', 'sort_ascending', 'sort_by', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alarms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'event_type' in params:
            query_params.append(('event_type', params['event_type']))  # noqa: E501
        if 'feature_name' in params:
            query_params.append(('feature_name', params['feature_name']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'intent_path' in params:
            query_params.append(('intent_path', params['intent_path']))  # noqa: E501
        if 'node_id' in params:
            query_params.append(('node_id', params['node_id']))  # noqa: E501
        if 'node_resource_type' in params:
            query_params.append(('node_resource_type', params['node_resource_type']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'severity' in params:
            query_params.append(('severity', params['severity']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/alarms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlarmsListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event(self, event_id, **kwargs):  # noqa: E501
        """Get Events identified by event-id.  # noqa: E501

        Returns event associated with event-id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_id: (required)
        :return: MonitoringEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_event_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def get_event_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Get Events identified by event-id.  # noqa: E501

        Returns event associated with event-id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_with_http_info(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_id: (required)
        :return: MonitoringEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event-id'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/events/{event-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MonitoringEvent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_events(self, **kwargs):  # noqa: E501
        """Get the list of all Events defined in NSX.  # noqa: E501

        Returns a list of all Events defined in NSX.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_events(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EventListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_events_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_events_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_events_with_http_info(self, **kwargs):  # noqa: E501
        """Get the list of all Events defined in NSX.  # noqa: E501

        Returns a list of all Events defined in NSX.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_events_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EventListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_events" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_event_values_set_default(self, event_id, **kwargs):  # noqa: E501
        """Reset all user configurable values to factory defaults.  # noqa: E501

        Reset all user configurable values for event identified by event-id to factory defaults.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_event_values_set_default(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_id: (required)
        :return: MonitoringEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_event_values_set_default_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_event_values_set_default_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def reset_event_values_set_default_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Reset all user configurable values to factory defaults.  # noqa: E501

        Reset all user configurable values for event identified by event-id to factory defaults.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_event_values_set_default_with_http_info(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_id: (required)
        :return: MonitoringEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_event_values_set_default" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `reset_event_values_set_default`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event-id'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/events/{event-id}?action=set_default', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MonitoringEvent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_alarm_status_set_status(self, alarm_id, new_status, **kwargs):  # noqa: E501
        """Update staus of alarm identified by alarm-id.  # noqa: E501

        Update status of an Alarm. The new_status value can be OPEN, ACKNOWLEDGED, SUPPRESSED, or RESOLVED. If new_status is SUPPRESSED, the suppress_duration query parameter must also be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alarm_status_set_status(alarm_id, new_status, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str alarm_id: (required)
        :param str new_status: Status (required)
        :param int suppress_duration: Duration in hours for which Alarm should be suppressed
        :return: Alarm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_alarm_status_set_status_with_http_info(alarm_id, new_status, **kwargs)  # noqa: E501
        else:
            (data) = self.update_alarm_status_set_status_with_http_info(alarm_id, new_status, **kwargs)  # noqa: E501
            return data

    def update_alarm_status_set_status_with_http_info(self, alarm_id, new_status, **kwargs):  # noqa: E501
        """Update staus of alarm identified by alarm-id.  # noqa: E501

        Update status of an Alarm. The new_status value can be OPEN, ACKNOWLEDGED, SUPPRESSED, or RESOLVED. If new_status is SUPPRESSED, the suppress_duration query parameter must also be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alarm_status_set_status_with_http_info(alarm_id, new_status, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str alarm_id: (required)
        :param str new_status: Status (required)
        :param int suppress_duration: Duration in hours for which Alarm should be suppressed
        :return: Alarm
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alarm_id', 'new_status', 'suppress_duration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_alarm_status_set_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'alarm_id' is set
        if ('alarm_id' not in params or
                params['alarm_id'] is None):
            raise ValueError("Missing the required parameter `alarm_id` when calling `update_alarm_status_set_status`")  # noqa: E501
        # verify the required parameter 'new_status' is set
        if ('new_status' not in params or
                params['new_status'] is None):
            raise ValueError("Missing the required parameter `new_status` when calling `update_alarm_status_set_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'alarm_id' in params:
            path_params['alarm-id'] = params['alarm_id']  # noqa: E501

        query_params = []
        if 'new_status' in params:
            query_params.append(('new_status', params['new_status']))  # noqa: E501
        if 'suppress_duration' in params:
            query_params.append(('suppress_duration', params['suppress_duration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/alarms/{alarm-id}?action=set_status', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Alarm',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event(self, body, event_id, **kwargs):  # noqa: E501
        """Update event associated with event-id.  # noqa: E501

        Update event identified by event-id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event(body, event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MonitoringEvent body: (required)
        :param str event_id: (required)
        :return: MonitoringEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_event_with_http_info(body, event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_with_http_info(body, event_id, **kwargs)  # noqa: E501
            return data

    def update_event_with_http_info(self, body, event_id, **kwargs):  # noqa: E501
        """Update event associated with event-id.  # noqa: E501

        Update event identified by event-id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_with_http_info(body, event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MonitoringEvent body: (required)
        :param str event_id: (required)
        :return: MonitoringEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'event_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_event`")  # noqa: E501
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `update_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event-id'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/events/{event-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MonitoringEvent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
