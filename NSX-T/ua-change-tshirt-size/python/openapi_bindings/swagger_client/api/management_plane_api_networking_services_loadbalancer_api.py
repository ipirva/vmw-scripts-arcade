# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPINetworkingServicesLoadbalancerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_load_balancer_application_profile(self, body, **kwargs):  # noqa: E501
        """Create a load balancer application profile  # noqa: E501

        Create a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_application_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbAppProfile body: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_application_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_application_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_application_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer application profile  # noqa: E501

        Create a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_application_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbAppProfile body: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_application_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_application_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbAppProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_client_ssl_profile(self, body, **kwargs):  # noqa: E501
        """Create a load balancer client-ssl profile  # noqa: E501

        Create a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_client_ssl_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbClientSslProfile body: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_client_ssl_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_client_ssl_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_client_ssl_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer client-ssl profile  # noqa: E501

        Create a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_client_ssl_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbClientSslProfile body: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_client_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_client_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbClientSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_monitor(self, body, **kwargs):  # noqa: E501
        """Create a load balancer monitor  # noqa: E501

        Create a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_monitor(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbMonitor body: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_monitor_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_monitor_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_monitor_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer monitor  # noqa: E501

        Create a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_monitor_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbMonitor body: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbMonitor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_persistence_profile(self, body, **kwargs):  # noqa: E501
        """Create a load balancer persistence profile  # noqa: E501

        Create a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_persistence_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbPersistenceProfile body: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_persistence_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_persistence_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_persistence_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer persistence profile  # noqa: E501

        Create a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_persistence_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbPersistenceProfile body: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_persistence_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_persistence_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPersistenceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_pool(self, body, **kwargs):  # noqa: E501
        """Create a load balancer pool  # noqa: E501

        Create a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_pool(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbPool body: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_pool_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_pool_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_pool_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer pool  # noqa: E501

        Create a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_pool_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbPool body: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_rule(self, body, **kwargs):  # noqa: E501
        """Create a load balancer rule  # noqa: E501

        Create a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_rule(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbRule body: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_rule_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_rule_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer rule  # noqa: E501

        Create a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbRule body: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_server_ssl_profile(self, body, **kwargs):  # noqa: E501
        """Create a load balancer server-ssl profile  # noqa: E501

        Create a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_server_ssl_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbServerSslProfile body: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_server_ssl_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_server_ssl_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_server_ssl_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer server-ssl profile  # noqa: E501

        Create a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_server_ssl_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbServerSslProfile body: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_server_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_server_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServerSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_service(self, body, **kwargs):  # noqa: E501
        """Create a load balancer service  # noqa: E501

        Create a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_service(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbService body: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_service_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_service_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_service_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer service  # noqa: E501

        Create a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_service_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbService body: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbService',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_virtual_server(self, body, **kwargs):  # noqa: E501
        """Create a load balancer virtual server  # noqa: E501

        Create a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_virtual_server(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbVirtualServer body: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_virtual_server_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_virtual_server_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_virtual_server_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer virtual server  # noqa: E501

        Create a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_virtual_server_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbVirtualServer body: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_virtual_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_virtual_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_virtual_server_with_rules_create_with_rules(self, body, **kwargs):  # noqa: E501
        """Create a load balancer virtual server with rules  # noqa: E501

        It is used to create virtual servers, the associated rules and bind the rules to the virtual server. To add new rules, make sure the rules which have no identifier specified, the new rules are automatically generated and associated to the virtual server. If the virtual server need to consume some existed rules without change, those rules should not be specified in this array, otherwise, the rules are updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_virtual_server_with_rules_create_with_rules(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbVirtualServerWithRule body: (required)
        :return: LbVirtualServerWithRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_load_balancer_virtual_server_with_rules_create_with_rules_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_virtual_server_with_rules_create_with_rules_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_virtual_server_with_rules_create_with_rules_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a load balancer virtual server with rules  # noqa: E501

        It is used to create virtual servers, the associated rules and bind the rules to the virtual server. To add new rules, make sure the rules which have no identifier specified, the new rules are automatically generated and associated to the virtual server. If the virtual server need to consume some existed rules without change, those rules should not be specified in this array, otherwise, the rules are updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_load_balancer_virtual_server_with_rules_create_with_rules_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbVirtualServerWithRule body: (required)
        :return: LbVirtualServerWithRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_virtual_server_with_rules_create_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_load_balancer_virtual_server_with_rules_create_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers?action=create_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerWithRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_application_profile(self, application_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer application profile  # noqa: E501

        Delete a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_application_profile(application_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_application_profile_with_http_info(application_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_application_profile_with_http_info(application_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_application_profile_with_http_info(self, application_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer application profile  # noqa: E501

        Delete a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_application_profile_with_http_info(application_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_application_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_profile_id' is set
        if ('application_profile_id' not in params or
                params['application_profile_id'] is None):
            raise ValueError("Missing the required parameter `application_profile_id` when calling `delete_load_balancer_application_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_profile_id' in params:
            path_params['application-profile-id'] = params['application_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles/{application-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_client_ssl_profile(self, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer client-ssl profile  # noqa: E501

        Delete a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_client_ssl_profile(client_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_ssl_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_client_ssl_profile_with_http_info(self, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer client-ssl profile  # noqa: E501

        Delete a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_ssl_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_ssl_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_client_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_ssl_profile_id' is set
        if ('client_ssl_profile_id' not in params or
                params['client_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `client_ssl_profile_id` when calling `delete_load_balancer_client_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_ssl_profile_id' in params:
            path_params['client-ssl-profile-id'] = params['client_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_monitor(self, monitor_id, **kwargs):  # noqa: E501
        """Delete a load balancer monitor  # noqa: E501

        Delete a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_monitor(monitor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_monitor_with_http_info(monitor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_monitor_with_http_info(monitor_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_monitor_with_http_info(self, monitor_id, **kwargs):  # noqa: E501
        """Delete a load balancer monitor  # noqa: E501

        Delete a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_monitor_with_http_info(monitor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_id' is set
        if ('monitor_id' not in params or
                params['monitor_id'] is None):
            raise ValueError("Missing the required parameter `monitor_id` when calling `delete_load_balancer_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_id' in params:
            path_params['monitor-id'] = params['monitor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors/{monitor-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_persistence_profile(self, persistence_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer persistence profile  # noqa: E501

        Delete a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_persistence_profile(persistence_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str persistence_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_persistence_profile_with_http_info(persistence_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_persistence_profile_with_http_info(persistence_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_persistence_profile_with_http_info(self, persistence_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer persistence profile  # noqa: E501

        Delete a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_persistence_profile_with_http_info(persistence_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str persistence_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['persistence_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_persistence_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'persistence_profile_id' is set
        if ('persistence_profile_id' not in params or
                params['persistence_profile_id'] is None):
            raise ValueError("Missing the required parameter `persistence_profile_id` when calling `delete_load_balancer_persistence_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'persistence_profile_id' in params:
            path_params['persistence-profile-id'] = params['persistence_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles/{persistence-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_pool(self, pool_id, **kwargs):  # noqa: E501
        """Delete a load balancer pool  # noqa: E501

        Delete a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_pool(pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Delete a load balancer pool  # noqa: E501

        Delete a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_pool_with_http_info(pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `delete_load_balancer_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools/{pool-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_rule(self, rule_id, **kwargs):  # noqa: E501
        """Delete a load balancer rule  # noqa: E501

        Delete a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_rule(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_rule_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Delete a load balancer rule  # noqa: E501

        Delete a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_rule_with_http_info(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_load_balancer_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules/{rule-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_server_ssl_profile(self, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer server-ssl profile  # noqa: E501

        Delete a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_server_ssl_profile(server_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_ssl_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_server_ssl_profile_with_http_info(self, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer server-ssl profile  # noqa: E501

        Delete a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_ssl_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_ssl_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_server_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_ssl_profile_id' is set
        if ('server_ssl_profile_id' not in params or
                params['server_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `server_ssl_profile_id` when calling `delete_load_balancer_server_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_ssl_profile_id' in params:
            path_params['server-ssl-profile-id'] = params['server_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_service(self, service_id, **kwargs):  # noqa: E501
        """Delete a load balancer service  # noqa: E501

        Delete a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_service(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Delete a load balancer service  # noqa: E501

        Delete a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_service_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_load_balancer_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_virtual_server(self, virtual_server_id, **kwargs):  # noqa: E501
        """Delete a load balancer virtual server  # noqa: E501

        Delete a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_virtual_server(virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str virtual_server_id: (required)
        :param bool delete_associated_rules: Delete associated rules
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_load_balancer_virtual_server_with_http_info(virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_virtual_server_with_http_info(virtual_server_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_virtual_server_with_http_info(self, virtual_server_id, **kwargs):  # noqa: E501
        """Delete a load balancer virtual server  # noqa: E501

        Delete a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_load_balancer_virtual_server_with_http_info(virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str virtual_server_id: (required)
        :param bool delete_associated_rules: Delete associated rules
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['virtual_server_id', 'delete_associated_rules']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_virtual_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `delete_load_balancer_virtual_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []
        if 'delete_associated_rules' in params:
            query_params.append(('delete_associated_rules', params['delete_associated_rules']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers/{virtual-server-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_pool_statistics(self, service_id, pool_id, **kwargs):  # noqa: E501
        """Get the statistics of load balancer pool  # noqa: E501

        Returns the statistics of the given load balancer pool by given load balancer serives id and load balancer pool id. Currently, only realtime mode is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_pool_statistics(service_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str pool_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_load_balancer_pool_statistics_with_http_info(service_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_pool_statistics_with_http_info(service_id, pool_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_pool_statistics_with_http_info(self, service_id, pool_id, **kwargs):  # noqa: E501
        """Get the statistics of load balancer pool  # noqa: E501

        Returns the statistics of the given load balancer pool by given load balancer serives id and load balancer pool id. Currently, only realtime mode is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_pool_statistics_with_http_info(service_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str pool_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'pool_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_pool_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_pool_statistics`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `get_load_balancer_pool_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/pools/{pool-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_pool_status(self, service_id, pool_id, **kwargs):  # noqa: E501
        """Get the status of load balancer pool  # noqa: E501

        Returns the status of the given load balancer pool by given load balancer serives id and load balancer pool id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_pool_status(service_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str pool_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_load_balancer_pool_status_with_http_info(service_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_pool_status_with_http_info(service_id, pool_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_pool_status_with_http_info(self, service_id, pool_id, **kwargs):  # noqa: E501
        """Get the status of load balancer pool  # noqa: E501

        Returns the status of the given load balancer pool by given load balancer serives id and load balancer pool id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_pool_status_with_http_info(service_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str pool_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'pool_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_pool_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_pool_status`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `get_load_balancer_pool_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/pools/{pool-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_service_statistics(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics of load balancer service  # noqa: E501

        Returns the statistics of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_service_statistics(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbServiceStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_load_balancer_service_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_service_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_service_statistics_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics of load balancer service  # noqa: E501

        Returns the statistics of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_service_statistics_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbServiceStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_service_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_service_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServiceStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_service_status(self, service_id, **kwargs):  # noqa: E501
        """Get the status of the given load balancer service  # noqa: E501

        Returns the status of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_service_status(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param bool include_instance_details: Flag to indicate whether include detail information
        :param str source: Data source type.
        :param str transport_node_ids: The UUIDs of transport nodes
        :return: LbServiceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_load_balancer_service_status_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_service_status_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_service_status_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the status of the given load balancer service  # noqa: E501

        Returns the status of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_service_status_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param bool include_instance_details: Flag to indicate whether include detail information
        :param str source: Data source type.
        :param str transport_node_ids: The UUIDs of transport nodes
        :return: LbServiceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'include_instance_details', 'source', 'transport_node_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_service_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_service_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'include_instance_details' in params:
            query_params.append(('include_instance_details', params['include_instance_details']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_ids' in params:
            query_params.append(('transport_node_ids', params['transport_node_ids']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServiceStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_virtual_server_statistics(self, service_id, virtual_server_id, **kwargs):  # noqa: E501
        """Get the statistics of the given load balancer virtual server  # noqa: E501

        Returns the statistics of the load balancer virtual server by given load  balancer serives id and load balancer virtual server id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_virtual_server_statistics(service_id, virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str virtual_server_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_load_balancer_virtual_server_statistics_with_http_info(service_id, virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_virtual_server_statistics_with_http_info(service_id, virtual_server_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_virtual_server_statistics_with_http_info(self, service_id, virtual_server_id, **kwargs):  # noqa: E501
        """Get the statistics of the given load balancer virtual server  # noqa: E501

        Returns the statistics of the load balancer virtual server by given load  balancer serives id and load balancer virtual server id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_virtual_server_statistics_with_http_info(service_id, virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str virtual_server_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'virtual_server_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_virtual_server_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_virtual_server_statistics`")  # noqa: E501
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `get_load_balancer_virtual_server_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/virtual-servers/{virtual-server-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_virtual_server_status(self, service_id, virtual_server_id, **kwargs):  # noqa: E501
        """Get the status of the load balancer virtual server  # noqa: E501

        Returns the status of the virtual server by given load balancer serives id and load balancer virtual server id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_virtual_server_status(service_id, virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str virtual_server_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_load_balancer_virtual_server_status_with_http_info(service_id, virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_virtual_server_status_with_http_info(service_id, virtual_server_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_virtual_server_status_with_http_info(self, service_id, virtual_server_id, **kwargs):  # noqa: E501
        """Get the status of the load balancer virtual server  # noqa: E501

        Returns the status of the virtual server by given load balancer serives id and load balancer virtual server id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_virtual_server_status_with_http_info(service_id, virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str virtual_server_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'virtual_server_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_virtual_server_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_virtual_server_status`")  # noqa: E501
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `get_load_balancer_virtual_server_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/virtual-servers/{virtual-server-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_application_profiles(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer application profiles  # noqa: E501

        Retrieve a paginated list of load balancer application profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_application_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: application profile type
        :return: LbAppProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_application_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_application_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_application_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer application profiles  # noqa: E501

        Retrieve a paginated list of load balancer application profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_application_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: application profile type
        :return: LbAppProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_application_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbAppProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_client_ssl_profiles(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer client-ssl profiles  # noqa: E501

        Retrieve a paginated list of load balancer client-ssl profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_client_ssl_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbClientSslProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_client_ssl_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_client_ssl_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_client_ssl_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer client-ssl profiles  # noqa: E501

        Retrieve a paginated list of load balancer client-ssl profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_client_ssl_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbClientSslProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_client_ssl_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbClientSslProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_monitors(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer monitors  # noqa: E501

        Retrieve a paginated list of load balancer monitors.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_monitors(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: monitor query type
        :return: LbMonitorListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_monitors_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_monitors_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_monitors_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer monitors  # noqa: E501

        Retrieve a paginated list of load balancer monitors.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_monitors_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: monitor query type
        :return: LbMonitorListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_monitors" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbMonitorListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_persistence_profiles(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer persistence profiles  # noqa: E501

        Retrieve a paginated list of load balancer persistence profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_persistence_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: persistence profile type
        :return: LbPersistenceProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_persistence_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_persistence_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_persistence_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer persistence profiles  # noqa: E501

        Retrieve a paginated list of load balancer persistence profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_persistence_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: persistence profile type
        :return: LbPersistenceProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_persistence_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPersistenceProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_pool_statistics(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics list of load balancer pools  # noqa: E501

        Returns the statistics list of load balancer pools in given load balancer service. Currently, only realtime mode is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_pool_statistics(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatisticsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_pool_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_pool_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_load_balancer_pool_statistics_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics list of load balancer pools  # noqa: E501

        Returns the statistics list of load balancer pools in given load balancer service. Currently, only realtime mode is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_pool_statistics_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatisticsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_pool_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_load_balancer_pool_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/pools/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolStatisticsListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_pool_statuses(self, service_id, **kwargs):  # noqa: E501
        """Get the status list of load balancer pools  # noqa: E501

        Returns the status list of load balancer pools in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_pool_statuses(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_pool_statuses_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_pool_statuses_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_load_balancer_pool_statuses_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the status list of load balancer pools  # noqa: E501

        Returns the status list of load balancer pools in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_pool_statuses_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_pool_statuses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_load_balancer_pool_statuses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/pools/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_pools(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer pools  # noqa: E501

        Retrieve a paginated list of load balancer pools.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_pools(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_pools_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_pools_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_pools_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer pools  # noqa: E501

        Retrieve a paginated list of load balancer pools.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_pools_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_pools" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_rules(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer rules  # noqa: E501

        Retrieve a paginated list of load balancer rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_rules(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_rules_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_rules_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_rules_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer rules  # noqa: E501

        Retrieve a paginated list of load balancer rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_rules_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_rules" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_server_ssl_profiles(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer server-ssl profiles  # noqa: E501

        Retrieve a paginated list of load balancer server-ssl profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_server_ssl_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbServerSslProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_server_ssl_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_server_ssl_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_server_ssl_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer server-ssl profiles  # noqa: E501

        Retrieve a paginated list of load balancer server-ssl profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_server_ssl_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbServerSslProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_server_ssl_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServerSslProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_services(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer services  # noqa: E501

        Retrieve a paginated list of load balancer services. When logical_router_id is specified in request parameters, the associated load balancer services which are related to the given logical router returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_services(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str logical_router_id: Logical router identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_services_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer services  # noqa: E501

        Retrieve a paginated list of load balancer services. When logical_router_id is specified in request parameters, the associated load balancer services which are related to the given logical router returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_services_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str logical_router_id: Logical router identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'logical_router_id', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_services" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'logical_router_id' in params:
            query_params.append(('logical_router_id', params['logical_router_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServiceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_ssl_ciphers_and_protocols(self, **kwargs):  # noqa: E501
        """Retrieve a list of supported SSL ciphers and protocols  # noqa: E501

        Retrieve a list of supported SSL ciphers and protocols.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_ssl_ciphers_and_protocols(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbSslCipherAndProtocolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_ssl_ciphers_and_protocols_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_ssl_ciphers_and_protocols_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_ssl_ciphers_and_protocols_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a list of supported SSL ciphers and protocols  # noqa: E501

        Retrieve a list of supported SSL ciphers and protocols.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_ssl_ciphers_and_protocols_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbSslCipherAndProtocolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_ssl_ciphers_and_protocols" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/ssl/ciphers-and-protocols', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbSslCipherAndProtocolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_virtual_server_statuses(self, service_id, **kwargs):  # noqa: E501
        """Get the status list of virtual servers in given load balancer service  # noqa: E501

        Returns the status list of virtual servers in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_virtual_server_statuses(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_virtual_server_statuses_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_virtual_server_statuses_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_load_balancer_virtual_server_statuses_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the status list of virtual servers in given load balancer service  # noqa: E501

        Returns the status list of virtual servers in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_virtual_server_statuses_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_virtual_server_statuses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_load_balancer_virtual_server_statuses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/virtual-servers/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_virtual_servers(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer virtual servers  # noqa: E501

        Retrieve a paginated list of load balancer virtual servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_virtual_servers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbVirtualServerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_virtual_servers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_virtual_servers_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_virtual_servers_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer virtual servers  # noqa: E501

        Retrieve a paginated list of load balancer virtual servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_virtual_servers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbVirtualServerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_virtual_servers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_virtual_servers_statistics(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics list of virtual servers  # noqa: E501

        Returns the statistics list of virtual servers in given load balancer service. Currently, only realtime mode is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_virtual_servers_statistics(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatisticsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_load_balancer_virtual_servers_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_virtual_servers_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_load_balancer_virtual_servers_statistics_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics list of virtual servers  # noqa: E501

        Returns the statistics list of virtual servers in given load balancer service. Currently, only realtime mode is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_load_balancer_virtual_servers_statistics_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatisticsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_virtual_servers_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_load_balancer_virtual_servers_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/virtual-servers/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerStatisticsListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def perform_pool_member_action(self, body, action, pool_id, **kwargs):  # noqa: E501
        """Add, remove, or modify load balancer pool members  # noqa: E501

        For ADD_MEMBERS, pool members will be created and added to load balancer pool. This action is only valid for static pool members. For REMOVE_MEMBERS, pool members will be removed from load balancer pool via IP and port in pool member settings. This action is only valid for static pool members. For UPDATE_MEMBERS, pool members admin state will be updated. This action is valid for both static pool members and dynamic pool members. For dynamic pool members, this update will be stored in customized_members field in load balancer pool member group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.perform_pool_member_action(body, action, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PoolMemberSettingList body: (required)
        :param str action: Specifies addition, removal and modification action (required)
        :param str pool_id: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.perform_pool_member_action_with_http_info(body, action, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.perform_pool_member_action_with_http_info(body, action, pool_id, **kwargs)  # noqa: E501
            return data

    def perform_pool_member_action_with_http_info(self, body, action, pool_id, **kwargs):  # noqa: E501
        """Add, remove, or modify load balancer pool members  # noqa: E501

        For ADD_MEMBERS, pool members will be created and added to load balancer pool. This action is only valid for static pool members. For REMOVE_MEMBERS, pool members will be removed from load balancer pool via IP and port in pool member settings. This action is only valid for static pool members. For UPDATE_MEMBERS, pool members admin state will be updated. This action is valid for both static pool members and dynamic pool members. For dynamic pool members, this update will be stored in customized_members field in load balancer pool member group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.perform_pool_member_action_with_http_info(body, action, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PoolMemberSettingList body: (required)
        :param str action: Specifies addition, removal and modification action (required)
        :param str pool_id: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'action', 'pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method perform_pool_member_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `perform_pool_member_action`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `perform_pool_member_action`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `perform_pool_member_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools/{pool-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_application_profile(self, application_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer application profile  # noqa: E501

        Retrieve a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_application_profile(application_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application_profile_id: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_application_profile_with_http_info(application_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_application_profile_with_http_info(application_profile_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_application_profile_with_http_info(self, application_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer application profile  # noqa: E501

        Retrieve a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_application_profile_with_http_info(application_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application_profile_id: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_application_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_profile_id' is set
        if ('application_profile_id' not in params or
                params['application_profile_id'] is None):
            raise ValueError("Missing the required parameter `application_profile_id` when calling `read_load_balancer_application_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_profile_id' in params:
            path_params['application-profile-id'] = params['application_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles/{application-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbAppProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_client_ssl_profile(self, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer client-ssl profile  # noqa: E501

        Retrieve a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_client_ssl_profile(client_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_ssl_profile_id: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_client_ssl_profile_with_http_info(self, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer client-ssl profile  # noqa: E501

        Retrieve a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_ssl_profile_id: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_ssl_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_client_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_ssl_profile_id' is set
        if ('client_ssl_profile_id' not in params or
                params['client_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `client_ssl_profile_id` when calling `read_load_balancer_client_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_ssl_profile_id' in params:
            path_params['client-ssl-profile-id'] = params['client_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbClientSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_monitor(self, monitor_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer monitor  # noqa: E501

        Retrieve a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_monitor(monitor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_id: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_monitor_with_http_info(monitor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_monitor_with_http_info(monitor_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_monitor_with_http_info(self, monitor_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer monitor  # noqa: E501

        Retrieve a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_monitor_with_http_info(monitor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_id: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_id' is set
        if ('monitor_id' not in params or
                params['monitor_id'] is None):
            raise ValueError("Missing the required parameter `monitor_id` when calling `read_load_balancer_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_id' in params:
            path_params['monitor-id'] = params['monitor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors/{monitor-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbMonitor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_node_usage(self, node_id, **kwargs):  # noqa: E501
        """Read load balancer usage for the given node  # noqa: E501

        API is used to retrieve the usage of load balancer entities which include current number and remaining number of credits, virtual Servers, pools, pool Members and different size of LB services from the given node. Currently only Edge node is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_node_usage(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: (required)
        :return: LbNodeUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_node_usage_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_node_usage_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_node_usage_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Read load balancer usage for the given node  # noqa: E501

        API is used to retrieve the usage of load balancer entities which include current number and remaining number of credits, virtual Servers, pools, pool Members and different size of LB services from the given node. Currently only Edge node is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_node_usage_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: (required)
        :return: LbNodeUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_node_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `read_load_balancer_node_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/usage-per-node/{node-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbNodeUsage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_node_usage_summary(self, **kwargs):  # noqa: E501
        """Read load balancer node usage summary  # noqa: E501

        API is used to retrieve the load balancer node usage summary for all nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_node_usage_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_usages: Whether to include node usages
        :return: LbNodeUsageSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_node_usage_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_node_usage_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_load_balancer_node_usage_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Read load balancer node usage summary  # noqa: E501

        API is used to retrieve the load balancer node usage summary for all nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_node_usage_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_usages: Whether to include node usages
        :return: LbNodeUsageSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_usages']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_node_usage_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_usages' in params:
            query_params.append(('include_usages', params['include_usages']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/node-usage-summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbNodeUsageSummary',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_persistence_profile(self, persistence_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer persistence profile  # noqa: E501

        Retrieve a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_persistence_profile(persistence_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str persistence_profile_id: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_persistence_profile_with_http_info(persistence_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_persistence_profile_with_http_info(persistence_profile_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_persistence_profile_with_http_info(self, persistence_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer persistence profile  # noqa: E501

        Retrieve a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_persistence_profile_with_http_info(persistence_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str persistence_profile_id: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['persistence_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_persistence_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'persistence_profile_id' is set
        if ('persistence_profile_id' not in params or
                params['persistence_profile_id'] is None):
            raise ValueError("Missing the required parameter `persistence_profile_id` when calling `read_load_balancer_persistence_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'persistence_profile_id' in params:
            path_params['persistence-profile-id'] = params['persistence_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles/{persistence-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPersistenceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_pool(self, pool_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer pool  # noqa: E501

        Retrieve a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_pool(pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pool_id: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer pool  # noqa: E501

        Retrieve a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_pool_with_http_info(pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pool_id: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_load_balancer_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_rule(self, rule_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer rule  # noqa: E501

        Retrieve a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_rule(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_id: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_rule_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer rule  # noqa: E501

        Retrieve a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_rule_with_http_info(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_id: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `read_load_balancer_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_server_ssl_profile(self, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer server-ssl profile  # noqa: E501

        Retrieve a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_server_ssl_profile(server_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_ssl_profile_id: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_server_ssl_profile_with_http_info(self, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer server-ssl profile  # noqa: E501

        Retrieve a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_ssl_profile_id: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_ssl_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_server_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_ssl_profile_id' is set
        if ('server_ssl_profile_id' not in params or
                params['server_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `server_ssl_profile_id` when calling `read_load_balancer_server_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_ssl_profile_id' in params:
            path_params['server-ssl-profile-id'] = params['server_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServerSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_service(self, service_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer service  # noqa: E501

        Retrieve a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_service(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer service  # noqa: E501

        Retrieve a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_service_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `read_load_balancer_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbService',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_service_debug_info(self, service_id, **kwargs):  # noqa: E501
        """Read the debug information of the load balancer service  # noqa: E501

        API to download below information which will be used for debugging and troubleshooting. 1) Load balancer service 2) Load balancer associated virtual servers 3) Load balancer associated pools 4) Load balancer associated profiles such as persistence, SSL, application. 5) Load balancer associated monitors 6) Load balancer associated rules   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_service_debug_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: LbServiceDebugInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_service_debug_info_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_service_debug_info_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_service_debug_info_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Read the debug information of the load balancer service  # noqa: E501

        API to download below information which will be used for debugging and troubleshooting. 1) Load balancer service 2) Load balancer associated virtual servers 3) Load balancer associated pools 4) Load balancer associated profiles such as persistence, SSL, application. 5) Load balancer associated monitors 6) Load balancer associated rules   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_service_debug_info_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: LbServiceDebugInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_service_debug_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `read_load_balancer_service_debug_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/debug-info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServiceDebugInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_service_usage(self, service_id, **kwargs):  # noqa: E501
        """Read the usage information of the given load balancer service  # noqa: E501

        API to fetch the capacity and current usage of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_service_usage(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: LbServiceUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_service_usage_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_service_usage_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_service_usage_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Read the usage information of the given load balancer service  # noqa: E501

        API to fetch the capacity and current usage of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_service_usage_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: LbServiceUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_service_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `read_load_balancer_service_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServiceUsage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_virtual_server(self, virtual_server_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer virtual server  # noqa: E501

        Retrieve a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_virtual_server(virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str virtual_server_id: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_load_balancer_virtual_server_with_http_info(virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_virtual_server_with_http_info(virtual_server_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_virtual_server_with_http_info(self, virtual_server_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer virtual server  # noqa: E501

        Retrieve a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_load_balancer_virtual_server_with_http_info(virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str virtual_server_id: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['virtual_server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_virtual_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `read_load_balancer_virtual_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers/{virtual-server-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_application_profile(self, body, application_profile_id, **kwargs):  # noqa: E501
        """Update a load balancer application profile  # noqa: E501

        Update a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_application_profile(body, application_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbAppProfile body: (required)
        :param str application_profile_id: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_application_profile_with_http_info(body, application_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_application_profile_with_http_info(body, application_profile_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_application_profile_with_http_info(self, body, application_profile_id, **kwargs):  # noqa: E501
        """Update a load balancer application profile  # noqa: E501

        Update a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_application_profile_with_http_info(body, application_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbAppProfile body: (required)
        :param str application_profile_id: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'application_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_application_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_application_profile`")  # noqa: E501
        # verify the required parameter 'application_profile_id' is set
        if ('application_profile_id' not in params or
                params['application_profile_id'] is None):
            raise ValueError("Missing the required parameter `application_profile_id` when calling `update_load_balancer_application_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_profile_id' in params:
            path_params['application-profile-id'] = params['application_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles/{application-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbAppProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_client_ssl_profile(self, body, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Update a load balancer client-ssl profile  # noqa: E501

        Update a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_client_ssl_profile(body, client_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbClientSslProfile body: (required)
        :param str client_ssl_profile_id: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_client_ssl_profile_with_http_info(body, client_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_client_ssl_profile_with_http_info(body, client_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_client_ssl_profile_with_http_info(self, body, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Update a load balancer client-ssl profile  # noqa: E501

        Update a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_client_ssl_profile_with_http_info(body, client_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbClientSslProfile body: (required)
        :param str client_ssl_profile_id: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'client_ssl_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_client_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_client_ssl_profile`")  # noqa: E501
        # verify the required parameter 'client_ssl_profile_id' is set
        if ('client_ssl_profile_id' not in params or
                params['client_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `client_ssl_profile_id` when calling `update_load_balancer_client_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_ssl_profile_id' in params:
            path_params['client-ssl-profile-id'] = params['client_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbClientSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_monitor(self, body, monitor_id, **kwargs):  # noqa: E501
        """Update a load balancer monitor  # noqa: E501

        Update a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_monitor(body, monitor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbMonitor body: (required)
        :param str monitor_id: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_monitor_with_http_info(body, monitor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_monitor_with_http_info(body, monitor_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_monitor_with_http_info(self, body, monitor_id, **kwargs):  # noqa: E501
        """Update a load balancer monitor  # noqa: E501

        Update a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_monitor_with_http_info(body, monitor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbMonitor body: (required)
        :param str monitor_id: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'monitor_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_monitor`")  # noqa: E501
        # verify the required parameter 'monitor_id' is set
        if ('monitor_id' not in params or
                params['monitor_id'] is None):
            raise ValueError("Missing the required parameter `monitor_id` when calling `update_load_balancer_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_id' in params:
            path_params['monitor-id'] = params['monitor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors/{monitor-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbMonitor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_persistence_profile(self, body, persistence_profile_id, **kwargs):  # noqa: E501
        """Update a load balancer persistence profile  # noqa: E501

        Update a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_persistence_profile(body, persistence_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbPersistenceProfile body: (required)
        :param str persistence_profile_id: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_persistence_profile_with_http_info(body, persistence_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_persistence_profile_with_http_info(body, persistence_profile_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_persistence_profile_with_http_info(self, body, persistence_profile_id, **kwargs):  # noqa: E501
        """Update a load balancer persistence profile  # noqa: E501

        Update a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_persistence_profile_with_http_info(body, persistence_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbPersistenceProfile body: (required)
        :param str persistence_profile_id: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'persistence_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_persistence_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_persistence_profile`")  # noqa: E501
        # verify the required parameter 'persistence_profile_id' is set
        if ('persistence_profile_id' not in params or
                params['persistence_profile_id'] is None):
            raise ValueError("Missing the required parameter `persistence_profile_id` when calling `update_load_balancer_persistence_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'persistence_profile_id' in params:
            path_params['persistence-profile-id'] = params['persistence_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles/{persistence-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPersistenceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_pool(self, body, pool_id, **kwargs):  # noqa: E501
        """Update a load balancer pool  # noqa: E501

        Update a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_pool(body, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbPool body: (required)
        :param str pool_id: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_pool_with_http_info(body, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_pool_with_http_info(body, pool_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_pool_with_http_info(self, body, pool_id, **kwargs):  # noqa: E501
        """Update a load balancer pool  # noqa: E501

        Update a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_pool_with_http_info(body, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbPool body: (required)
        :param str pool_id: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `update_load_balancer_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools/{pool-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_rule(self, body, rule_id, **kwargs):  # noqa: E501
        """Update a load balancer rule  # noqa: E501

        Update a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_rule(body, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbRule body: (required)
        :param str rule_id: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_rule_with_http_info(body, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_rule_with_http_info(body, rule_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_rule_with_http_info(self, body, rule_id, **kwargs):  # noqa: E501
        """Update a load balancer rule  # noqa: E501

        Update a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_rule_with_http_info(body, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbRule body: (required)
        :param str rule_id: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `update_load_balancer_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules/{rule-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_server_ssl_profile(self, body, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Update a load balancer server-ssl profile  # noqa: E501

        Update a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_server_ssl_profile(body, server_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbServerSslProfile body: (required)
        :param str server_ssl_profile_id: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_server_ssl_profile_with_http_info(body, server_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_server_ssl_profile_with_http_info(body, server_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_server_ssl_profile_with_http_info(self, body, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Update a load balancer server-ssl profile  # noqa: E501

        Update a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_server_ssl_profile_with_http_info(body, server_ssl_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbServerSslProfile body: (required)
        :param str server_ssl_profile_id: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_ssl_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_server_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_server_ssl_profile`")  # noqa: E501
        # verify the required parameter 'server_ssl_profile_id' is set
        if ('server_ssl_profile_id' not in params or
                params['server_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `server_ssl_profile_id` when calling `update_load_balancer_server_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_ssl_profile_id' in params:
            path_params['server-ssl-profile-id'] = params['server_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServerSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_service(self, body, service_id, **kwargs):  # noqa: E501
        """Update a load balancer service  # noqa: E501

        Update a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_service(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbService body: (required)
        :param str service_id: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_service_with_http_info(body, service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_service_with_http_info(body, service_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_service_with_http_info(self, body, service_id, **kwargs):  # noqa: E501
        """Update a load balancer service  # noqa: E501

        Update a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_service_with_http_info(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbService body: (required)
        :param str service_id: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_service`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_load_balancer_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbService',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_virtual_server(self, body, virtual_server_id, **kwargs):  # noqa: E501
        """Update a load balancer virtual server  # noqa: E501

        Update a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_virtual_server(body, virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbVirtualServer body: (required)
        :param str virtual_server_id: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_virtual_server_with_http_info(body, virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_virtual_server_with_http_info(body, virtual_server_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_virtual_server_with_http_info(self, body, virtual_server_id, **kwargs):  # noqa: E501
        """Update a load balancer virtual server  # noqa: E501

        Update a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_virtual_server_with_http_info(body, virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbVirtualServer body: (required)
        :param str virtual_server_id: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'virtual_server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_virtual_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_virtual_server`")  # noqa: E501
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `update_load_balancer_virtual_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers/{virtual-server-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_virtual_server_with_rules_update_with_rules(self, body, virtual_server_id, **kwargs):  # noqa: E501
        """Update a load balancer virtual server with rules  # noqa: E501

        It is used to update virtual servers, the associated rules and update the binding of virtual server and rules. To add new rules, make sure the rules which have no identifier specified, the new rules are automatically generated and associated to the virtual server. To delete old rules, the rules should not be configured in new action, the UUID of deleted rules should be also removed from rule_ids. To update rules, the rules should be specified with new change and configured with identifier. If there are some rules which are not modified, those rule should not be specified in the rules list, the UUID list of rules should be specified in rule_ids of LbVirtualServer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_virtual_server_with_rules_update_with_rules(body, virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbVirtualServerWithRule body: (required)
        :param str virtual_server_id: (required)
        :return: LbVirtualServerWithRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_virtual_server_with_rules_update_with_rules_with_http_info(body, virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_virtual_server_with_rules_update_with_rules_with_http_info(body, virtual_server_id, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_virtual_server_with_rules_update_with_rules_with_http_info(self, body, virtual_server_id, **kwargs):  # noqa: E501
        """Update a load balancer virtual server with rules  # noqa: E501

        It is used to update virtual servers, the associated rules and update the binding of virtual server and rules. To add new rules, make sure the rules which have no identifier specified, the new rules are automatically generated and associated to the virtual server. To delete old rules, the rules should not be configured in new action, the UUID of deleted rules should be also removed from rule_ids. To update rules, the rules should be specified with new change and configured with identifier. If there are some rules which are not modified, those rule should not be specified in the rules list, the UUID list of rules should be specified in rule_ids of LbVirtualServer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_virtual_server_with_rules_update_with_rules_with_http_info(body, virtual_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LbVirtualServerWithRule body: (required)
        :param str virtual_server_id: (required)
        :return: LbVirtualServerWithRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'virtual_server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_virtual_server_with_rules_update_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer_virtual_server_with_rules_update_with_rules`")  # noqa: E501
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `update_load_balancer_virtual_server_with_rules_update_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers/{virtual-server-id}?action=update_with_rules', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerWithRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
