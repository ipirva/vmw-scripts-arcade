# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class SystemAdministrationSettingsCertificatesCSRApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_crl_import(self, body, **kwargs):  # noqa: E501
        """Add a New Certificate Revocation List  # noqa: E501

        Adds a new certificate revocation list (CRL). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_crl_import(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CrlObjectData body: (required)
        :return: CrlList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_crl_import_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_crl_import_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_crl_import_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add a New Certificate Revocation List  # noqa: E501

        Adds a new certificate revocation list (CRL). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_crl_import_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CrlObjectData body: (required)
        :return: CrlList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_crl_import" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_crl_import`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls?action=import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrlList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_crl(self, crl_id, **kwargs):  # noqa: E501
        """Delete a CRL  # noqa: E501

        Deletes an existing CRL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_crl(crl_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crl_id: ID of CRL to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_crl_with_http_info(crl_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_crl_with_http_info(crl_id, **kwargs)  # noqa: E501
            return data

    def delete_crl_with_http_info(self, crl_id, **kwargs):  # noqa: E501
        """Delete a CRL  # noqa: E501

        Deletes an existing CRL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_crl_with_http_info(crl_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crl_id: ID of CRL to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crl_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_crl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crl_id' is set
        if ('crl_id' not in params or
                params['crl_id'] is None):
            raise ValueError("Missing the required parameter `crl_id` when calling `delete_crl`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crl_id' in params:
            path_params['crl-id'] = params['crl_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls/{crl-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_csr(self, csr_id, **kwargs):  # noqa: E501
        """Delete a CSR  # noqa: E501

        Removes a specified CSR. If a CSR is not used for verification, you can delete it. Note that the CSR import and upload POST actions automatically delete the associated CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_csr(csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str csr_id: ID of CSR to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_csr_with_http_info(csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_csr_with_http_info(csr_id, **kwargs)  # noqa: E501
            return data

    def delete_csr_with_http_info(self, csr_id, **kwargs):  # noqa: E501
        """Delete a CSR  # noqa: E501

        Removes a specified CSR. If a CSR is not used for verification, you can delete it. Note that the CSR import and upload POST actions automatically delete the associated CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_csr_with_http_info(csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str csr_id: ID of CSR to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_csr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `delete_csr`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_csr(self, body, **kwargs):  # noqa: E501
        """Generate a New Certificate Signing Request  # noqa: E501

        Creates a new certificate signing request (CSR). A CSR is encrypted text that contains information about your organization (organization name, country, and so on) and your Web server's public key, which is a public certificate the is generated on the server that can be used to forward this request to a certificate authority (CA). A private key is also usually created at the same time as the CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_csr(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Csr body: (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.generate_csr_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_csr_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def generate_csr_with_http_info(self, body, **kwargs):  # noqa: E501
        """Generate a New Certificate Signing Request  # noqa: E501

        Creates a new certificate signing request (CSR). A CSR is encrypted text that contains information about your organization (organization name, country, and so on) and your Web server's public key, which is a public certificate the is generated on the server that can be used to forward this request to a certificate authority (CA). A private key is also usually created at the same time as the CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_csr_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Csr body: (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_csr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `generate_csr`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Csr',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crl(self, crl_id, **kwargs):  # noqa: E501
        """Show CRL Data for the Given CRL ID  # noqa: E501

        Returns information about the specified CRL. For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_crl(crl_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crl_id: ID of CRL to read (required)
        :param bool details: whether to expand the pem data and show all its details
        :return: Crl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_crl_with_http_info(crl_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_crl_with_http_info(crl_id, **kwargs)  # noqa: E501
            return data

    def get_crl_with_http_info(self, crl_id, **kwargs):  # noqa: E501
        """Show CRL Data for the Given CRL ID  # noqa: E501

        Returns information about the specified CRL. For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_crl_with_http_info(crl_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crl_id: ID of CRL to read (required)
        :param bool details: whether to expand the pem data and show all its details
        :return: Crl
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crl_id', 'details']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crl_id' is set
        if ('crl_id' not in params or
                params['crl_id'] is None):
            raise ValueError("Missing the required parameter `crl_id` when calling `get_crl`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crl_id' in params:
            path_params['crl-id'] = params['crl_id']  # noqa: E501

        query_params = []
        if 'details' in params:
            query_params.append(('details', params['details']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls/{crl-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Crl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crls(self, **kwargs):  # noqa: E501
        """Return All Added CRLs  # noqa: E501

        Returns information about all CRLs. For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_crls(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool details: whether to expand the pem data and show all its details
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: Type of certificate to return
        :return: CrlList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_crls_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crls_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crls_with_http_info(self, **kwargs):  # noqa: E501
        """Return All Added CRLs  # noqa: E501

        Returns information about all CRLs. For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_crls_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool details: whether to expand the pem data and show all its details
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: Type of certificate to return
        :return: CrlList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'details', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crls" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'details' in params:
            query_params.append(('details', params['details']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrlList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_csr(self, csr_id, **kwargs):  # noqa: E501
        """Show CSR Data for the Given CSR ID  # noqa: E501

        Returns information about the specified CSR.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_csr(csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str csr_id: ID of CSR to read (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_csr_with_http_info(csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_csr_with_http_info(csr_id, **kwargs)  # noqa: E501
            return data

    def get_csr_with_http_info(self, csr_id, **kwargs):  # noqa: E501
        """Show CSR Data for the Given CSR ID  # noqa: E501

        Returns information about the specified CSR.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_csr_with_http_info(csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str csr_id: ID of CSR to read (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_csr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `get_csr`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Csr',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_csr_pem(self, csr_id, **kwargs):  # noqa: E501
        """Get CSR PEM File for the Given CSR ID  # noqa: E501

        Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_csr_pem(csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str csr_id: ID of CSR to read (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_csr_pem_with_http_info(csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_csr_pem_with_http_info(csr_id, **kwargs)  # noqa: E501
            return data

    def get_csr_pem_with_http_info(self, csr_id, **kwargs):  # noqa: E501
        """Get CSR PEM File for the Given CSR ID  # noqa: E501

        Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_csr_pem_with_http_info(csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str csr_id: ID of CSR to read (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_csr_pem" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `get_csr_pem`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain;charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}/pem-file', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_csrs(self, **kwargs):  # noqa: E501
        """Return All the Generated CSRs  # noqa: E501

        Returns information about all of the CSRs that have been created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_csrs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CsrList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_csrs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_csrs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_csrs_with_http_info(self, **kwargs):  # noqa: E501
        """Return All the Generated CSRs  # noqa: E501

        Returns information about all of the CSRs that have been created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_csrs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CsrList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_csrs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CsrList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_trust_objects(self, **kwargs):  # noqa: E501
        """Return the Properties of a Trust Manager  # noqa: E501

        Returns information about the supported algorithms and key sizes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_trust_objects(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TrustManagementData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_trust_objects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_trust_objects_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_trust_objects_with_http_info(self, **kwargs):  # noqa: E501
        """Return the Properties of a Trust Manager  # noqa: E501

        Returns information about the supported algorithms and key sizes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_trust_objects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TrustManagementData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trust_objects" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrustManagementData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_certificate_import(self, body, csr_id, **kwargs):  # noqa: E501
        """Import a Certificate Associated with an Approved CSR  # noqa: E501

        Imports a certificate authority (CA)-signed certificate for a CSR. This action links the certificate to the private key created by the CSR. The pem_encoded string in the request body is the signed certificate provided by your CA in response to the CSR that you provide to them. The import POST action automatically deletes the associated CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_certificate_import(body, csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TrustObjectData body: (required)
        :param str csr_id: CSR this certificate is associated with (required)
        :return: CertificateList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_certificate_import_with_http_info(body, csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.import_certificate_import_with_http_info(body, csr_id, **kwargs)  # noqa: E501
            return data

    def import_certificate_import_with_http_info(self, body, csr_id, **kwargs):  # noqa: E501
        """Import a Certificate Associated with an Approved CSR  # noqa: E501

        Imports a certificate authority (CA)-signed certificate for a CSR. This action links the certificate to the private key created by the CSR. The pem_encoded string in the request body is the signed certificate provided by your CA in response to the CSR that you provide to them. The import POST action automatically deletes the associated CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_certificate_import_with_http_info(body, csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TrustObjectData body: (required)
        :param str csr_id: CSR this certificate is associated with (required)
        :return: CertificateList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'csr_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_certificate_import" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `import_certificate_import`")  # noqa: E501
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `import_certificate_import`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}?action=import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def self_sign_certificate_self_sign(self, csr_id, days_valid, **kwargs):  # noqa: E501
        """Self-Sign the CSR  # noqa: E501

        Self-signs the previously generated CSR. This action is similar to the import certificate action, but instead of using a public certificate signed by a CA, the self_sign POST action uses a certificate that is signed with NSX's own private key. For validity, if a value greater than 825 days is provided, it will be set to 825 days.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.self_sign_certificate_self_sign(csr_id, days_valid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str csr_id: CSR this certificate is associated with (required)
        :param int days_valid: Number of days the certificate will be valid, default 825 days (required)
        :return: Certificate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.self_sign_certificate_self_sign_with_http_info(csr_id, days_valid, **kwargs)  # noqa: E501
        else:
            (data) = self.self_sign_certificate_self_sign_with_http_info(csr_id, days_valid, **kwargs)  # noqa: E501
            return data

    def self_sign_certificate_self_sign_with_http_info(self, csr_id, days_valid, **kwargs):  # noqa: E501
        """Self-Sign the CSR  # noqa: E501

        Self-signs the previously generated CSR. This action is similar to the import certificate action, but instead of using a public certificate signed by a CA, the self_sign POST action uses a certificate that is signed with NSX's own private key. For validity, if a value greater than 825 days is provided, it will be set to 825 days.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.self_sign_certificate_self_sign_with_http_info(csr_id, days_valid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str csr_id: CSR this certificate is associated with (required)
        :param int days_valid: Number of days the certificate will be valid, default 825 days (required)
        :return: Certificate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id', 'days_valid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method self_sign_certificate_self_sign" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `self_sign_certificate_self_sign`")  # noqa: E501
        # verify the required parameter 'days_valid' is set
        if ('days_valid' not in params or
                params['days_valid'] is None):
            raise ValueError("Missing the required parameter `days_valid` when calling `self_sign_certificate_self_sign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []
        if 'days_valid' in params:
            query_params.append(('days_valid', params['days_valid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}?action=self_sign', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Certificate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_crl(self, body, crl_id, **kwargs):  # noqa: E501
        """Update CRL for the Given CRL ID  # noqa: E501

        Updates an existing CRL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_crl(body, crl_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Crl body: (required)
        :param str crl_id: ID of CRL to update (required)
        :return: Crl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_crl_with_http_info(body, crl_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_crl_with_http_info(body, crl_id, **kwargs)  # noqa: E501
            return data

    def update_crl_with_http_info(self, body, crl_id, **kwargs):  # noqa: E501
        """Update CRL for the Given CRL ID  # noqa: E501

        Updates an existing CRL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_crl_with_http_info(body, crl_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Crl body: (required)
        :param str crl_id: ID of CRL to update (required)
        :return: Crl
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'crl_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_crl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_crl`")  # noqa: E501
        # verify the required parameter 'crl_id' is set
        if ('crl_id' not in params or
                params['crl_id'] is None):
            raise ValueError("Missing the required parameter `crl_id` when calling `update_crl`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crl_id' in params:
            path_params['crl-id'] = params['crl_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls/{crl-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Crl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
