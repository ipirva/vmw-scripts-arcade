# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPISecurityServicesServiceInsertionApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_instance_endpoint(self, body, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Add an InstanceEndpoint for a Service Instance  # noqa: E501

        Adds a new instance endpoint. It belongs to one service instance and is attached to one service attachment. It represents a redirection target for a Rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_instance_endpoint(body, service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InstanceEndpoint body: (required)
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: InstanceEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_instance_endpoint_with_http_info(body, service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_instance_endpoint_with_http_info(body, service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def add_instance_endpoint_with_http_info(self, body, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Add an InstanceEndpoint for a Service Instance  # noqa: E501

        Adds a new instance endpoint. It belongs to one service instance and is attached to one service attachment. It represents a redirection target for a Rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_instance_endpoint_with_http_info(body, service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InstanceEndpoint body: (required)
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: InstanceEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_instance_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_instance_endpoint`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `add_instance_endpoint`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `add_instance_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-endpoints', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_attachment(self, body, **kwargs):  # noqa: E501
        """Add a Service Attachment.  # noqa: E501

        Adds a new Service attachment. A service attachment represents a point on NSX entity (Example: Logical Router) to which service instance can be connected through an InstanceEndpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_attachment(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceAttachment body: (required)
        :return: ServiceAttachment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_attachment_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_attachment_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_service_attachment_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add a Service Attachment.  # noqa: E501

        Adds a new Service attachment. A service attachment represents a point on NSX entity (Example: Logical Router) to which service instance can be connected through an InstanceEndpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_attachment_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceAttachment body: (required)
        :return: ServiceAttachment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-attachments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceAttachment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_chain(self, body, **kwargs):  # noqa: E501
        """Add Service Chain  # noqa: E501

        Adds a new service chain. Service Chains is can contain profile belonging to same or different Service(s). It represents a redirection target for a Rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_chain(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceChain body: (required)
        :return: ServiceChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_chain_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_chain_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_service_chain_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add Service Chain  # noqa: E501

        Adds a new service chain. Service Chains is can contain profile belonging to same or different Service(s). It represents a redirection target for a Rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_chain_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceChain body: (required)
        :return: ServiceChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_chain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_chain`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-chains', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_insertion_exclude_list_member_add_member(self, body, **kwargs):  # noqa: E501
        """Add a new member in the exclude list  # noqa: E501

        Note- POST serviceinsertion excludelist API is deprecated. Please use the policy serviceinsertion excludelist API instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_exclude_list_member_add_member(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ResourceReference body: (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_insertion_exclude_list_member_add_member_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_insertion_exclude_list_member_add_member_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_service_insertion_exclude_list_member_add_member_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add a new member in the exclude list  # noqa: E501

        Note- POST serviceinsertion excludelist API is deprecated. Please use the policy serviceinsertion excludelist API instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_exclude_list_member_add_member_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ResourceReference body: (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_insertion_exclude_list_member_add_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_insertion_exclude_list_member_add_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/excludelist?action=add_member', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceReference',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_insertion_rule_in_section(self, body, section_id, **kwargs):  # noqa: E501
        """Add a Single Rule in a Section  # noqa: E501

        Adds a new serviceinsertion rule in existing serviceinsertion section. Note- POST service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_rule_in_section(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionRule body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_insertion_rule_in_section_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_insertion_rule_in_section_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def add_service_insertion_rule_in_section_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Add a Single Rule in a Section  # noqa: E501

        Adds a new serviceinsertion rule in existing serviceinsertion section. Note- POST service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_rule_in_section_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionRule body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_insertion_rule_in_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_insertion_rule_in_section`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `add_service_insertion_rule_in_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_insertion_rules_in_section_create_multiple(self, body, section_id, **kwargs):  # noqa: E501
        """Add Multiple Rules in a Section  # noqa: E501

        Create multiple serviceinsertion rules in existing serviceinsertion section bounded by limit of 1000 serviceinsertion rules per section. Note- POST service insertion rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_rules_in_section_create_multiple(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionRuleList body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_insertion_rules_in_section_create_multiple_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_insertion_rules_in_section_create_multiple_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def add_service_insertion_rules_in_section_create_multiple_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Add Multiple Rules in a Section  # noqa: E501

        Create multiple serviceinsertion rules in existing serviceinsertion section bounded by limit of 1000 serviceinsertion rules per section. Note- POST service insertion rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_rules_in_section_create_multiple_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionRuleList body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_insertion_rules_in_section_create_multiple" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_insertion_rules_in_section_create_multiple`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `add_service_insertion_rules_in_section_create_multiple`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}/rules?action=create_multiple', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_insertion_section(self, body, **kwargs):  # noqa: E501
        """Create a New Empty Section  # noqa: E501

        Creates new empty Service Insertion section in the system. Note- POST service insertion section API is deprecated. Please use the policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_section(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSection body: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_insertion_section_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_insertion_section_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_service_insertion_section_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a New Empty Section  # noqa: E501

        Creates new empty Service Insertion section in the system. Note- POST service insertion section API is deprecated. Please use the policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_section_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSection body: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_insertion_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_insertion_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_insertion_section_with_rules_create_with_rules(self, body, **kwargs):  # noqa: E501
        """Create a Section with Rules  # noqa: E501

        Creates a new serviceinsertion section with rules. The limit on the number of rules is defined by maxItems in collection types for ServiceInsertionRule (ServiceInsertionRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules are not supported.  Instead, to create sections, use: POST /api/v1/serviceinsertion/sections  To create rules, use: POST /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules Note- POST service insertion section creation with rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_section_with_rules_create_with_rules(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSectionRuleList body: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_insertion_section_with_rules_create_with_rules_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_insertion_section_with_rules_create_with_rules_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_service_insertion_section_with_rules_create_with_rules_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Section with Rules  # noqa: E501

        Creates a new serviceinsertion section with rules. The limit on the number of rules is defined by maxItems in collection types for ServiceInsertionRule (ServiceInsertionRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules are not supported.  Instead, to create sections, use: POST /api/v1/serviceinsertion/sections  To create rules, use: POST /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules Note- POST service insertion section creation with rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_section_with_rules_create_with_rules_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSectionRuleList body: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_insertion_section_with_rules_create_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_insertion_section_with_rules_create_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections?action=create_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_insertion_service(self, body, **kwargs):  # noqa: E501
        """Create a Service-Insertion Service  # noqa: E501

        Creates new Service-Insertion Service in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_service(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceDefinition body: (required)
        :return: ServiceDefinition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_insertion_service_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_insertion_service_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_service_insertion_service_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Service-Insertion Service  # noqa: E501

        Creates new Service-Insertion Service in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_insertion_service_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceDefinition body: (required)
        :return: ServiceDefinition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_insertion_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_insertion_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceDefinition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_service_instance(self, body, service_id, **kwargs):  # noqa: E501
        """Add a Service Instance for a specified Service.  # noqa: E501

        Adds a new Service-Instance under the specified Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_instance(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseServiceInstance body: (required)
        :param str service_id: (required)
        :return: BaseServiceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_service_instance_with_http_info(body, service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_service_instance_with_http_info(body, service_id, **kwargs)  # noqa: E501
            return data

    def add_service_instance_with_http_info(self, body, service_id, **kwargs):  # noqa: E501
        """Add a Service Instance for a specified Service.  # noqa: E501

        Adds a new Service-Instance under the specified Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_service_instance_with_http_info(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseServiceInstance body: (required)
        :param str service_id: (required)
        :return: BaseServiceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_service_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_service_instance`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `add_service_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseServiceInstance',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_si_service_profile(self, body, service_id, **kwargs):  # noqa: E501
        """Add ServiceProfile for a given Service.  # noqa: E501

        Adds a new service profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_si_service_profile(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseServiceProfile body: (required)
        :param str service_id: (required)
        :return: BaseServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_si_service_profile_with_http_info(body, service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_si_service_profile_with_http_info(body, service_id, **kwargs)  # noqa: E501
            return data

    def add_si_service_profile_with_http_info(self, body, service_id, **kwargs):  # noqa: E501
        """Add ServiceProfile for a given Service.  # noqa: E501

        Adds a new service profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_si_service_profile_with_http_info(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseServiceProfile body: (required)
        :param str service_id: (required)
        :return: BaseServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_si_service_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_si_service_profile`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `add_si_service_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseServiceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_vendor_template(self, body, service_id, **kwargs):  # noqa: E501
        """Add Vendor Template for a given Service  # noqa: E501

        Adds a new vendor template. Vendor templates are service level objects, registered to be used in Service Profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_vendor_template(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VendorTemplate body: (required)
        :param str service_id: (required)
        :return: VendorTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_vendor_template_with_http_info(body, service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_vendor_template_with_http_info(body, service_id, **kwargs)  # noqa: E501
            return data

    def add_vendor_template_with_http_info(self, body, service_id, **kwargs):  # noqa: E501
        """Add Vendor Template for a given Service  # noqa: E501

        Adds a new vendor template. Vendor templates are service level objects, registered to be used in Service Profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_vendor_template_with_http_info(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VendorTemplate body: (required)
        :param str service_id: (required)
        :return: VendorTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_vendor_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_vendor_template`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `add_vendor_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/vendor-templates', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_solution_config(self, body, service_id, **kwargs):  # noqa: E501
        """Add Solution Config for a given Service  # noqa: E501

        Adds a solution config. Solution Config are service level objects, required for configuring the NXGI partner Service after deployment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_solution_config(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SolutionConfig body: (required)
        :param str service_id: (required)
        :return: SolutionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_solution_config_with_http_info(body, service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_solution_config_with_http_info(body, service_id, **kwargs)  # noqa: E501
            return data

    def create_solution_config_with_http_info(self, body, service_id, **kwargs):  # noqa: E501
        """Add Solution Config for a given Service  # noqa: E501

        Adds a solution config. Solution Config are service level objects, required for configuring the NXGI partner Service after deployment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_solution_config_with_http_info(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SolutionConfig body: (required)
        :param str service_id: (required)
        :return: SolutionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_solution_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_solution_config`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `create_solution_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/solution-configs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SolutionConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_instance_endpoint(self, service_id, service_instance_id, instance_endpoint_id, **kwargs):  # noqa: E501
        """Delete a particular InstanceEndpoint.  # noqa: E501

        Delete instance endpoint information for a given instace endpoint. Please make sure to delete all the Service Insertion Rules, which refer to this Endpoint as 'redirect_tos' target.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_instance_endpoint(service_id, service_instance_id, instance_endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_endpoint_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint_id, **kwargs)  # noqa: E501
            return data

    def delete_instance_endpoint_with_http_info(self, service_id, service_instance_id, instance_endpoint_id, **kwargs):  # noqa: E501
        """Delete a particular InstanceEndpoint.  # noqa: E501

        Delete instance endpoint information for a given instace endpoint. Please make sure to delete all the Service Insertion Rules, which refer to this Endpoint as 'redirect_tos' target.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_endpoint_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id', 'instance_endpoint_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_instance_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_instance_endpoint`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `delete_instance_endpoint`")  # noqa: E501
        # verify the required parameter 'instance_endpoint_id' is set
        if ('instance_endpoint_id' not in params or
                params['instance_endpoint_id'] is None):
            raise ValueError("Missing the required parameter `instance_endpoint_id` when calling `delete_instance_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501
        if 'instance_endpoint_id' in params:
            path_params['instance-endpoint-id'] = params['instance_endpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-endpoints/{instance-endpoint-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_attachment(self, service_attachment_id, **kwargs):  # noqa: E501
        """Delete an existing service attachment  # noqa: E501

        Delete existing service attachment from system. Before deletion, please make sure that, no instance endpoints are connected to this attachment. In turn no appliance should be connected to this attachment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_attachment(service_attachment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_attachment_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_attachment_with_http_info(service_attachment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_attachment_with_http_info(service_attachment_id, **kwargs)  # noqa: E501
            return data

    def delete_service_attachment_with_http_info(self, service_attachment_id, **kwargs):  # noqa: E501
        """Delete an existing service attachment  # noqa: E501

        Delete existing service attachment from system. Before deletion, please make sure that, no instance endpoints are connected to this attachment. In turn no appliance should be connected to this attachment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_attachment_with_http_info(service_attachment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_attachment_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_attachment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_attachment_id' is set
        if ('service_attachment_id' not in params or
                params['service_attachment_id'] is None):
            raise ValueError("Missing the required parameter `service_attachment_id` when calling `delete_service_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_attachment_id' in params:
            path_params['service-attachment-id'] = params['service_attachment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-attachments/{service-attachment-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_chain(self, service_chain_id, **kwargs):  # noqa: E501
        """Delete a Service Chain.  # noqa: E501

        Delete a particular service chain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_chain(service_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_chain_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_chain_with_http_info(service_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_chain_with_http_info(service_chain_id, **kwargs)  # noqa: E501
            return data

    def delete_service_chain_with_http_info(self, service_chain_id, **kwargs):  # noqa: E501
        """Delete a Service Chain.  # noqa: E501

        Delete a particular service chain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_chain_with_http_info(service_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_chain_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_chain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_chain_id' is set
        if ('service_chain_id' not in params or
                params['service_chain_id'] is None):
            raise ValueError("Missing the required parameter `service_chain_id` when calling `delete_service_chain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_chain_id' in params:
            path_params['service-chain-id'] = params['service_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-chains/{service-chain-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_deployment(self, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Remove service deployment  # noqa: E501

        Remove the service deployment. Will remove all the Service VMs that were created as part of this deployment. User can send optional force delete option which will force remove the deployment, but should be used only when the regular delete is not working. Regular delete will ensure proper cleanup of Service VMs and related objects. Directly calling this API without trying regular undeploy will result in unexpected results, and orphan objects.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_deployment(service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_deployment_with_http_info(service_id, service_deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_deployment_with_http_info(service_id, service_deployment_id, **kwargs)  # noqa: E501
            return data

    def delete_service_deployment_with_http_info(self, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Remove service deployment  # noqa: E501

        Remove the service deployment. Will remove all the Service VMs that were created as part of this deployment. User can send optional force delete option which will force remove the deployment, but should be used only when the regular delete is not working. Regular delete will ensure proper cleanup of Service VMs and related objects. Directly calling this API without trying regular undeploy will result in unexpected results, and orphan objects.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_deployment_with_http_info(service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_deployment_id', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_deployment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_service_deployment`")  # noqa: E501
        # verify the required parameter 'service_deployment_id' is set
        if ('service_deployment_id' not in params or
                params['service_deployment_id'] is None):
            raise ValueError("Missing the required parameter `service_deployment_id` when calling `delete_service_deployment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_deployment_id' in params:
            path_params['service-deployment-id'] = params['service_deployment_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-deployments/{service-deployment-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_insertion_rule(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Delete an Existing Rule  # noqa: E501

        Delete existing serviceinsertion rule in a serviceinsertion section. Note- DELETE service insertion rule API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_insertion_rule(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_insertion_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_insertion_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def delete_service_insertion_rule_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Delete an Existing Rule  # noqa: E501

        Delete existing serviceinsertion rule in a serviceinsertion section. Note- DELETE service insertion rule API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_insertion_rule_with_http_info(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_insertion_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `delete_service_insertion_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_service_insertion_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}/rules/{rule-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_insertion_section(self, section_id, **kwargs):  # noqa: E501
        """Delete an Existing Section and Its Associated Rules  # noqa: E501

        Removes serviceinsertion section from the system. ServiceInsertion section with rules can only be deleted by passing \"cascade=true\" parameter. Note- DELETE service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_insertion_section(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param bool cascade: Flag to cascade delete of this object to all it's child objects.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_insertion_section_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_insertion_section_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def delete_service_insertion_section_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Delete an Existing Section and Its Associated Rules  # noqa: E501

        Removes serviceinsertion section from the system. ServiceInsertion section with rules can only be deleted by passing \"cascade=true\" parameter. Note- DELETE service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_insertion_section_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param bool cascade: Flag to cascade delete of this object to all it's child objects.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'cascade']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_insertion_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `delete_service_insertion_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_insertion_service(self, service_id, **kwargs):  # noqa: E501
        """Delete an existing Service and the Service-Instance associated with it.  # noqa: E501

        Removes Service-Insertion Service from the system. A Service with Service-Instances can only be deleted by passing \"cascade=true\" parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_insertion_service(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param bool cascade: Flag to cascade delete all the child objects, associated with it.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_insertion_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_insertion_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def delete_service_insertion_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Delete an existing Service and the Service-Instance associated with it.  # noqa: E501

        Removes Service-Insertion Service from the system. A Service with Service-Instances can only be deleted by passing \"cascade=true\" parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_insertion_service_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param bool cascade: Flag to cascade delete all the child objects, associated with it.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'cascade']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_insertion_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_service_insertion_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_instance(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Delete an existing Service-Instance  # noqa: E501

        Delete existing Service-Instance for a given Service-Insertion Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_instance(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_instance_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_instance_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def delete_service_instance_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Delete an existing Service-Instance  # noqa: E501

        Delete existing Service-Instance for a given Service-Insertion Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_instance_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_service_instance`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `delete_service_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_manager(self, service_manager_id, **kwargs):  # noqa: E501
        """Delete service manager  # noqa: E501

        Delete service-manager which is registered with NSX with basic details like name, username, password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_manager(service_manager_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_manager_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_manager_with_http_info(service_manager_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_manager_with_http_info(service_manager_id, **kwargs)  # noqa: E501
            return data

    def delete_service_manager_with_http_info(self, service_manager_id, **kwargs):  # noqa: E501
        """Delete service manager  # noqa: E501

        Delete service-manager which is registered with NSX with basic details like name, username, password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_manager_with_http_info(service_manager_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_manager_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_manager_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_manager_id' is set
        if ('service_manager_id' not in params or
                params['service_manager_id'] is None):
            raise ValueError("Missing the required parameter `service_manager_id` when calling `delete_service_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_manager_id' in params:
            path_params['service-manager-id'] = params['service_manager_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-managers/{service-manager-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_v_ms_delete(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Remove service VMs either as standalone or HA  # noqa: E501

        Undeploy one service VM as standalone or two service VMs as HA. Associated deployment information and instance runtime will also be deleted once service VMs have been un-deployed successfully.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_v_ms_delete(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_service_v_ms_delete_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_v_ms_delete_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def delete_service_v_ms_delete_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Remove service VMs either as standalone or HA  # noqa: E501

        Undeploy one service VM as standalone or two service VMs as HA. Associated deployment information and instance runtime will also be deleted once service VMs have been un-deployed successfully.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_v_ms_delete_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_v_ms_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_service_v_ms_delete`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `delete_service_v_ms_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes?action=delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_si_service_profile(self, service_id, service_profile_id, **kwargs):  # noqa: E501
        """Delete a particular ServiceProfile.  # noqa: E501

        Delete service profile for a given service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_si_service_profile(service_id, service_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_si_service_profile_with_http_info(service_id, service_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_si_service_profile_with_http_info(service_id, service_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_si_service_profile_with_http_info(self, service_id, service_profile_id, **kwargs):  # noqa: E501
        """Delete a particular ServiceProfile.  # noqa: E501

        Delete service profile for a given service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_si_service_profile_with_http_info(service_id, service_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_si_service_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_si_service_profile`")  # noqa: E501
        # verify the required parameter 'service_profile_id' is set
        if ('service_profile_id' not in params or
                params['service_profile_id'] is None):
            raise ValueError("Missing the required parameter `service_profile_id` when calling `delete_si_service_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_profile_id' in params:
            path_params['service-profile-id'] = params['service_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-profiles/{service-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_solution_config(self, service_id, solution_config_id, **kwargs):  # noqa: E501
        """Deletes solution config information.  # noqa: E501

        Deletes solution config information for a given service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_solution_config(service_id, solution_config_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str solution_config_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_solution_config_with_http_info(service_id, solution_config_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_solution_config_with_http_info(service_id, solution_config_id, **kwargs)  # noqa: E501
            return data

    def delete_solution_config_with_http_info(self, service_id, solution_config_id, **kwargs):  # noqa: E501
        """Deletes solution config information.  # noqa: E501

        Deletes solution config information for a given service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_solution_config_with_http_info(service_id, solution_config_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str solution_config_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'solution_config_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_solution_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_solution_config`")  # noqa: E501
        # verify the required parameter 'solution_config_id' is set
        if ('solution_config_id' not in params or
                params['solution_config_id'] is None):
            raise ValueError("Missing the required parameter `solution_config_id` when calling `delete_solution_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'solution_config_id' in params:
            path_params['solution-config-id'] = params['solution_config_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/solution-configs/{solution-config-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_vendor_template(self, service_id, vendor_template_id, **kwargs):  # noqa: E501
        """Delete a particular vendor tempalte.  # noqa: E501

        Delete vendor template information for a given service. Please make sure to delete all the Service Profile(s), which refer to this vendor tempalte before deleting the template itself.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_vendor_template(service_id, vendor_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str vendor_template_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_vendor_template_with_http_info(service_id, vendor_template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_vendor_template_with_http_info(service_id, vendor_template_id, **kwargs)  # noqa: E501
            return data

    def delete_vendor_template_with_http_info(self, service_id, vendor_template_id, **kwargs):  # noqa: E501
        """Delete a particular vendor tempalte.  # noqa: E501

        Delete vendor template information for a given service. Please make sure to delete all the Service Profile(s), which refer to this vendor tempalte before deleting the template itself.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_vendor_template_with_http_info(service_id, vendor_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str vendor_template_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'vendor_template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_vendor_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_vendor_template`")  # noqa: E501
        # verify the required parameter 'vendor_template_id' is set
        if ('vendor_template_id' not in params or
                params['vendor_template_id'] is None):
            raise ValueError("Missing the required parameter `vendor_template_id` when calling `delete_vendor_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'vendor_template_id' in params:
            path_params['vendor-template-id'] = params['vendor_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/vendor-templates/{vendor-template-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deploy_service(self, body, service_id, **kwargs):  # noqa: E501
        """Deploys a particular service  # noqa: E501

        This will deploy a particular service on a given cluster / host. Internally multiple service instance can be created during the deployment. If there are no issues in the parameters, the call returns immediately, and the service VMs will be deployed asynchronously. To get the overall status of the deployment or to get the status of individual service vm, please use the deployment status APIs.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deploy_service(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceDeployment body: (required)
        :param str service_id: (required)
        :return: ServiceDeployment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.deploy_service_with_http_info(body, service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.deploy_service_with_http_info(body, service_id, **kwargs)  # noqa: E501
            return data

    def deploy_service_with_http_info(self, body, service_id, **kwargs):  # noqa: E501
        """Deploys a particular service  # noqa: E501

        This will deploy a particular service on a given cluster / host. Internally multiple service instance can be created during the deployment. If there are no issues in the parameters, the call returns immediately, and the service VMs will be deployed asynchronously. To get the overall status of the deployment or to get the status of individual service vm, please use the deployment status APIs.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deploy_service_with_http_info(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceDeployment body: (required)
        :param str service_id: (required)
        :return: ServiceDeployment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deploy_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `deploy_service`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `deploy_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-deployments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceDeployment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deploy_service_v_ms_deploy(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Deploy and set up service VMs either as standalone or HA  # noqa: E501

        Deploys one service VM as standalone, or two service VMs as HA where one VM is active and another one is standby.  During the deployment of service VMs, service will be set up based on deployment events using callbacks.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deploy_service_v_ms_deploy(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.deploy_service_v_ms_deploy_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.deploy_service_v_ms_deploy_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def deploy_service_v_ms_deploy_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Deploy and set up service VMs either as standalone or HA  # noqa: E501

        Deploys one service VM as standalone, or two service VMs as HA where one VM is active and another one is standby.  During the deployment of service VMs, service will be set up based on deployment events using callbacks.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deploy_service_v_ms_deploy_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deploy_service_v_ms_deploy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `deploy_service_v_ms_deploy`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `deploy_service_v_ms_deploy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes?action=deploy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_instance_endpoint(self, service_id, service_instance_id, instance_endpoint_id, **kwargs):  # noqa: E501
        """Get a particular instance endpoint for a service instance.  # noqa: E501

        Returns detailed Endpoint information for a given InstanceEndpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_instance_endpoint(service_id, service_instance_id, instance_endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_endpoint_id: (required)
        :return: InstanceEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint_id, **kwargs)  # noqa: E501
            return data

    def get_instance_endpoint_with_http_info(self, service_id, service_instance_id, instance_endpoint_id, **kwargs):  # noqa: E501
        """Get a particular instance endpoint for a service instance.  # noqa: E501

        Returns detailed Endpoint information for a given InstanceEndpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_instance_endpoint_with_http_info(service_id, service_instance_id, instance_endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_endpoint_id: (required)
        :return: InstanceEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id', 'instance_endpoint_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_instance_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_instance_endpoint`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `get_instance_endpoint`")  # noqa: E501
        # verify the required parameter 'instance_endpoint_id' is set
        if ('instance_endpoint_id' not in params or
                params['instance_endpoint_id'] is None):
            raise ValueError("Missing the required parameter `instance_endpoint_id` when calling `get_instance_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501
        if 'instance_endpoint_id' in params:
            path_params['instance-endpoint-id'] = params['instance_endpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-endpoints/{instance-endpoint-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_runtime_interface_operational_status(self, service_id, service_instance_id, instance_runtime_id, interface_index, **kwargs):  # noqa: E501
        """Get operational status for an interface  # noqa: E501

        Returns operational status of a specified interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_interface_operational_status(service_id, service_instance_id, instance_runtime_id, interface_index, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_runtime_id: (required)
        :param str interface_index: (required)
        :param str source: Data source type.
        :return: RuntimeInterfaceOperationalStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_runtime_interface_operational_status_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, **kwargs)  # noqa: E501
        else:
            (data) = self.get_runtime_interface_operational_status_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, **kwargs)  # noqa: E501
            return data

    def get_runtime_interface_operational_status_with_http_info(self, service_id, service_instance_id, instance_runtime_id, interface_index, **kwargs):  # noqa: E501
        """Get operational status for an interface  # noqa: E501

        Returns operational status of a specified interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_interface_operational_status_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_runtime_id: (required)
        :param str interface_index: (required)
        :param str source: Data source type.
        :return: RuntimeInterfaceOperationalStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id', 'instance_runtime_id', 'interface_index', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_runtime_interface_operational_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_runtime_interface_operational_status`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `get_runtime_interface_operational_status`")  # noqa: E501
        # verify the required parameter 'instance_runtime_id' is set
        if ('instance_runtime_id' not in params or
                params['instance_runtime_id'] is None):
            raise ValueError("Missing the required parameter `instance_runtime_id` when calling `get_runtime_interface_operational_status`")  # noqa: E501
        # verify the required parameter 'interface_index' is set
        if ('interface_index' not in params or
                params['interface_index'] is None):
            raise ValueError("Missing the required parameter `interface_index` when calling `get_runtime_interface_operational_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501
        if 'instance_runtime_id' in params:
            path_params['instance-runtime-id'] = params['instance_runtime_id']  # noqa: E501
        if 'interface_index' in params:
            path_params['interface_index'] = params['interface_index']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes/{instance-runtime-id}/interfaces/{interface_index}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuntimeInterfaceOperationalStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_runtime_interface_statistics(self, service_id, service_instance_id, instance_runtime_id, interface_index, **kwargs):  # noqa: E501
        """Get statistics for a given interface identified by the interface index  # noqa: E501

        Returns statistics of a specified interface via associated logical port. If the logical port is attached to a logical router port, query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_interface_statistics(service_id, service_instance_id, instance_runtime_id, interface_index, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_runtime_id: (required)
        :param str interface_index: (required)
        :param str source: Data source type.
        :return: RuntimeInterfaceStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_runtime_interface_statistics_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, **kwargs)  # noqa: E501
        else:
            (data) = self.get_runtime_interface_statistics_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, **kwargs)  # noqa: E501
            return data

    def get_runtime_interface_statistics_with_http_info(self, service_id, service_instance_id, instance_runtime_id, interface_index, **kwargs):  # noqa: E501
        """Get statistics for a given interface identified by the interface index  # noqa: E501

        Returns statistics of a specified interface via associated logical port. If the logical port is attached to a logical router port, query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_interface_statistics_with_http_info(service_id, service_instance_id, instance_runtime_id, interface_index, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_runtime_id: (required)
        :param str interface_index: (required)
        :param str source: Data source type.
        :return: RuntimeInterfaceStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id', 'instance_runtime_id', 'interface_index', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_runtime_interface_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_runtime_interface_statistics`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `get_runtime_interface_statistics`")  # noqa: E501
        # verify the required parameter 'instance_runtime_id' is set
        if ('instance_runtime_id' not in params or
                params['instance_runtime_id'] is None):
            raise ValueError("Missing the required parameter `instance_runtime_id` when calling `get_runtime_interface_statistics`")  # noqa: E501
        # verify the required parameter 'interface_index' is set
        if ('interface_index' not in params or
                params['interface_index'] is None):
            raise ValueError("Missing the required parameter `interface_index` when calling `get_runtime_interface_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501
        if 'instance_runtime_id' in params:
            path_params['instance-runtime-id'] = params['instance_runtime_id']  # noqa: E501
        if 'interface_index' in params:
            path_params['interface_index'] = params['interface_index']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes/{instance-runtime-id}/interfaces/{interface_index}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuntimeInterfaceStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_attachment(self, service_attachment_id, **kwargs):  # noqa: E501
        """Get a particular service attachment.  # noqa: E501

        Returns detailed Attachment information for a given service attachment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_attachment(service_attachment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_attachment_id: (required)
        :return: ServiceAttachment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_attachment_with_http_info(service_attachment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_attachment_with_http_info(service_attachment_id, **kwargs)  # noqa: E501
            return data

    def get_service_attachment_with_http_info(self, service_attachment_id, **kwargs):  # noqa: E501
        """Get a particular service attachment.  # noqa: E501

        Returns detailed Attachment information for a given service attachment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_attachment_with_http_info(service_attachment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_attachment_id: (required)
        :return: ServiceAttachment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_attachment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_attachment_id' is set
        if ('service_attachment_id' not in params or
                params['service_attachment_id'] is None):
            raise ValueError("Missing the required parameter `service_attachment_id` when calling `get_service_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_attachment_id' in params:
            path_params['service-attachment-id'] = params['service_attachment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-attachments/{service-attachment-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceAttachment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_chain(self, service_chain_id, **kwargs):  # noqa: E501
        """Get a particular service chain.  # noqa: E501

        Returns detailed service chain information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_chain(service_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_chain_id: (required)
        :return: ServiceChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_chain_with_http_info(service_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_chain_with_http_info(service_chain_id, **kwargs)  # noqa: E501
            return data

    def get_service_chain_with_http_info(self, service_chain_id, **kwargs):  # noqa: E501
        """Get a particular service chain.  # noqa: E501

        Returns detailed service chain information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_chain_with_http_info(service_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_chain_id: (required)
        :return: ServiceChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_chain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_chain_id' is set
        if ('service_chain_id' not in params or
                params['service_chain_id'] is None):
            raise ValueError("Missing the required parameter `service_chain_id` when calling `get_service_chain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_chain_id' in params:
            path_params['service-chain-id'] = params['service_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-chains/{service-chain-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_deployment(self, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Get a particular service deployment.  # noqa: E501

        Returns detail of service deployment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_deployment(service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :return: ServiceDeployment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_deployment_with_http_info(service_id, service_deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_deployment_with_http_info(service_id, service_deployment_id, **kwargs)  # noqa: E501
            return data

    def get_service_deployment_with_http_info(self, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Get a particular service deployment.  # noqa: E501

        Returns detail of service deployment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_deployment_with_http_info(service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :return: ServiceDeployment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_deployment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_deployment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_deployment`")  # noqa: E501
        # verify the required parameter 'service_deployment_id' is set
        if ('service_deployment_id' not in params or
                params['service_deployment_id'] is None):
            raise ValueError("Missing the required parameter `service_deployment_id` when calling `get_service_deployment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_deployment_id' in params:
            path_params['service-deployment-id'] = params['service_deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-deployments/{service-deployment-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceDeployment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_deployment_state(self, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Get Service-Deployment state for Service.  # noqa: E501

        Returns configuration state of deployed partner service using service insertion framework.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_deployment_state(service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_deployment_state_with_http_info(service_id, service_deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_deployment_state_with_http_info(service_id, service_deployment_id, **kwargs)  # noqa: E501
            return data

    def get_service_deployment_state_with_http_info(self, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Get Service-Deployment state for Service.  # noqa: E501

        Returns configuration state of deployed partner service using service insertion framework.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_deployment_state_with_http_info(service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_deployment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_deployment_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_deployment_state`")  # noqa: E501
        # verify the required parameter 'service_deployment_id' is set
        if ('service_deployment_id' not in params or
                params['service_deployment_id'] is None):
            raise ValueError("Missing the required parameter `service_deployment_id` when calling `get_service_deployment_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_deployment_id' in params:
            path_params['service-deployment-id'] = params['service_deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-deployments/{service-deployment-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigurationState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_deployment_status(self, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Get a particular service deployment status.  # noqa: E501

        Returns current status of the deployment of partner service. Available only for EPP Services. By default this API would return cached status. Caching happens every 3 minutes. For realtime status, query parameter \"source=realtime\" needs to be passed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_deployment_status(service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :param str source: Data source type.
        :return: ServiceDeploymentStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_deployment_status_with_http_info(service_id, service_deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_deployment_status_with_http_info(service_id, service_deployment_id, **kwargs)  # noqa: E501
            return data

    def get_service_deployment_status_with_http_info(self, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Get a particular service deployment status.  # noqa: E501

        Returns current status of the deployment of partner service. Available only for EPP Services. By default this API would return cached status. Caching happens every 3 minutes. For realtime status, query parameter \"source=realtime\" needs to be passed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_deployment_status_with_http_info(service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :param str source: Data source type.
        :return: ServiceDeploymentStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_deployment_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_deployment_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_deployment_status`")  # noqa: E501
        # verify the required parameter 'service_deployment_id' is set
        if ('service_deployment_id' not in params or
                params['service_deployment_id'] is None):
            raise ValueError("Missing the required parameter `service_deployment_id` when calling `get_service_deployment_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_deployment_id' in params:
            path_params['service-deployment-id'] = params['service_deployment_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-deployments/{service-deployment-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceDeploymentStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_deployments(self, service_id, **kwargs):  # noqa: E501
        """Get all service deployments for the given service id  # noqa: E501

        Returns the list of deployments for the given service   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_deployments(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: ServiceDeploymentListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_deployments_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_deployments_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def get_service_deployments_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get all service deployments for the given service id  # noqa: E501

        Returns the list of deployments for the given service   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_deployments_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: ServiceDeploymentListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_deployments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_deployments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-deployments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceDeploymentListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_insertion_exclude_list(self, **kwargs):  # noqa: E501
        """Get list of members in exclude list  # noqa: E501

        Note- GET serviceinsertion excludelist API is deprecated. Please use the policy serviceinsertion excludelist API instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_exclude_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SIExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_insertion_exclude_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_service_insertion_exclude_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_service_insertion_exclude_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of members in exclude list  # noqa: E501

        Note- GET serviceinsertion excludelist API is deprecated. Please use the policy serviceinsertion excludelist API instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_exclude_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SIExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_insertion_exclude_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/excludelist', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SIExcludeList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_insertion_rule(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Read an Existing Rule  # noqa: E501

        Return existing serviceinsertion rule information in a serviceinsertion section. Note- GET service insertion rule API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_rule(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: ServiceInsertionRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_insertion_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_insertion_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_service_insertion_rule_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Read an Existing Rule  # noqa: E501

        Return existing serviceinsertion rule information in a serviceinsertion section. Note- GET service insertion rule API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_rule_with_http_info(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: ServiceInsertionRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_insertion_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_service_insertion_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_service_insertion_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_insertion_rules(self, section_id, **kwargs):  # noqa: E501
        """Get All the Rules for a Section  # noqa: E501

        Return all serviceinsertion rule(s) information for a given serviceinsertion section. Note- GET service insertion rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_rules(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str applied_tos: AppliedTo's referenced by this section or section's Distributed Service Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's Distributed Service Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's Distributed Service Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Distributed Service Rules .
        :return: ServiceInsertionRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_insertion_rules_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_insertion_rules_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_service_insertion_rules_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get All the Rules for a Section  # noqa: E501

        Return all serviceinsertion rule(s) information for a given serviceinsertion section. Note- GET service insertion rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_rules_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str applied_tos: AppliedTo's referenced by this section or section's Distributed Service Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's Distributed Service Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's Distributed Service Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Distributed Service Rules .
        :return: ServiceInsertionRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'applied_tos', 'cursor', 'destinations', 'filter_type', 'included_fields', 'page_size', 'services', 'sort_ascending', 'sort_by', 'sources']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_insertion_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_service_insertion_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_insertion_section(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section  # noqa: E501

        Returns information about serviceinsertion section for the identifier. Note- GET service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_section(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :return: ServiceInsertionSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_insertion_section_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_insertion_section_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_service_insertion_section_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section  # noqa: E501

        Returns information about serviceinsertion section for the identifier. Note- GET service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_section_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :return: ServiceInsertionSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_insertion_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_service_insertion_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_insertion_section_with_rules_list_with_rules(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section, Including Rules  # noqa: E501

        Returns serviceinsertion section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules are not supported.  Instead, to read serviceinsertion rules, use: GET /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules with the appropriate page_size. Note- GET service insertion section with rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_section_with_rules_list_with_rules(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :return: ServiceInsertionSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_insertion_section_with_rules_list_with_rules_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_insertion_section_with_rules_list_with_rules_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_service_insertion_section_with_rules_list_with_rules_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section, Including Rules  # noqa: E501

        Returns serviceinsertion section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules are not supported.  Instead, to read serviceinsertion rules, use: GET /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules with the appropriate page_size. Note- GET service insertion section with rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_section_with_rules_list_with_rules_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :return: ServiceInsertionSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_insertion_section_with_rules_list_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_service_insertion_section_with_rules_list_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}?action=list_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_insertion_service(self, service_id, **kwargs):  # noqa: E501
        """Get an existing Service  # noqa: E501

        Returns information about Service-Insertion Service with the given identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_service(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: ServiceDefinition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_insertion_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_insertion_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def get_service_insertion_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get an existing Service  # noqa: E501

        Returns information about Service-Insertion Service with the given identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_service_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: ServiceDefinition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_insertion_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_insertion_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceDefinition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_insertion_status(self, context_type, **kwargs):  # noqa: E501
        """Get ServiceInsertion global status for a context  # noqa: E501

        Get ServiceInsertion global status for a context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_status(context_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :return: ServiceInsertionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_insertion_status_with_http_info(context_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_insertion_status_with_http_info(context_type, **kwargs)  # noqa: E501
            return data

    def get_service_insertion_status_with_http_info(self, context_type, **kwargs):  # noqa: E501
        """Get ServiceInsertion global status for a context  # noqa: E501

        Get ServiceInsertion global status for a context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_insertion_status_with_http_info(context_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :return: ServiceInsertionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['context_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_insertion_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `get_service_insertion_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/status/{context-type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_instance(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Get Service-Instance for Service.  # noqa: E501

        Returns Service-Instance information for a given Service-Insertion Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_instance(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: BaseServiceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_instance_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_instance_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def get_service_instance_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Get Service-Instance for Service.  # noqa: E501

        Returns Service-Instance information for a given Service-Insertion Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_instance_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: BaseServiceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_instance`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `get_service_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseServiceInstance',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_instance_ns_groups(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Get NSgroups for a given ServiceInstance.  # noqa: E501

        Returns list of NSGroups used in Service Insertion North-South rules for a given Service Instance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_instance_ns_groups(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: ServiceInstanceNSGroups
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_instance_ns_groups_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_instance_ns_groups_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def get_service_instance_ns_groups_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Get NSgroups for a given ServiceInstance.  # noqa: E501

        Returns list of NSGroups used in Service Insertion North-South rules for a given Service Instance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_instance_ns_groups_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: ServiceInstanceNSGroups
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_instance_ns_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_instance_ns_groups`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `get_service_instance_ns_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/group-associations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInstanceNSGroups',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_instance_state(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Get Service-Instance state for Service.  # noqa: E501

        Returns configuration state of one instance of a deployed partner service using service insertion framework.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_instance_state(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_instance_state_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_instance_state_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def get_service_instance_state_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Get Service-Instance state for Service.  # noqa: E501

        Returns configuration state of one instance of a deployed partner service using service insertion framework.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_instance_state_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_instance_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_instance_state`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `get_service_instance_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigurationState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_instance_status(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Get Service-Instance status for Service.  # noqa: E501

        Returns status of one instance of a deployed partner service using service insertion framework. By default this API would return cached status. Caching happens every 3 minutes. For realtime status, query parameter \"source=realtime\" needs to be passed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_instance_status(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str source: Data source type.
        :return: ServiceInstanceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_instance_status_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_instance_status_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def get_service_instance_status_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Get Service-Instance status for Service.  # noqa: E501

        Returns status of one instance of a deployed partner service using service insertion framework. By default this API would return cached status. Caching happens every 3 minutes. For realtime status, query parameter \"source=realtime\" needs to be passed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_instance_status_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str source: Data source type.
        :return: ServiceInstanceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_instance_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_instance_status`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `get_service_instance_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInstanceStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_manager(self, service_manager_id, **kwargs):  # noqa: E501
        """Get service manager  # noqa: E501

        Retrieve service-manager details like name, username, password, vendor ID, thumbprint for a given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_manager(service_manager_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_manager_id: (required)
        :return: ServiceManager
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_manager_with_http_info(service_manager_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_manager_with_http_info(service_manager_id, **kwargs)  # noqa: E501
            return data

    def get_service_manager_with_http_info(self, service_manager_id, **kwargs):  # noqa: E501
        """Get service manager  # noqa: E501

        Retrieve service-manager details like name, username, password, vendor ID, thumbprint for a given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_manager_with_http_info(service_manager_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_manager_id: (required)
        :return: ServiceManager
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_manager_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_manager_id' is set
        if ('service_manager_id' not in params or
                params['service_manager_id'] is None):
            raise ValueError("Missing the required parameter `service_manager_id` when calling `get_service_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_manager_id' in params:
            path_params['service-manager-id'] = params['service_manager_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-managers/{service-manager-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceManager',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_profile_ns_groups(self, service_id, service_profile_id, **kwargs):  # noqa: E501
        """Get NSgroups for a given ServiceProfile.  # noqa: E501

        Returns list of NSGroups used in Service Insertion rules for a given Service Profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_profile_ns_groups(service_id, service_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_profile_id: (required)
        :return: ServiceProfileNSGroups
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_profile_ns_groups_with_http_info(service_id, service_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_profile_ns_groups_with_http_info(service_id, service_profile_id, **kwargs)  # noqa: E501
            return data

    def get_service_profile_ns_groups_with_http_info(self, service_id, service_profile_id, **kwargs):  # noqa: E501
        """Get NSgroups for a given ServiceProfile.  # noqa: E501

        Returns list of NSGroups used in Service Insertion rules for a given Service Profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_profile_ns_groups_with_http_info(service_id, service_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_profile_id: (required)
        :return: ServiceProfileNSGroups
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_profile_ns_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_service_profile_ns_groups`")  # noqa: E501
        # verify the required parameter 'service_profile_id' is set
        if ('service_profile_id' not in params or
                params['service_profile_id'] is None):
            raise ValueError("Missing the required parameter `service_profile_id` when calling `get_service_profile_ns_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_profile_id' in params:
            path_params['service-profile-id'] = params['service_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-profiles/{service-profile-id}/nsgroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceProfileNSGroups',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_si_service_profile(self, service_id, service_profile_id, **kwargs):  # noqa: E501
        """Get a particular ServiceProfile for a Service.  # noqa: E501

        Returns detailed service profile information for a given Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_si_service_profile(service_id, service_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_profile_id: (required)
        :return: BaseServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_si_service_profile_with_http_info(service_id, service_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_si_service_profile_with_http_info(service_id, service_profile_id, **kwargs)  # noqa: E501
            return data

    def get_si_service_profile_with_http_info(self, service_id, service_profile_id, **kwargs):  # noqa: E501
        """Get a particular ServiceProfile for a Service.  # noqa: E501

        Returns detailed service profile information for a given Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_si_service_profile_with_http_info(service_id, service_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_profile_id: (required)
        :return: BaseServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_si_service_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_si_service_profile`")  # noqa: E501
        # verify the required parameter 'service_profile_id' is set
        if ('service_profile_id' not in params or
                params['service_profile_id'] is None):
            raise ValueError("Missing the required parameter `service_profile_id` when calling `get_si_service_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_profile_id' in params:
            path_params['service-profile-id'] = params['service_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-profiles/{service-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseServiceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_solution_config(self, service_id, solution_config_id, **kwargs):  # noqa: E501
        """Get Solution Config Information for a given solution config id.  # noqa: E501

        Returns Solution Config information for a given solution config id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_solution_config(service_id, solution_config_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str solution_config_id: (required)
        :return: SolutionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_solution_config_with_http_info(service_id, solution_config_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_solution_config_with_http_info(service_id, solution_config_id, **kwargs)  # noqa: E501
            return data

    def get_solution_config_with_http_info(self, service_id, solution_config_id, **kwargs):  # noqa: E501
        """Get Solution Config Information for a given solution config id.  # noqa: E501

        Returns Solution Config information for a given solution config id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_solution_config_with_http_info(service_id, solution_config_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str solution_config_id: (required)
        :return: SolutionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'solution_config_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_solution_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_solution_config`")  # noqa: E501
        # verify the required parameter 'solution_config_id' is set
        if ('solution_config_id' not in params or
                params['solution_config_id'] is None):
            raise ValueError("Missing the required parameter `solution_config_id` when calling `get_solution_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'solution_config_id' in params:
            path_params['solution-config-id'] = params['solution_config_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/solution-configs/{solution-config-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SolutionConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_template(self, service_id, vendor_template_id, **kwargs):  # noqa: E501
        """Get a particular vendor template for a given service.  # noqa: E501

        Returns detailed vendor template information for a given service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_template(service_id, vendor_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str vendor_template_id: (required)
        :return: VendorTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vendor_template_with_http_info(service_id, vendor_template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vendor_template_with_http_info(service_id, vendor_template_id, **kwargs)  # noqa: E501
            return data

    def get_vendor_template_with_http_info(self, service_id, vendor_template_id, **kwargs):  # noqa: E501
        """Get a particular vendor template for a given service.  # noqa: E501

        Returns detailed vendor template information for a given service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_template_with_http_info(service_id, vendor_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str vendor_template_id: (required)
        :return: VendorTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'vendor_template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_vendor_template`")  # noqa: E501
        # verify the required parameter 'vendor_template_id' is set
        if ('vendor_template_id' not in params or
                params['vendor_template_id'] is None):
            raise ValueError("Missing the required parameter `vendor_template_id` when calling `get_vendor_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'vendor_template_id' in params:
            path_params['vendor-template-id'] = params['vendor_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/vendor-templates/{vendor-template-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_instance_endpoints(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """List all InstanceEndpoints of a Service Instance.  # noqa: E501

        List all InstanceEndpoints of a service instance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_instance_endpoints(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: InstanceEndpointListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_instance_endpoints_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_instance_endpoints_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def list_instance_endpoints_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """List all InstanceEndpoints of a Service Instance.  # noqa: E501

        List all InstanceEndpoints of a service instance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_instance_endpoints_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: InstanceEndpointListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_instance_endpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_instance_endpoints`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `list_instance_endpoints`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-endpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceEndpointListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_instance_runtimes(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Returns list of instance runtimes of service VM being deployed  # noqa: E501

        Returns list of instance runtimes of service VMs being deployed for a given service instance id   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_instance_runtimes(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: InstanceRuntimeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_instance_runtimes_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_instance_runtimes_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def list_instance_runtimes_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Returns list of instance runtimes of service VM being deployed  # noqa: E501

        Returns list of instance runtimes of service VMs being deployed for a given service instance id   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_instance_runtimes_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: InstanceRuntimeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_instance_runtimes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_instance_runtimes`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `list_instance_runtimes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceRuntimeListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_attachments(self, **kwargs):  # noqa: E501
        """Get all service attachments.  # noqa: E501

        Returns all Service-Attachement(s) present in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_attachments(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceAttachmentListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_attachments_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_service_attachments_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_service_attachments_with_http_info(self, **kwargs):  # noqa: E501
        """Get all service attachments.  # noqa: E501

        Returns all Service-Attachement(s) present in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_attachments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceAttachmentListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_attachments" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceAttachmentListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_chain_mappings(self, service_id, service_profile_id, **kwargs):  # noqa: E501
        """List all ServiceChainMappings.  # noqa: E501

        List all service chain mappings in the system for the given service profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_chain_mappings(service_id, service_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_profile_id: (required)
        :return: ServiceChainMappingListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_chain_mappings_with_http_info(service_id, service_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_service_chain_mappings_with_http_info(service_id, service_profile_id, **kwargs)  # noqa: E501
            return data

    def list_service_chain_mappings_with_http_info(self, service_id, service_profile_id, **kwargs):  # noqa: E501
        """List all ServiceChainMappings.  # noqa: E501

        List all service chain mappings in the system for the given service profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_chain_mappings_with_http_info(service_id, service_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_profile_id: (required)
        :return: ServiceChainMappingListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_chain_mappings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_service_chain_mappings`")  # noqa: E501
        # verify the required parameter 'service_profile_id' is set
        if ('service_profile_id' not in params or
                params['service_profile_id'] is None):
            raise ValueError("Missing the required parameter `service_profile_id` when calling `list_service_chain_mappings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_profile_id' in params:
            path_params['service-profile-id'] = params['service_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-profiles/{service-profile-id}/service-chain-mappings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceChainMappingListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_chains(self, **kwargs):  # noqa: E501
        """List all ServiceChains.  # noqa: E501

        List all service chains in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_chains(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceChainListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_chains_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_service_chains_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_service_chains_with_http_info(self, **kwargs):  # noqa: E501
        """List all ServiceChains.  # noqa: E501

        List all service chains in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_chains_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceChainListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_chains" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-chains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceChainListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_insertion_sections(self, **kwargs):  # noqa: E501
        """List All Service Insertion Sections  # noqa: E501

        List all Service Insertion section in paginated form. A default page size is limited to 1000 sections. By default, the list of section is filtered by L3REDIRECT type. Note- GET service insertion sections API is deprecated. Please use the policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_insertion_sections(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str applied_tos: AppliedTo's referenced by this section or section's Distributed Service Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's Distributed Service Rules .
        :param str exclude_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str filter_type: Filter type
        :param str include_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's Distributed Service Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Distributed Service Rules .
        :param str type: Section Type
        :return: ServiceInsertionSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_insertion_sections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_service_insertion_sections_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_service_insertion_sections_with_http_info(self, **kwargs):  # noqa: E501
        """List All Service Insertion Sections  # noqa: E501

        List all Service Insertion section in paginated form. A default page size is limited to 1000 sections. By default, the list of section is filtered by L3REDIRECT type. Note- GET service insertion sections API is deprecated. Please use the policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_insertion_sections_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str applied_tos: AppliedTo's referenced by this section or section's Distributed Service Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's Distributed Service Rules .
        :param str exclude_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str filter_type: Filter type
        :param str include_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's Distributed Service Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Distributed Service Rules .
        :param str type: Section Type
        :return: ServiceInsertionSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applied_tos', 'cursor', 'destinations', 'exclude_applied_to_type', 'filter_type', 'include_applied_to_type', 'included_fields', 'page_size', 'services', 'sort_ascending', 'sort_by', 'sources', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_insertion_sections" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'exclude_applied_to_type' in params:
            query_params.append(('exclude_applied_to_type', params['exclude_applied_to_type']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'include_applied_to_type' in params:
            query_params.append(('include_applied_to_type', params['include_applied_to_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSectionListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_insertion_services(self, **kwargs):  # noqa: E501
        """List all Service-Insertion Services.  # noqa: E501

        List all Service-Insertion Service Definitions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_insertion_services(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceInsertionServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_insertion_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_service_insertion_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_service_insertion_services_with_http_info(self, **kwargs):  # noqa: E501
        """List all Service-Insertion Services.  # noqa: E501

        List all Service-Insertion Service Definitions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_insertion_services_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceInsertionServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_insertion_services" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionServiceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_insertion_status(self, **kwargs):  # noqa: E501
        """List all service insertion status for supported contexts  # noqa: E501

        List all service insertion status for supported contexts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_insertion_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceInsertionStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_insertion_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_service_insertion_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_service_insertion_status_with_http_info(self, **kwargs):  # noqa: E501
        """List all service insertion status for supported contexts  # noqa: E501

        List all service insertion status for supported contexts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_insertion_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceInsertionStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_insertion_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_instances(self, **kwargs):  # noqa: E501
        """Get all Service-Instances present in system  # noqa: E501

        Returns all Service-Instance(s) of all Services present in system. When request parameter (deployed_to or service_deployment_id) is provided as a part of request, it will filter out Service-Instances accordingly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_instances(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str deployed_to: Deployed_to referenced by service instances present in system
        :param str service_deployment_id: Service Deployment Id using which the instances were deployed
        :return: ServiceInstanceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_instances_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_service_instances_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_service_instances_with_http_info(self, **kwargs):  # noqa: E501
        """Get all Service-Instances present in system  # noqa: E501

        Returns all Service-Instance(s) of all Services present in system. When request parameter (deployed_to or service_deployment_id) is provided as a part of request, it will filter out Service-Instances accordingly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_instances_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str deployed_to: Deployed_to referenced by service instances present in system
        :param str service_deployment_id: Service Deployment Id using which the instances were deployed
        :return: ServiceInstanceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployed_to', 'service_deployment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_instances" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'deployed_to' in params:
            query_params.append(('deployed_to', params['deployed_to']))  # noqa: E501
        if 'service_deployment_id' in params:
            query_params.append(('service_deployment_id', params['service_deployment_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-instances', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInstanceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_instances_for_service(self, service_id, **kwargs):  # noqa: E501
        """Get all Service-Instances for Service.  # noqa: E501

        Returns all Service-Instance(s) for a given Service-Insertion Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_instances_for_service(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: ServiceInstanceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_instances_for_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_service_instances_for_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_service_instances_for_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get all Service-Instances for Service.  # noqa: E501

        Returns all Service-Instance(s) for a given Service-Insertion Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_instances_for_service_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: ServiceInstanceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_instances_for_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_service_instances_for_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInstanceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_managers(self, **kwargs):  # noqa: E501
        """List service managers  # noqa: E501

        List all service managers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_managers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceManagerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_managers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_service_managers_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_service_managers_with_http_info(self, **kwargs):  # noqa: E501
        """List service managers  # noqa: E501

        List all service managers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_managers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceManagerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_managers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-managers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceManagerListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_paths(self, service_chain_id, **kwargs):  # noqa: E501
        """List all service paths  # noqa: E501

        List all service paths for the given service chain for the given service chain id NOTE: GET service paths api is deprecated, please use the policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_paths(service_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_chain_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServicePathListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_service_paths_with_http_info(service_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_service_paths_with_http_info(service_chain_id, **kwargs)  # noqa: E501
            return data

    def list_service_paths_with_http_info(self, service_chain_id, **kwargs):  # noqa: E501
        """List all service paths  # noqa: E501

        List all service paths for the given service chain for the given service chain id NOTE: GET service paths api is deprecated, please use the policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_service_paths_with_http_info(service_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_chain_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServicePathListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_chain_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_paths" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_chain_id' is set
        if ('service_chain_id' not in params or
                params['service_chain_id'] is None):
            raise ValueError("Missing the required parameter `service_chain_id` when calling `list_service_paths`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_chain_id' in params:
            path_params['service-chain-id'] = params['service_chain_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-chains/{service-chain-id}/service-paths', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServicePathListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_si_service_profiles(self, service_id, **kwargs):  # noqa: E501
        """List all Service Profiles of a Service.  # noqa: E501

        List all service profiles of a service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_si_service_profiles(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: SIServiceProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_si_service_profiles_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_si_service_profiles_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_si_service_profiles_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """List all Service Profiles of a Service.  # noqa: E501

        List all service profiles of a service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_si_service_profiles_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: SIServiceProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_si_service_profiles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_si_service_profiles`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SIServiceProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_solution_configs(self, service_id, **kwargs):  # noqa: E501
        """Get Solution Config Information associated with a given service.  # noqa: E501

        Returns Solution Config information for a given service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_solution_configs(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: SolutionConfigListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_solution_configs_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_solution_configs_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_solution_configs_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get Solution Config Information associated with a given service.  # noqa: E501

        Returns Solution Config information for a given service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_solution_configs_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :return: SolutionConfigListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_solution_configs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_solution_configs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/solution-configs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SolutionConfigListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_vendor_templates(self, service_id, **kwargs):  # noqa: E501
        """List all VendorTemplates of a Service.  # noqa: E501

        List all vendor templates of a service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_vendor_templates(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str vendor_template_name: Name of vendor template
        :return: VendorTemplateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_vendor_templates_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_vendor_templates_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_vendor_templates_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """List all VendorTemplates of a Service.  # noqa: E501

        List all vendor templates of a service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_vendor_templates_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str vendor_template_name: Name of vendor template
        :return: VendorTemplateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'vendor_template_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_vendor_templates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_vendor_templates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'vendor_template_name' in params:
            query_params.append(('vendor_template_name', params['vendor_template_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/vendor-templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorTemplateListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_service_manager(self, body, **kwargs):  # noqa: E501
        """Register service manager  # noqa: E501

        Register service-manager with NSX with basic details like name, username, password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_service_manager(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceManager body: (required)
        :return: ServiceManager
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.register_service_manager_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.register_service_manager_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def register_service_manager_with_http_info(self, body, **kwargs):  # noqa: E501
        """Register service manager  # noqa: E501

        Register service-manager with NSX with basic details like name, username, password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_service_manager_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceManager body: (required)
        :return: ServiceManager
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_service_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `register_service_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-managers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceManager',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_service_insertion_exclude_list_member_remove_member(self, object_id, **kwargs):  # noqa: E501
        """Remove an existing object from the exclude list  # noqa: E501

        Note- POST serviceinsertion excludelist API is deprecated. Please use the policy serviceinsertion excludelist API instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_service_insertion_exclude_list_member_remove_member(object_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier of the object (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_service_insertion_exclude_list_member_remove_member_with_http_info(object_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_service_insertion_exclude_list_member_remove_member_with_http_info(object_id, **kwargs)  # noqa: E501
            return data

    def remove_service_insertion_exclude_list_member_remove_member_with_http_info(self, object_id, **kwargs):  # noqa: E501
        """Remove an existing object from the exclude list  # noqa: E501

        Note- POST serviceinsertion excludelist API is deprecated. Please use the policy serviceinsertion excludelist API instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_service_insertion_exclude_list_member_remove_member_with_http_info(object_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier of the object (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_service_insertion_exclude_list_member_remove_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params or
                params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `remove_service_insertion_exclude_list_member_remove_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'object_id' in params:
            query_params.append(('object_id', params['object_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/excludelist?action=remove_member', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceReference',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resolve_source_entities(self, source_node_value, **kwargs):  # noqa: E501
        """Resolve 'source node id' value to source entities.  # noqa: E501

        Service insertion data path inserts unique 'source node id' value into each packet. This API can be used to identify the source of the packet using this value. It can be resolved to multiple source entities.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_source_entities(source_node_value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source_node_value: value (required)
        :return: SourceEntityResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resolve_source_entities_with_http_info(source_node_value, **kwargs)  # noqa: E501
        else:
            (data) = self.resolve_source_entities_with_http_info(source_node_value, **kwargs)  # noqa: E501
            return data

    def resolve_source_entities_with_http_info(self, source_node_value, **kwargs):  # noqa: E501
        """Resolve 'source node id' value to source entities.  # noqa: E501

        Service insertion data path inserts unique 'source node id' value into each packet. This API can be used to identify the source of the packet using this value. It can be resolved to multiple source entities.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resolve_source_entities_with_http_info(source_node_value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source_node_value: value (required)
        :return: SourceEntityResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['source_node_value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_source_entities" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'source_node_value' is set
        if ('source_node_value' not in params or
                params['source_node_value'] is None):
            raise ValueError("Missing the required parameter `source_node_value` when calling `resolve_source_entities`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'source_node_value' in params:
            query_params.append(('source_node_value', params['source_node_value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/source-entities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SourceEntityResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_service_insertion_rule_revise(self, body, section_id, rule_id, **kwargs):  # noqa: E501
        """Update an Existing Rule and Reorder the Rule  # noqa: E501

        Modifies existing serviceinsertion rule along with relative position among other serviceinsertion rules inside a serviceinsertion section. Note- POST service insertion rule API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_service_insertion_rule_revise(body, section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionRule body: (required)
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revise_service_insertion_rule_revise_with_http_info(body, section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_service_insertion_rule_revise_with_http_info(body, section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def revise_service_insertion_rule_revise_with_http_info(self, body, section_id, rule_id, **kwargs):  # noqa: E501
        """Update an Existing Rule and Reorder the Rule  # noqa: E501

        Modifies existing serviceinsertion rule along with relative position among other serviceinsertion rules inside a serviceinsertion section. Note- POST service insertion rule API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_service_insertion_rule_revise_with_http_info(body, section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionRule body: (required)
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'rule_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_service_insertion_rule_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `revise_service_insertion_rule_revise`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_service_insertion_rule_revise`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `revise_service_insertion_rule_revise`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}/rules/{rule-id}?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_service_insertion_section_revise(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Position  # noqa: E501

        Modifies an existing serviceinsertion section along with its relative position among other serviceinsertion sections in the system. Note- POST service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_service_insertion_section_revise(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSection body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revise_service_insertion_section_revise_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_service_insertion_section_revise_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def revise_service_insertion_section_revise_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Position  # noqa: E501

        Modifies an existing serviceinsertion section along with its relative position among other serviceinsertion sections in the system. Note- POST service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_service_insertion_section_revise_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSection body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_service_insertion_section_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `revise_service_insertion_section_revise`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_service_insertion_section_revise`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_service_insertion_section_with_rules_revise_with_rules(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section with Rules  # noqa: E501

        Modifies an existing serviceinsertion section along with its relative position among other serviceinsertion sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/serviceinsertion/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt; Note- POST service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_service_insertion_section_with_rules_revise_with_rules(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSectionRuleList body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revise_service_insertion_section_with_rules_revise_with_rules_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_service_insertion_section_with_rules_revise_with_rules_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def revise_service_insertion_section_with_rules_revise_with_rules_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section with Rules  # noqa: E501

        Modifies an existing serviceinsertion section along with its relative position among other serviceinsertion sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/serviceinsertion/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt; Note- POST service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_service_insertion_section_with_rules_revise_with_rules_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSectionRuleList body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: ServiceInsertionSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_service_insertion_section_with_rules_revise_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `revise_service_insertion_section_with_rules_revise_with_rules`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_service_insertion_section_with_rules_revise_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}?action=revise_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_attachment(self, body, service_attachment_id, **kwargs):  # noqa: E501
        """Update an existing service attachment.  # noqa: E501

        Modifies an existing service attachment. Updates to name, description and Logical Router list only supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_attachment(body, service_attachment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceAttachment body: (required)
        :param str service_attachment_id: (required)
        :return: ServiceAttachment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_attachment_with_http_info(body, service_attachment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_attachment_with_http_info(body, service_attachment_id, **kwargs)  # noqa: E501
            return data

    def update_service_attachment_with_http_info(self, body, service_attachment_id, **kwargs):  # noqa: E501
        """Update an existing service attachment.  # noqa: E501

        Modifies an existing service attachment. Updates to name, description and Logical Router list only supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_attachment_with_http_info(body, service_attachment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceAttachment body: (required)
        :param str service_attachment_id: (required)
        :return: ServiceAttachment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_attachment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_attachment`")  # noqa: E501
        # verify the required parameter 'service_attachment_id' is set
        if ('service_attachment_id' not in params or
                params['service_attachment_id'] is None):
            raise ValueError("Missing the required parameter `service_attachment_id` when calling `update_service_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_attachment_id' in params:
            path_params['service-attachment-id'] = params['service_attachment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-attachments/{service-attachment-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceAttachment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_deployment(self, body, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Update an existing Service Deployment.  # noqa: E501

        This API is deprecated since only property we can change on service deployment is display name, which is used for the SVM name. Changing the name will cause the name of the deployment to go out of sync with the deployed VM.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_deployment(body, service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceDeployment body: (required)
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :return: ServiceDeployment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_deployment_with_http_info(body, service_id, service_deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_deployment_with_http_info(body, service_id, service_deployment_id, **kwargs)  # noqa: E501
            return data

    def update_service_deployment_with_http_info(self, body, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Update an existing Service Deployment.  # noqa: E501

        This API is deprecated since only property we can change on service deployment is display name, which is used for the SVM name. Changing the name will cause the name of the deployment to go out of sync with the deployed VM.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_deployment_with_http_info(body, service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceDeployment body: (required)
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :return: ServiceDeployment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id', 'service_deployment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_deployment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_deployment`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_service_deployment`")  # noqa: E501
        # verify the required parameter 'service_deployment_id' is set
        if ('service_deployment_id' not in params or
                params['service_deployment_id'] is None):
            raise ValueError("Missing the required parameter `service_deployment_id` when calling `update_service_deployment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_deployment_id' in params:
            path_params['service-deployment-id'] = params['service_deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-deployments/{service-deployment-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceDeployment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_insertion_exclude_list(self, body, **kwargs):  # noqa: E501
        """Modify exclude list  # noqa: E501

        Modify exclude list. This includes adding/removing members in the list. Note- PUT serviceinsertion excludelist API is deprecated. Please use the policy serviceinsertion excludelist API instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_exclude_list(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SIExcludeList body: (required)
        :return: SIExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_insertion_exclude_list_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_insertion_exclude_list_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def update_service_insertion_exclude_list_with_http_info(self, body, **kwargs):  # noqa: E501
        """Modify exclude list  # noqa: E501

        Modify exclude list. This includes adding/removing members in the list. Note- PUT serviceinsertion excludelist API is deprecated. Please use the policy serviceinsertion excludelist API instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_exclude_list_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SIExcludeList body: (required)
        :return: SIExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_insertion_exclude_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_insertion_exclude_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/excludelist', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SIExcludeList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_insertion_rule(self, body, section_id, rule_id, **kwargs):  # noqa: E501
        """Update an Existing Rule  # noqa: E501

        Modifies existing serviceinsertion rule in a serviceinsertion section. Note- PUT service insertion rule API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_rule(body, section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionRule body: (required)
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: ServiceInsertionRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_insertion_rule_with_http_info(body, section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_insertion_rule_with_http_info(body, section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def update_service_insertion_rule_with_http_info(self, body, section_id, rule_id, **kwargs):  # noqa: E501
        """Update an Existing Rule  # noqa: E501

        Modifies existing serviceinsertion rule in a serviceinsertion section. Note- PUT service insertion rule API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_rule_with_http_info(body, section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionRule body: (required)
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: ServiceInsertionRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_insertion_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_insertion_rule`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_service_insertion_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `update_service_insertion_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}/rules/{rule-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_insertion_section(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section  # noqa: E501

        Modifies the specified section, but does not modify the section's associated rules. Note- PUT service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_section(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSection body: (required)
        :param str section_id: (required)
        :return: ServiceInsertionSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_insertion_section_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_insertion_section_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def update_service_insertion_section_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section  # noqa: E501

        Modifies the specified section, but does not modify the section's associated rules. Note- PUT service insertion section API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_section_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSection body: (required)
        :param str section_id: (required)
        :return: ServiceInsertionSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_insertion_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_insertion_section`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_service_insertion_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_insertion_section_with_rules_update_with_rules(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Rules  # noqa: E501

        Modifies existing serviceinsertion section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt; Note- POST service insertion section with rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_section_with_rules_update_with_rules(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSectionRuleList body: (required)
        :param str section_id: (required)
        :return: ServiceInsertionSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_insertion_section_with_rules_update_with_rules_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_insertion_section_with_rules_update_with_rules_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def update_service_insertion_section_with_rules_update_with_rules_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Rules  # noqa: E501

        Modifies existing serviceinsertion section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/serviceinsertion/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt; Note- POST service insertion section with rules API is deprecated. Please use policy redirection-policy API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_section_with_rules_update_with_rules_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionSectionRuleList body: (required)
        :param str section_id: (required)
        :return: ServiceInsertionSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_insertion_section_with_rules_update_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_insertion_section_with_rules_update_with_rules`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_service_insertion_section_with_rules_update_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/sections/{section-id}?action=update_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_insertion_service(self, body, service_id, **kwargs):  # noqa: E501
        """Update an existing Service  # noqa: E501

        Modifies the specified Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_service(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceDefinition body: (required)
        :param str service_id: (required)
        :return: ServiceDefinition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_insertion_service_with_http_info(body, service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_insertion_service_with_http_info(body, service_id, **kwargs)  # noqa: E501
            return data

    def update_service_insertion_service_with_http_info(self, body, service_id, **kwargs):  # noqa: E501
        """Update an existing Service  # noqa: E501

        Modifies the specified Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_service_with_http_info(body, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceDefinition body: (required)
        :param str service_id: (required)
        :return: ServiceDefinition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_insertion_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_insertion_service`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_service_insertion_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceDefinition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_insertion_status(self, body, context_type, **kwargs):  # noqa: E501
        """Update global ServiceInsertion status for a context  # noqa: E501

        Update global ServiceInsertion status for a context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_status(body, context_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionStatus body: (required)
        :param str context_type: (required)
        :return: ServiceInsertionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_insertion_status_with_http_info(body, context_type, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_insertion_status_with_http_info(body, context_type, **kwargs)  # noqa: E501
            return data

    def update_service_insertion_status_with_http_info(self, body, context_type, **kwargs):  # noqa: E501
        """Update global ServiceInsertion status for a context  # noqa: E501

        Update global ServiceInsertion status for a context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_insertion_status_with_http_info(body, context_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceInsertionStatus body: (required)
        :param str context_type: (required)
        :return: ServiceInsertionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'context_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_insertion_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_insertion_status`")  # noqa: E501
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `update_service_insertion_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/status/{context-type}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceInsertionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_instance(self, body, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Update an existing Service-Instance.  # noqa: E501

        Modifies an existing Service-Instance for a given Service-Insertion Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_instance(body, service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseServiceInstance body: (required)
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: BaseServiceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_instance_with_http_info(body, service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_instance_with_http_info(body, service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def update_service_instance_with_http_info(self, body, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Update an existing Service-Instance.  # noqa: E501

        Modifies an existing Service-Instance for a given Service-Insertion Service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_instance_with_http_info(body, service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseServiceInstance body: (required)
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: BaseServiceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_instance`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_service_instance`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `update_service_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseServiceInstance',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_manager(self, body, service_manager_id, **kwargs):  # noqa: E501
        """Update service manager  # noqa: E501

        Update service-manager which is registered with NSX with basic details like name, username, password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_manager(body, service_manager_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceManager body: (required)
        :param str service_manager_id: (required)
        :return: ServiceManager
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_manager_with_http_info(body, service_manager_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_manager_with_http_info(body, service_manager_id, **kwargs)  # noqa: E501
            return data

    def update_service_manager_with_http_info(self, body, service_manager_id, **kwargs):  # noqa: E501
        """Update service manager  # noqa: E501

        Update service-manager which is registered with NSX with basic details like name, username, password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_manager_with_http_info(body, service_manager_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceManager body: (required)
        :param str service_manager_id: (required)
        :return: ServiceManager
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_manager_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_service_manager`")  # noqa: E501
        # verify the required parameter 'service_manager_id' is set
        if ('service_manager_id' not in params or
                params['service_manager_id'] is None):
            raise ValueError("Missing the required parameter `service_manager_id` when calling `update_service_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_manager_id' in params:
            path_params['service-manager-id'] = params['service_manager_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/service-managers/{service-manager-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceManager',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_vm_state(self, service_id, service_instance_id, instance_runtime_id, **kwargs):  # noqa: E501
        """Update maintenance mode or runtime state of a service VM  # noqa: E501

        Set service VM either in or out of maintenance mode for maintenance mode, or in service or out of service for runtime state. Only one value can be set at one time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_vm_state(service_id, service_instance_id, instance_runtime_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_runtime_id: (required)
        :param str action:
        :param str unhealthy_reason: Reason for the unhealthy state
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_service_vm_state_with_http_info(service_id, service_instance_id, instance_runtime_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_vm_state_with_http_info(service_id, service_instance_id, instance_runtime_id, **kwargs)  # noqa: E501
            return data

    def update_service_vm_state_with_http_info(self, service_id, service_instance_id, instance_runtime_id, **kwargs):  # noqa: E501
        """Update maintenance mode or runtime state of a service VM  # noqa: E501

        Set service VM either in or out of maintenance mode for maintenance mode, or in service or out of service for runtime state. Only one value can be set at one time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_service_vm_state_with_http_info(service_id, service_instance_id, instance_runtime_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :param str instance_runtime_id: (required)
        :param str action:
        :param str unhealthy_reason: Reason for the unhealthy state
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id', 'instance_runtime_id', 'action', 'unhealthy_reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_vm_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_service_vm_state`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `update_service_vm_state`")  # noqa: E501
        # verify the required parameter 'instance_runtime_id' is set
        if ('instance_runtime_id' not in params or
                params['instance_runtime_id'] is None):
            raise ValueError("Missing the required parameter `instance_runtime_id` when calling `update_service_vm_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501
        if 'instance_runtime_id' in params:
            path_params['instance-runtime-id'] = params['instance_runtime_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'unhealthy_reason' in params:
            query_params.append(('unhealthy_reason', params['unhealthy_reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes/{instance-runtime-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_solution_config(self, body, service_id, solution_config_id, **kwargs):  # noqa: E501
        """Updates Solution Config for a given Service  # noqa: E501

        Updates a solution config. Solution Config are service level objects, required for configuring the NXGI partner Service after deployment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_solution_config(body, service_id, solution_config_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SolutionConfig body: (required)
        :param str service_id: (required)
        :param str solution_config_id: (required)
        :return: SolutionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_solution_config_with_http_info(body, service_id, solution_config_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_solution_config_with_http_info(body, service_id, solution_config_id, **kwargs)  # noqa: E501
            return data

    def update_solution_config_with_http_info(self, body, service_id, solution_config_id, **kwargs):  # noqa: E501
        """Updates Solution Config for a given Service  # noqa: E501

        Updates a solution config. Solution Config are service level objects, required for configuring the NXGI partner Service after deployment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_solution_config_with_http_info(body, service_id, solution_config_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SolutionConfig body: (required)
        :param str service_id: (required)
        :param str solution_config_id: (required)
        :return: SolutionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id', 'solution_config_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_solution_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_solution_config`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_solution_config`")  # noqa: E501
        # verify the required parameter 'solution_config_id' is set
        if ('solution_config_id' not in params or
                params['solution_config_id'] is None):
            raise ValueError("Missing the required parameter `solution_config_id` when calling `update_solution_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'solution_config_id' in params:
            path_params['solution-config-id'] = params['solution_config_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/solution-configs/{solution-config-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SolutionConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upgrade_service_deployment_upgrade(self, body, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Upgrade all VMs part of this service deployment to new Spec OVF.  # noqa: E501

        If new deployment spec is provided, the deployment will be moved to the provided spec provided that current deployment state is either UPGRADE_FAILED or DEPLOYMENT_SUCCESSFUL If same deployment spec is provided, upgrade will be done only if current deployment state is UPGRADE_FAILED    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_service_deployment_upgrade(body, service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeploymentSpecName body: (required)
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upgrade_service_deployment_upgrade_with_http_info(body, service_id, service_deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upgrade_service_deployment_upgrade_with_http_info(body, service_id, service_deployment_id, **kwargs)  # noqa: E501
            return data

    def upgrade_service_deployment_upgrade_with_http_info(self, body, service_id, service_deployment_id, **kwargs):  # noqa: E501
        """Upgrade all VMs part of this service deployment to new Spec OVF.  # noqa: E501

        If new deployment spec is provided, the deployment will be moved to the provided spec provided that current deployment state is either UPGRADE_FAILED or DEPLOYMENT_SUCCESSFUL If same deployment spec is provided, upgrade will be done only if current deployment state is UPGRADE_FAILED    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_service_deployment_upgrade_with_http_info(body, service_id, service_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeploymentSpecName body: (required)
        :param str service_id: (required)
        :param str service_deployment_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'service_id', 'service_deployment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upgrade_service_deployment_upgrade" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `upgrade_service_deployment_upgrade`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `upgrade_service_deployment_upgrade`")  # noqa: E501
        # verify the required parameter 'service_deployment_id' is set
        if ('service_deployment_id' not in params or
                params['service_deployment_id'] is None):
            raise ValueError("Missing the required parameter `service_deployment_id` when calling `upgrade_service_deployment_upgrade`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_deployment_id' in params:
            path_params['service-deployment-id'] = params['service_deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-deployments/{service-deployment-id}?action=upgrade', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upgrade_service_v_ms_upgrade(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Upgrade service VMs using newer version of OVF  # noqa: E501

        Upgrade service VMs using newer version of OVF. Upgrade is a 2 step process. Update the 'deployment_spec_name' in the ServiceInstance to the new DeploymentSpec to which the service VMs will be upgraded, folowed by this 'upgrade' api. In case of HA, the stand-by service VM will be upgrade first. Once it has been upgraded, it switches to be the Active one and then the other VM will be upgrade.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_service_v_ms_upgrade(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upgrade_service_v_ms_upgrade_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upgrade_service_v_ms_upgrade_with_http_info(service_id, service_instance_id, **kwargs)  # noqa: E501
            return data

    def upgrade_service_v_ms_upgrade_with_http_info(self, service_id, service_instance_id, **kwargs):  # noqa: E501
        """Upgrade service VMs using newer version of OVF  # noqa: E501

        Upgrade service VMs using newer version of OVF. Upgrade is a 2 step process. Update the 'deployment_spec_name' in the ServiceInstance to the new DeploymentSpec to which the service VMs will be upgraded, folowed by this 'upgrade' api. In case of HA, the stand-by service VM will be upgrade first. Once it has been upgraded, it switches to be the Active one and then the other VM will be upgrade.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_service_v_ms_upgrade_with_http_info(service_id, service_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_id: (required)
        :param str service_instance_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upgrade_service_v_ms_upgrade" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `upgrade_service_v_ms_upgrade`")  # noqa: E501
        # verify the required parameter 'service_instance_id' is set
        if ('service_instance_id' not in params or
                params['service_instance_id'] is None):
            raise ValueError("Missing the required parameter `service_instance_id` when calling `upgrade_service_v_ms_upgrade`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_instance_id' in params:
            path_params['service-instance-id'] = params['service_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/serviceinsertion/services/{service-id}/service-instances/{service-instance-id}/instance-runtimes?action=upgrade', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
