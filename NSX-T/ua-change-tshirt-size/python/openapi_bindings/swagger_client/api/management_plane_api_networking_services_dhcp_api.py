# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPINetworkingServicesDHCPApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_dhcp_ip_pool(self, body, server_id, **kwargs):  # noqa: E501
        """Create an ip pool for a DHCP server  # noqa: E501

        Create an ip pool for a local DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_ip_pool(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpIpPool body: (required)
        :param str server_id: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dhcp_ip_pool_with_http_info(body, server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_ip_pool_with_http_info(body, server_id, **kwargs)  # noqa: E501
            return data

    def create_dhcp_ip_pool_with_http_info(self, body, server_id, **kwargs):  # noqa: E501
        """Create an ip pool for a DHCP server  # noqa: E501

        Create an ip pool for a local DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_ip_pool_with_http_info(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpIpPool body: (required)
        :param str server_id: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `create_dhcp_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpIpPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_profile(self, body, **kwargs):  # noqa: E501
        """Create a DHCP server profile  # noqa: E501

        Create a DHCP server profile. If no edge member is specified, edge members to run the dhcp servers will be auto-allocated from the edge cluster.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpProfile body: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dhcp_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_dhcp_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a DHCP server profile  # noqa: E501

        Create a DHCP server profile. If no edge member is specified, edge members to run the dhcp servers will be auto-allocated from the edge cluster.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpProfile body: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_dhcp_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_server(self, body, **kwargs):  # noqa: E501
        """Create a DHCP server  # noqa: E501

        Create a logical DHCP server with v4 and/or v6 servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_server(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalDhcpServer body: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dhcp_server_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_server_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_dhcp_server_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a DHCP server  # noqa: E501

        Create a logical DHCP server with v4 and/or v6 servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_server_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalDhcpServer body: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_dhcp_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalDhcpServer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_static_binding(self, body, server_id, **kwargs):  # noqa: E501
        """Create a static binding for a DHCP server  # noqa: E501

        Create a static binding for a logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_static_binding(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpStaticBinding body: (required)
        :param str server_id: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dhcp_static_binding_with_http_info(body, server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_static_binding_with_http_info(body, server_id, **kwargs)  # noqa: E501
            return data

    def create_dhcp_static_binding_with_http_info(self, body, server_id, **kwargs):  # noqa: E501
        """Create a static binding for a DHCP server  # noqa: E501

        Create a static binding for a logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_static_binding_with_http_info(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpStaticBinding body: (required)
        :param str server_id: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `create_dhcp_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_v6_ip_pool(self, body, server_id, **kwargs):  # noqa: E501
        """Create an ip pool for a DHCP IPv6 server  # noqa: E501

        Create an ip pool for a local DHCP IPv6 server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_v6_ip_pool(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpV6IpPool body: (required)
        :param str server_id: (required)
        :return: DhcpV6IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dhcp_v6_ip_pool_with_http_info(body, server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_v6_ip_pool_with_http_info(body, server_id, **kwargs)  # noqa: E501
            return data

    def create_dhcp_v6_ip_pool_with_http_info(self, body, server_id, **kwargs):  # noqa: E501
        """Create an ip pool for a DHCP IPv6 server  # noqa: E501

        Create an ip pool for a local DHCP IPv6 server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_v6_ip_pool_with_http_info(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpV6IpPool body: (required)
        :param str server_id: (required)
        :return: DhcpV6IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_v6_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_dhcp_v6_ip_pool`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `create_dhcp_v6_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-ip-pools', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpV6IpPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_v6_static_binding(self, body, server_id, **kwargs):  # noqa: E501
        """Create a static binding for a DHCP IPv6 server  # noqa: E501

        Create a static binding for a logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_v6_static_binding(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpV6StaticBinding body: (required)
        :param str server_id: (required)
        :return: DhcpV6StaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dhcp_v6_static_binding_with_http_info(body, server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_v6_static_binding_with_http_info(body, server_id, **kwargs)  # noqa: E501
            return data

    def create_dhcp_v6_static_binding_with_http_info(self, body, server_id, **kwargs):  # noqa: E501
        """Create a static binding for a DHCP IPv6 server  # noqa: E501

        Create a static binding for a logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dhcp_v6_static_binding_with_http_info(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpV6StaticBinding body: (required)
        :param str server_id: (required)
        :return: DhcpV6StaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_v6_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_dhcp_v6_static_binding`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `create_dhcp_v6_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-static-bindings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpV6StaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_a_dhcp_lease(self, server_id, ip, mac, **kwargs):  # noqa: E501
        """Delete a single DHCP lease entry specified by ip and mac.  # noqa: E501

        Delete a single DHCP lease entry specified by ip and mac.  The DHCP server matches the DHCP lease with the given ip address and the mac address. The matched lease entry will be deleted. If no lease matches, the request is ignored.  The DHCP lease to be deleted will be removed by the system from both active and standby node. The system will report error if the DHCP lease could not be removed from both nodes. If the DHCP lease could not be removed on either node, please check the DHCP server status. Once the DHCP server status is UP, please invoke the deletion API again to ensure the lease gets deleted from both nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_a_dhcp_lease(server_id, ip, mac, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str ip: IPv4 or IPv6 address (required)
        :param str mac: MAC Address (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_a_dhcp_lease_with_http_info(server_id, ip, mac, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_a_dhcp_lease_with_http_info(server_id, ip, mac, **kwargs)  # noqa: E501
            return data

    def delete_a_dhcp_lease_with_http_info(self, server_id, ip, mac, **kwargs):  # noqa: E501
        """Delete a single DHCP lease entry specified by ip and mac.  # noqa: E501

        Delete a single DHCP lease entry specified by ip and mac.  The DHCP server matches the DHCP lease with the given ip address and the mac address. The matched lease entry will be deleted. If no lease matches, the request is ignored.  The DHCP lease to be deleted will be removed by the system from both active and standby node. The system will report error if the DHCP lease could not be removed from both nodes. If the DHCP lease could not be removed on either node, please check the DHCP server status. Once the DHCP server status is UP, please invoke the deletion API again to ensure the lease gets deleted from both nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_a_dhcp_lease_with_http_info(server_id, ip, mac, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str ip: IPv4 or IPv6 address (required)
        :param str mac: MAC Address (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'ip', 'mac']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_a_dhcp_lease" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_a_dhcp_lease`")  # noqa: E501
        # verify the required parameter 'ip' is set
        if ('ip' not in params or
                params['ip'] is None):
            raise ValueError("Missing the required parameter `ip` when calling `delete_a_dhcp_lease`")  # noqa: E501
        # verify the required parameter 'mac' is set
        if ('mac' not in params or
                params['mac'] is None):
            raise ValueError("Missing the required parameter `mac` when calling `delete_a_dhcp_lease`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'ip' in params:
            query_params.append(('ip', params['ip']))  # noqa: E501
        if 'mac' in params:
            query_params.append(('mac', params['mac']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/leases', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_ip_pool(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Delete a DHCP server's IP pool  # noqa: E501

        Delete a specific ip pool of a given logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_ip_pool(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dhcp_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_ip_pool_with_http_info(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Delete a DHCP server's IP pool  # noqa: E501

        Delete a specific ip pool of a given logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_ip_pool_with_http_info(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `delete_dhcp_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools/{pool-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_profile(self, profile_id, **kwargs):  # noqa: E501
        """Delete a DHCP server profile  # noqa: E501

        Delete a DHCP server profile specified by the profile id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_profile(profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dhcp_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_profile_with_http_info(self, profile_id, **kwargs):  # noqa: E501
        """Delete a DHCP server profile  # noqa: E501

        Delete a DHCP server profile specified by the profile id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_profile_with_http_info(profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `delete_dhcp_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles/{profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_server(self, server_id, **kwargs):  # noqa: E501
        """Delete a DHCP server  # noqa: E501

        Delete a logical DHCP server specified by server id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_server(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dhcp_server_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_server_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_server_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Delete a DHCP server  # noqa: E501

        Delete a logical DHCP server specified by server id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_server_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dhcp_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_static_binding(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Delete a static binding  # noqa: E501

        Delete a specific static binding of a given logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_static_binding(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dhcp_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_static_binding_with_http_info(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Delete a static binding  # noqa: E501

        Delete a specific static binding of a given logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_static_binding_with_http_info(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'binding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `delete_dhcp_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings/{binding-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_v6_ip_pool(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Delete a DHCP IPv6 server's IP pool  # noqa: E501

        Delete a specific ip pool of a given logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_v6_ip_pool(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dhcp_v6_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_v6_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_v6_ip_pool_with_http_info(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Delete a DHCP IPv6 server's IP pool  # noqa: E501

        Delete a specific ip pool of a given logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_v6_ip_pool_with_http_info(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_v6_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dhcp_v6_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `delete_dhcp_v6_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-ip-pools/{pool-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_v6_static_binding(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Delete a static binding for DHCP IPv6 server  # noqa: E501

        Delete a specific static binding of a given logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_v6_static_binding(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dhcp_v6_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_v6_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_v6_static_binding_with_http_info(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Delete a static binding for DHCP IPv6 server  # noqa: E501

        Delete a specific static binding of a given logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dhcp_v6_static_binding_with_http_info(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'binding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_v6_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dhcp_v6_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `delete_dhcp_v6_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-static-bindings/{binding-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dhcp_ip_pool_state(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Get the realized state of a dhcp ip pool  # noqa: E501

        Return realized state information of a dhcp ip pool. After a dhcp ip pool is created or updated, you can invoke this API to get the realization information of the ip pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dhcp_ip_pool_state(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dhcp_ip_pool_state_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dhcp_ip_pool_state_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def get_dhcp_ip_pool_state_with_http_info(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Get the realized state of a dhcp ip pool  # noqa: E501

        Return realized state information of a dhcp ip pool. After a dhcp ip pool is created or updated, you can invoke this API to get the realization information of the ip pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dhcp_ip_pool_state_with_http_info(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'pool_id', 'barrier_id', 'request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dhcp_ip_pool_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `get_dhcp_ip_pool_state`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `get_dhcp_ip_pool_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501
        if 'request_id' in params:
            query_params.append(('request_id', params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools/{pool-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigurationState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dhcp_server_state(self, server_id, **kwargs):  # noqa: E501
        """Get the realized state of a dhcp server  # noqa: E501

        Return realized state information of a dhcp server. After a dhcp server is created or updated, you can invoke this API to get the realization information of the server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dhcp_server_state(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dhcp_server_state_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dhcp_server_state_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def get_dhcp_server_state_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get the realized state of a dhcp server  # noqa: E501

        Return realized state information of a dhcp server. After a dhcp server is created or updated, you can invoke this API to get the realization information of the server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dhcp_server_state_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'barrier_id', 'request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dhcp_server_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `get_dhcp_server_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501
        if 'request_id' in params:
            query_params.append(('request_id', params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigurationState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dhcp_static_binding_state(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Get the realized state of a dhcp static binding  # noqa: E501

        Return realized state information of a dhcp static binding. After a dhcp static binding is created or updated, you can invoke this API to get the realization information of the static binding.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dhcp_static_binding_state(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dhcp_static_binding_state_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dhcp_static_binding_state_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def get_dhcp_static_binding_state_with_http_info(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Get the realized state of a dhcp static binding  # noqa: E501

        Return realized state information of a dhcp static binding. After a dhcp static binding is created or updated, you can invoke this API to get the realization information of the static binding.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dhcp_static_binding_state_with_http_info(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: ConfigurationState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'binding_id', 'barrier_id', 'request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dhcp_static_binding_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `get_dhcp_static_binding_state`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `get_dhcp_static_binding_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501
        if 'request_id' in params:
            query_params.append(('request_id', params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings/{binding-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigurationState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dhcp_status(self, server_id, **kwargs):  # noqa: E501
        """Get DHCP service status with given dhcp server id  # noqa: E501

        Returns the service status of the given dhcp server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dhcp_status(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :return: DhcpServerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dhcp_status_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dhcp_status_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def get_dhcp_status_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get DHCP service status with given dhcp server id  # noqa: E501

        Returns the service status of the given dhcp server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dhcp_status_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :return: DhcpServerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dhcp_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `get_dhcp_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpServerStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_ip_pools(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP server's IP pools  # noqa: E501

        List the ip pools of a logical DHCP server with pagination support.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_ip_pools(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpIpPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_dhcp_ip_pools_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_ip_pools_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def list_dhcp_ip_pools_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP server's IP pools  # noqa: E501

        List the ip pools of a logical DHCP server with pagination support.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_ip_pools_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpIpPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_ip_pools" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `list_dhcp_ip_pools`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpIpPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_profiles(self, **kwargs):  # noqa: E501
        """Get a paginated list of DHCP server profiles  # noqa: E501

        Get a paginated list of DHCP server profiles.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_dhcp_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dhcp_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Get a paginated list of DHCP server profiles  # noqa: E501

        Get a paginated list of DHCP server profiles.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_servers(self, **kwargs):  # noqa: E501
        """Get a paginated list of DHCP servers  # noqa: E501

        List logical DHCP servers with pagination support.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_servers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalDhcpServerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_dhcp_servers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_servers_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dhcp_servers_with_http_info(self, **kwargs):  # noqa: E501
        """Get a paginated list of DHCP servers  # noqa: E501

        List logical DHCP servers with pagination support.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_servers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalDhcpServerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_servers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalDhcpServerListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_static_bindings(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP server's static bindings  # noqa: E501

        Return a paginated list of a static bindings of a given logical DHCP server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_static_bindings(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpStaticBindingListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_dhcp_static_bindings_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_static_bindings_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def list_dhcp_static_bindings_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP server's static bindings  # noqa: E501

        Return a paginated list of a static bindings of a given logical DHCP server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_static_bindings_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpStaticBindingListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_static_bindings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `list_dhcp_static_bindings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStaticBindingListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_v6_ip_pools(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP IPv6 server's IP pools  # noqa: E501

        List the ip pools of a logical DHCP IPv6 server with pagination support.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_v6_ip_pools(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpV6IpPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_dhcp_v6_ip_pools_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_v6_ip_pools_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def list_dhcp_v6_ip_pools_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP IPv6 server's IP pools  # noqa: E501

        List the ip pools of a logical DHCP IPv6 server with pagination support.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_v6_ip_pools_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpV6IpPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_v6_ip_pools" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `list_dhcp_v6_ip_pools`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-ip-pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpV6IpPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_v6_static_bindings(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP IPv6 server's static bindings  # noqa: E501

        Return a paginated list of a static bindings of a given logical DHCP IPv6 server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_v6_static_bindings(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpV6StaticBindingListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_dhcp_v6_static_bindings_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_v6_static_bindings_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def list_dhcp_v6_static_bindings_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP IPv6 server's static bindings  # noqa: E501

        Return a paginated list of a static bindings of a given logical DHCP IPv6 server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dhcp_v6_static_bindings_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpV6StaticBindingListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_v6_static_bindings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `list_dhcp_v6_static_bindings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-static-bindings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpV6StaticBindingListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_ip_pool(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Get a DHCP server's IP pool with the specified pool ID  # noqa: E501

        Return a specific ip pool of a given logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_ip_pool(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_dhcp_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_ip_pool_with_http_info(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Get a DHCP server's IP pool with the specified pool ID  # noqa: E501

        Return a specific ip pool of a given logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_ip_pool_with_http_info(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `read_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_dhcp_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpIpPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_profile(self, profile_id, **kwargs):  # noqa: E501
        """Get a DHCP server profile  # noqa: E501

        Return the DHCP profile specified by the profile id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_profile(profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str profile_id: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_dhcp_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_profile_with_http_info(self, profile_id, **kwargs):  # noqa: E501
        """Get a DHCP server profile  # noqa: E501

        Return the DHCP profile specified by the profile id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_profile_with_http_info(profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str profile_id: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `read_dhcp_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles/{profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_server(self, server_id, **kwargs):  # noqa: E501
        """Get a DHCP server with v4 and/or v6 servers  # noqa: E501

        Retrieve a logical DHCP server specified by server id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_server(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_dhcp_server_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_server_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_server_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get a DHCP server with v4 and/or v6 servers  # noqa: E501

        Retrieve a logical DHCP server specified by server id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_server_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `read_dhcp_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalDhcpServer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_static_binding(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Get a DHCP server's static binding with the specified binding ID  # noqa: E501

        Return a specific static binding of a given logical DHCP server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_static_binding(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_dhcp_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_static_binding_with_http_info(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Get a DHCP server's static binding with the specified binding ID  # noqa: E501

        Return a specific static binding of a given logical DHCP server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_static_binding_with_http_info(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'binding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `read_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `read_dhcp_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings/{binding-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_v6_ip_pool(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Get a DHCP IPv6 server's IP pool with the specified pool ID  # noqa: E501

        Return a specific ip pool of a given logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_v6_ip_pool(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpV6IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_dhcp_v6_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_v6_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_v6_ip_pool_with_http_info(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Get a DHCP IPv6 server's IP pool with the specified pool ID  # noqa: E501

        Return a specific ip pool of a given logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_v6_ip_pool_with_http_info(server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpV6IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_v6_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `read_dhcp_v6_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_dhcp_v6_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-ip-pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpV6IpPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_v6_static_binding(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Get a DHCP IPv6 server's static binding with the specified binding ID  # noqa: E501

        Return a specific static binding of a given logical DHCP IPv6 server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_v6_static_binding(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpV6StaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_dhcp_v6_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_v6_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_v6_static_binding_with_http_info(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Get a DHCP IPv6 server's static binding with the specified binding ID  # noqa: E501

        Return a specific static binding of a given logical DHCP IPv6 server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dhcp_v6_static_binding_with_http_info(server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpV6StaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'binding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_v6_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `read_dhcp_v6_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `read_dhcp_v6_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-static-bindings/{binding-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpV6StaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reallocate_dhcp_profile_edge_cluster_reallocate(self, body, server_profile_id, **kwargs):  # noqa: E501
        """Reallocate edge cluster and members of given DHCP profile.  # noqa: E501

        As changing edge-cluster-id of a DhcpProfile by a PUT is disallowed, this re-allocate API is used to modify the edge-cluster-id and members of a given DhcpProfile.  Only the edge-cluster-id and the edge-cluster-member-indexes fields will be picked up by this re-allication API. The othere fields in the payload will be ignored.  If the edge-cluster-id in the payload DhcpProfile is different from the current edge-cluster-id of the profile, the referencing DHCP server(s) will be re-allocated to the new edge cluster. If the edge-cluster-id is not changed, the referencing DHCP server(s) will be re-allocated to the given edge members in the edge cluster. In this case, this REST API will act same as that of updating a DhcpProfile.  If the edge cluster member indexes are provided, they should exist in the given edge cluster. If the indexes are not specified in the DhcpProfile, edge members will be auto-allocated from the given edge cluster.  Please note that re-allocating edge-cluster will cause lose of all exisitng DHCP lease information. This API is used only when loosing DHCP leases is not a real problem, e.g. cross-site migration or failover and all client hosts will be reboot and get new IP addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reallocate_dhcp_profile_edge_cluster_reallocate(body, server_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpProfile body: (required)
        :param str server_profile_id: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reallocate_dhcp_profile_edge_cluster_reallocate_with_http_info(body, server_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reallocate_dhcp_profile_edge_cluster_reallocate_with_http_info(body, server_profile_id, **kwargs)  # noqa: E501
            return data

    def reallocate_dhcp_profile_edge_cluster_reallocate_with_http_info(self, body, server_profile_id, **kwargs):  # noqa: E501
        """Reallocate edge cluster and members of given DHCP profile.  # noqa: E501

        As changing edge-cluster-id of a DhcpProfile by a PUT is disallowed, this re-allocate API is used to modify the edge-cluster-id and members of a given DhcpProfile.  Only the edge-cluster-id and the edge-cluster-member-indexes fields will be picked up by this re-allication API. The othere fields in the payload will be ignored.  If the edge-cluster-id in the payload DhcpProfile is different from the current edge-cluster-id of the profile, the referencing DHCP server(s) will be re-allocated to the new edge cluster. If the edge-cluster-id is not changed, the referencing DHCP server(s) will be re-allocated to the given edge members in the edge cluster. In this case, this REST API will act same as that of updating a DhcpProfile.  If the edge cluster member indexes are provided, they should exist in the given edge cluster. If the indexes are not specified in the DhcpProfile, edge members will be auto-allocated from the given edge cluster.  Please note that re-allocating edge-cluster will cause lose of all exisitng DHCP lease information. This API is used only when loosing DHCP leases is not a real problem, e.g. cross-site migration or failover and all client hosts will be reboot and get new IP addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reallocate_dhcp_profile_edge_cluster_reallocate_with_http_info(body, server_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpProfile body: (required)
        :param str server_profile_id: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reallocate_dhcp_profile_edge_cluster_reallocate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `reallocate_dhcp_profile_edge_cluster_reallocate`")  # noqa: E501
        # verify the required parameter 'server_profile_id' is set
        if ('server_profile_id' not in params or
                params['server_profile_id'] is None):
            raise ValueError("Missing the required parameter `server_profile_id` when calling `reallocate_dhcp_profile_edge_cluster_reallocate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_profile_id' in params:
            path_params['server-profile-id'] = params['server_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles/{server-profile-id}?action=reallocate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_ip_pool(self, body, server_id, pool_id, **kwargs):  # noqa: E501
        """Update a DHCP server's IP pool  # noqa: E501

        Update a specific ip pool of a given logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_ip_pool(body, server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpIpPool body: (required)
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dhcp_ip_pool_with_http_info(body, server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_ip_pool_with_http_info(body, server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def update_dhcp_ip_pool_with_http_info(self, body, server_id, pool_id, **kwargs):  # noqa: E501
        """Update a DHCP server's IP pool  # noqa: E501

        Update a specific ip pool of a given logical DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_ip_pool_with_http_info(body, server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpIpPool body: (required)
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id', 'pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `update_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `update_dhcp_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools/{pool-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpIpPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_profile(self, body, profile_id, **kwargs):  # noqa: E501
        """Update a DHCP server profile  # noqa: E501

        If both the edge_cluster_member_indexes in the DhcpProfile are changed in a same PUT API, e.g. change from [a,b] to [x,y], the current DHCP server leases will be lost, which could cause the network crash due to ip conflicts. Hence the suggestion is to change only one member index in one single update, e.g. from [a, b] to [a,y].  Please note, the edge_cluster_id in DhcpProfile can NOT be changed by this PUT operation because all existing DHCP leases will lost. If losing leases is not a problem, a dedicated re-allocation API is suggested to modify the edge-cluster-id, i.e. \"POST /api/v1/dhcp/dhcp-profiles/<profileId>?action=reallocate\".  Meanwhile, if the edge_cluster_member_indexes was specified currently but now is changed to none (not specified) via a PUT operation, the edge nodes will not be auto-selected from edge cluster. Instead, the previously-allocated edge nodes will continue to be used by the DHCP server. This is because changing both edge nodes of a DHCP server will lose all existing leases. In case re-allocation is required and leases lost is not a problem (or can be recovered), please invoke the reallocate API mentioned above with new DhcpProfile to accomplish the intent.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_profile(body, profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpProfile body: (required)
        :param str profile_id: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dhcp_profile_with_http_info(body, profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_profile_with_http_info(body, profile_id, **kwargs)  # noqa: E501
            return data

    def update_dhcp_profile_with_http_info(self, body, profile_id, **kwargs):  # noqa: E501
        """Update a DHCP server profile  # noqa: E501

        If both the edge_cluster_member_indexes in the DhcpProfile are changed in a same PUT API, e.g. change from [a,b] to [x,y], the current DHCP server leases will be lost, which could cause the network crash due to ip conflicts. Hence the suggestion is to change only one member index in one single update, e.g. from [a, b] to [a,y].  Please note, the edge_cluster_id in DhcpProfile can NOT be changed by this PUT operation because all existing DHCP leases will lost. If losing leases is not a problem, a dedicated re-allocation API is suggested to modify the edge-cluster-id, i.e. \"POST /api/v1/dhcp/dhcp-profiles/<profileId>?action=reallocate\".  Meanwhile, if the edge_cluster_member_indexes was specified currently but now is changed to none (not specified) via a PUT operation, the edge nodes will not be auto-selected from edge cluster. Instead, the previously-allocated edge nodes will continue to be used by the DHCP server. This is because changing both edge nodes of a DHCP server will lose all existing leases. In case re-allocation is required and leases lost is not a problem (or can be recovered), please invoke the reallocate API mentioned above with new DhcpProfile to accomplish the intent.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_profile_with_http_info(body, profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpProfile body: (required)
        :param str profile_id: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dhcp_profile`")  # noqa: E501
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `update_dhcp_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles/{profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_server(self, body, server_id, **kwargs):  # noqa: E501
        """Update a DHCP server with v4 and/or v6 servers  # noqa: E501

        Update a logical DHCP server with new configurations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_server(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalDhcpServer body: (required)
        :param str server_id: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dhcp_server_with_http_info(body, server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_server_with_http_info(body, server_id, **kwargs)  # noqa: E501
            return data

    def update_dhcp_server_with_http_info(self, body, server_id, **kwargs):  # noqa: E501
        """Update a DHCP server with v4 and/or v6 servers  # noqa: E501

        Update a logical DHCP server with new configurations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_server_with_http_info(body, server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalDhcpServer body: (required)
        :param str server_id: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dhcp_server`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `update_dhcp_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalDhcpServer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_static_binding(self, body, server_id, binding_id, **kwargs):  # noqa: E501
        """Update a DHCP server's static binding  # noqa: E501

        Update a specific static binding of a given local DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_static_binding(body, server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpStaticBinding body: (required)
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dhcp_static_binding_with_http_info(body, server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_static_binding_with_http_info(body, server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def update_dhcp_static_binding_with_http_info(self, body, server_id, binding_id, **kwargs):  # noqa: E501
        """Update a DHCP server's static binding  # noqa: E501

        Update a specific static binding of a given local DHCP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_static_binding_with_http_info(body, server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpStaticBinding body: (required)
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id', 'binding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `update_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `update_dhcp_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings/{binding-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_v6_ip_pool(self, body, server_id, pool_id, **kwargs):  # noqa: E501
        """Update a DHCP IPv6 server's IP pool  # noqa: E501

        Update a specific ip pool of a given logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_v6_ip_pool(body, server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpV6IpPool body: (required)
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpV6IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dhcp_v6_ip_pool_with_http_info(body, server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_v6_ip_pool_with_http_info(body, server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def update_dhcp_v6_ip_pool_with_http_info(self, body, server_id, pool_id, **kwargs):  # noqa: E501
        """Update a DHCP IPv6 server's IP pool  # noqa: E501

        Update a specific ip pool of a given logical DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_v6_ip_pool_with_http_info(body, server_id, pool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpV6IpPool body: (required)
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpV6IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id', 'pool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_v6_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dhcp_v6_ip_pool`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `update_dhcp_v6_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `update_dhcp_v6_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-ip-pools/{pool-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpV6IpPool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_v6_static_binding(self, body, server_id, binding_id, **kwargs):  # noqa: E501
        """Update a DHCP IPv6 server's static binding  # noqa: E501

        Update a specific static binding of a given local DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_v6_static_binding(body, server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpV6StaticBinding body: (required)
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpV6StaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dhcp_v6_static_binding_with_http_info(body, server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_v6_static_binding_with_http_info(body, server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def update_dhcp_v6_static_binding_with_http_info(self, body, server_id, binding_id, **kwargs):  # noqa: E501
        """Update a DHCP IPv6 server's static binding  # noqa: E501

        Update a specific static binding of a given local DHCP IPv6 server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dhcp_v6_static_binding_with_http_info(body, server_id, binding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DhcpV6StaticBinding body: (required)
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpV6StaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server_id', 'binding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_v6_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dhcp_v6_static_binding`")  # noqa: E501
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `update_dhcp_v6_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `update_dhcp_v6_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ipv6-static-bindings/{binding-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpV6StaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
