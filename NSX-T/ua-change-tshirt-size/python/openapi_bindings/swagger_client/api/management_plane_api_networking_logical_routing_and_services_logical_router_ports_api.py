# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPINetworkingLogicalRoutingAndServicesLogicalRouterPortsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_logical_router_port(self, body, **kwargs):  # noqa: E501
        """Create a Logical Router Port  # noqa: E501

        Creates a logical router port. The required parameters include resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort, LogicalRouterCentralizedServicePort); and logical_router_id (the router to which each logical router port is assigned). The service_bindings parameter is optional.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_logical_router_port(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalRouterPort body: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_logical_router_port_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_logical_router_port_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_logical_router_port_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Logical Router Port  # noqa: E501

        Creates a logical router port. The required parameters include resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort, LogicalRouterCentralizedServicePort); and logical_router_id (the router to which each logical router port is assigned). The service_bindings parameter is optional.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_logical_router_port_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalRouterPort body: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_logical_router_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_logical_router_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_logical_router_port(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Delete a Logical Router Port  # noqa: E501

        Deletes the specified logical router port. You must delete logical router ports before you can delete the associated logical router. To Delete Tier0 router link port you must have to delete attached tier1 router link port, otherwise pass \"force=true\" as query param to force delete the Tier0 router link port.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_logical_router_port(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param bool cascade_delete_linked_ports: Flag to specify whether to delete related logical switch ports
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_logical_router_port_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_logical_router_port_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def delete_logical_router_port_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Delete a Logical Router Port  # noqa: E501

        Deletes the specified logical router port. You must delete logical router ports before you can delete the associated logical router. To Delete Tier0 router link port you must have to delete attached tier1 router link port, otherwise pass \"force=true\" as query param to force delete the Tier0 router link port.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_logical_router_port_with_http_info(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param bool cascade_delete_linked_ports: Flag to specify whether to delete related logical switch ports
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'cascade_delete_linked_ports', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_logical_router_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `delete_logical_router_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'cascade_delete_linked_ports' in params:
            query_params.append(('cascade_delete_linked_ports', params['cascade_delete_linked_ports']))  # noqa: E501
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_arp_table(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the ARP table (IPv4) or Neighbor Discovery table (IPv6) for the Logical Router Port of the given id   # noqa: E501

        Returns ARP table (IPv4) or Neighbor Discovery table (IPv6) for the Logical Router Port of the given id, on a node if a query parameter \"transport_node_id=<transport-node-id>\" is given. The transport_node_id parameter is mandatory if the router port is not uplink type. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_arp_table(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortArpTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_port_arp_table_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_arp_table_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_arp_table_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the ARP table (IPv4) or Neighbor Discovery table (IPv6) for the Logical Router Port of the given id   # noqa: E501

        Returns ARP table (IPv4) or Neighbor Discovery table (IPv6) for the Logical Router Port of the given id, on a node if a query parameter \"transport_node_id=<transport-node-id>\" is given. The transport_node_id parameter is mandatory if the router port is not uplink type. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_arp_table_with_http_info(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortArpTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_arp_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_arp_table`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/arp-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortArpTable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_arp_table_in_csv_format_csv(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the ARP table (IPv4) or Neighbor Discovery table (IPv6) for the Logical Router Port of the given id   # noqa: E501

        Returns ARP table (IPv4) or Neighbor Discovery table (IPv6) in CSV format for the Logical Router Port of the given id, on a node if a query parameter \"transport_node_id=<transport-node-id>\" is given. The transport_node_id parameter is mandatory if the router port is not uplink type. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_arp_table_in_csv_format_csv(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortArpTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_port_arp_table_in_csv_format_csv_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_arp_table_in_csv_format_csv_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_arp_table_in_csv_format_csv_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the ARP table (IPv4) or Neighbor Discovery table (IPv6) for the Logical Router Port of the given id   # noqa: E501

        Returns ARP table (IPv4) or Neighbor Discovery table (IPv6) in CSV format for the Logical Router Port of the given id, on a node if a query parameter \"transport_node_id=<transport-node-id>\" is given. The transport_node_id parameter is mandatory if the router port is not uplink type. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_arp_table_in_csv_format_csv_with_http_info(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortArpTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_arp_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_arp_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/arp-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortArpTableInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_state(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Logical Router Port  # noqa: E501

        Return realized state information of a logical router port. Any configuration update that affects the logical router port can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of logical router ports, dhcp relays, etc.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_state(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: LogicalRouterPortState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_port_state_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_state_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_state_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Logical Router Port  # noqa: E501

        Return realized state information of a logical router port. Any configuration update that affects the logical router port can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of logical router ports, dhcp relays, etc.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_state_with_http_info(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: LogicalRouterPortState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'barrier_id', 'request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501
        if 'request_id' in params:
            query_params.append(('request_id', params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_statistics(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the statistics of a specified logical router port on all or a specified node  # noqa: E501

        Returns the statistics for the Logical Router Port. If query parameter \"transport_node_id=<transport-node-id>\" is given,  only the statistics from the given node for the logical router port will be returned. Otherwise the statistics from each node for the same logical router port will be returned. The transport_node_id is mandatory if the router port is not uplink type. The query parameter \"source=cached\" will be ignored and it will always return realtime statistics of the logical router port.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_statistics(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_port_statistics_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_statistics_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_statistics_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the statistics of a specified logical router port on all or a specified node  # noqa: E501

        Returns the statistics for the Logical Router Port. If query parameter \"transport_node_id=<transport-node-id>\" is given,  only the statistics from the given node for the logical router port will be returned. Otherwise the statistics from each node for the same logical router port will be returned. The transport_node_id is mandatory if the router port is not uplink type. The query parameter \"source=cached\" will be ignored and it will always return realtime statistics of the logical router port.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_statistics_with_http_info(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_statistics_summary(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the statistics summary of a specified logical router port  # noqa: E501

        Returns the summation of statistics from all nodes for the Specified Logical Router Port. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_statistics_summary(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :return: LogicalRouterPortStatisticsSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_port_statistics_summary_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_statistics_summary_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_statistics_summary_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the statistics summary of a specified logical router port  # noqa: E501

        Returns the summation of statistics from all nodes for the Specified Logical Router Port. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_port_statistics_summary_with_http_info(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :return: LogicalRouterPortStatisticsSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_statistics_summary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_statistics_summary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/statistics/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortStatisticsSummary',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_logical_router_ports(self, **kwargs):  # noqa: E501
        """List Logical Router Ports  # noqa: E501

        Returns information about all logical router ports. Information includes the resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort, LogicalRouterCentralizedServicePort); logical_router_id (the router to which each logical router port is assigned); and any service_bindings (such as DHCP relay service). The GET request can include a query parameter (logical_router_id or logical_switch_id).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_logical_router_ports(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str logical_router_id: Logical Router identifier
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: Resource types of logical router port
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalRouterPortListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_logical_router_ports_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_logical_router_ports_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_logical_router_ports_with_http_info(self, **kwargs):  # noqa: E501
        """List Logical Router Ports  # noqa: E501

        Returns information about all logical router ports. Information includes the resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort, LogicalRouterCentralizedServicePort); logical_router_id (the router to which each logical router port is assigned); and any service_bindings (such as DHCP relay service). The GET request can include a query parameter (logical_router_id or logical_switch_id).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_logical_router_ports_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str logical_router_id: Logical Router identifier
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: Resource types of logical router port
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalRouterPortListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'logical_router_id', 'logical_switch_id', 'page_size', 'resource_type', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_logical_router_ports" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'logical_router_id' in params:
            query_params.append(('logical_router_id', params['logical_router_id']))  # noqa: E501
        if 'logical_switch_id' in params:
            query_params.append(('logical_switch_id', params['logical_switch_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_logical_router_port(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Read Logical Router Port  # noqa: E501

        Returns information about the specified logical router port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_logical_router_port(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_logical_router_port_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_logical_router_port_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def read_logical_router_port_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Read Logical Router Port  # noqa: E501

        Returns information about the specified logical router port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_logical_router_port_with_http_info(logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_port_id: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_logical_router_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `read_logical_router_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_logical_router_port(self, body, logical_router_port_id, **kwargs):  # noqa: E501
        """Update a Logical Router Port  # noqa: E501

        Modifies the specified logical router port. Required parameters include the resource_type and logical_router_id. Modifiable parameters include the resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort, LogicalRouterCentralizedServicePort), logical_router_id (to reassign the port to a different router), and service_bindings.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_logical_router_port(body, logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalRouterPort body: (required)
        :param str logical_router_port_id: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_logical_router_port_with_http_info(body, logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_logical_router_port_with_http_info(body, logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def update_logical_router_port_with_http_info(self, body, logical_router_port_id, **kwargs):  # noqa: E501
        """Update a Logical Router Port  # noqa: E501

        Modifies the specified logical router port. Required parameters include the resource_type and logical_router_id. Modifiable parameters include the resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort, LogicalRouterCentralizedServicePort), logical_router_id (to reassign the port to a different router), and service_bindings.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_logical_router_port_with_http_info(body, logical_router_port_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalRouterPort body: (required)
        :param str logical_router_port_id: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_port_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_logical_router_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_logical_router_port`")  # noqa: E501
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `update_logical_router_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
