# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPINetworkingLogicalSwitchingLogicalSwitchPortsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_logical_port(self, body, **kwargs):  # noqa: E501
        """Create a Logical Port  # noqa: E501

        Creates a new logical switch port. The required parameters are the associated logical_switch_id and admin_state (UP or DOWN). Optional parameters are the attachment and switching_profile_ids. If you don't specify switching_profile_ids, default switching profiles are assigned to the port. If you don't specify an attachment, the switch port remains empty. To configure an attachment, you must specify an id, and optionally you can specify an attachment_type (VIF or LOGICALROUTER). The attachment_type is VIF by default.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_logical_port(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalPort body: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_logical_port_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_logical_port_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_logical_port_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Logical Port  # noqa: E501

        Creates a new logical switch port. The required parameters are the associated logical_switch_id and admin_state (UP or DOWN). Optional parameters are the attachment and switching_profile_ids. If you don't specify switching_profile_ids, default switching profiles are assigned to the port. If you don't specify an attachment, the switch port remains empty. To configure an attachment, you must specify an id, and optionally you can specify an attachment_type (VIF or LOGICALROUTER). The attachment_type is VIF by default.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_logical_port_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalPort body: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_logical_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_logical_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_switching_profile(self, body, **kwargs):  # noqa: E501
        """Create a Switching Profile  # noqa: E501

        Creates a new, custom qos, port-mirroring, spoof-guard or port-security switching profile. You can override their default switching profile assignments by creating a new switching profile and assigning it to one or more logical switches. You cannot override the default ipfix or ip_discovery switching profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_switching_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseSwitchingProfile body: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_switching_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_switching_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_switching_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Switching Profile  # noqa: E501

        Creates a new, custom qos, port-mirroring, spoof-guard or port-security switching profile. You can override their default switching profile assignments by creating a new switching profile and assigning it to one or more logical switches. You cannot override the default ipfix or ip_discovery switching profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_switching_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseSwitchingProfile body: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_switching_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_switching_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseSwitchingProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_logical_port(self, lport_id, **kwargs):  # noqa: E501
        """Delete a Logical Port  # noqa: E501

        Deletes the specified logical switch port. By default, if logical port has attachments, or it is added to any NSGroup, the deletion will be failed. Option detach could be used for deleting logical port forcibly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_logical_port(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param bool detach: force delete even if attached or referenced by a group
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_logical_port_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_logical_port_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def delete_logical_port_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Delete a Logical Port  # noqa: E501

        Deletes the specified logical switch port. By default, if logical port has attachments, or it is added to any NSGroup, the deletion will be failed. Option detach could be used for deleting logical port forcibly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_logical_port_with_http_info(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param bool detach: force delete even if attached or referenced by a group
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'detach']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_logical_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `delete_logical_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'detach' in params:
            query_params.append(('detach', params['detach']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_switching_profile(self, switching_profile_id, **kwargs):  # noqa: E501
        """Delete a Switching Profile  # noqa: E501

        Deletes the specified switching profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_switching_profile(switching_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str switching_profile_id: (required)
        :param bool unbind: force unbinding of logical switches and ports from a switching profile
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_switching_profile_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_switching_profile_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_switching_profile_with_http_info(self, switching_profile_id, **kwargs):  # noqa: E501
        """Delete a Switching Profile  # noqa: E501

        Deletes the specified switching profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_switching_profile_with_http_info(switching_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str switching_profile_id: (required)
        :param bool unbind: force unbinding of logical switches and ports from a switching profile
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['switching_profile_id', 'unbind']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_switching_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'switching_profile_id' is set
        if ('switching_profile_id' not in params or
                params['switching_profile_id'] is None):
            raise ValueError("Missing the required parameter `switching_profile_id` when calling `delete_switching_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'switching_profile_id' in params:
            path_params['switching-profile-id'] = params['switching_profile_id']  # noqa: E501

        query_params = []
        if 'unbind' in params:
            query_params.append(('unbind', params['unbind']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles/{switching-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port(self, lport_id, **kwargs):  # noqa: E501
        """Get Information About a Logical Port  # noqa: E501

        Returns information about a specified logical port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_port_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get Information About a Logical Port  # noqa: E501

        Returns information about a specified logical port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_with_http_info(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_mac_table(self, lport_id, **kwargs):  # noqa: E501
        """Get MAC table of a logical port with a given port id (lport-id)  # noqa: E501

        Returns MAC table of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \"source=cached\" is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_mac_table(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalPortMacAddressListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_port_mac_table_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_mac_table_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_mac_table_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get MAC table of a logical port with a given port id (lport-id)  # noqa: E501

        Returns MAC table of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \"source=cached\" is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_mac_table_with_http_info(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalPortMacAddressListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_mac_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_mac_table`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/mac-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortMacAddressListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_mac_table_in_csv_format_csv(self, lport_id, **kwargs):  # noqa: E501
        """Get MAC table of a logical port with a given port id (lport-id)  # noqa: E501

        Returns MAC table in CSV format of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \"source=cached\" is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_mac_table_in_csv_format_csv(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalPortMacAddressCsvListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_port_mac_table_in_csv_format_csv_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_mac_table_in_csv_format_csv_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_mac_table_in_csv_format_csv_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get MAC table of a logical port with a given port id (lport-id)  # noqa: E501

        Returns MAC table in CSV format of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \"source=cached\" is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_mac_table_in_csv_format_csv_with_http_info(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalPortMacAddressCsvListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_mac_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_mac_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/mac-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortMacAddressCsvListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_operational_status(self, lport_id, **kwargs):  # noqa: E501
        """Get Operational Status for Logical Port of a Given Port ID (lport-id)  # noqa: E501

        Returns operational status of a specified logical port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_operational_status(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param str source: Data source type.
        :return: LogicalPortOperationalStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_port_operational_status_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_operational_status_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_operational_status_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get Operational Status for Logical Port of a Given Port ID (lport-id)  # noqa: E501

        Returns operational status of a specified logical port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_operational_status_with_http_info(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param str source: Data source type.
        :return: LogicalPortOperationalStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_operational_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_operational_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortOperationalStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_state(self, lport_id, **kwargs):  # noqa: E501
        """Get realized state & location of a logical port  # noqa: E501

        Returns transport node id for a specified logical port. Also returns information about all address bindings of the specified logical port. This includes address bindings discovered via various snooping methods like ARP snooping, DHCP snooping etc. and addressing bindings that are realized based on user configuration.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_state(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :return: LogicalPortState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_port_state_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_state_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_state_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get realized state & location of a logical port  # noqa: E501

        Returns transport node id for a specified logical port. Also returns information about all address bindings of the specified logical port. This includes address bindings discovered via various snooping methods like ARP snooping, DHCP snooping etc. and addressing bindings that are realized based on user configuration.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_state_with_http_info(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :return: LogicalPortState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_statistics(self, lport_id, **kwargs):  # noqa: E501
        """Get Statistics for Logical Port of a Given Port ID (lport-id)  # noqa: E501

        Returns statistics of a specified logical port. If the logical port is attached to a logical router port, query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_statistics(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param str source: Data source type.
        :return: LogicalPortStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_port_statistics_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_statistics_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_statistics_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get Statistics for Logical Port of a Given Port ID (lport-id)  # noqa: E501

        Returns statistics of a specified logical port. If the logical port is attached to a logical router port, query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_statistics_with_http_info(lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str lport_id: (required)
        :param str source: Data source type.
        :return: LogicalPortStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_status_summary(self, **kwargs):  # noqa: E501
        """Get Operational Status Summary of All Logical Ports in the System  # noqa: E501

        Returns operational status of all logical ports. The query parameter \"source=realtime\" is not supported. Pagination is not supported for this API. The query parameters \"cursor\", \"sort_ascending\", \"sort_by\", \"page_size\" and \"included_fields\" will be ignored.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_status_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str attachment_id: Logical Port attachment Id
        :param str attachment_type: Type of attachment for logical port; for query only.
        :param str bridge_cluster_id: Bridge Cluster identifier
        :param bool container_ports_only: Only container VIF logical ports will be returned if true
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical port.
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str parent_vif_id: ID of the VIF of type PARENT
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str switching_profile_id: Network Profile identifier
        :param str transport_node_id: Transport node identifier
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalPortStatusSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_port_status_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_status_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_logical_port_status_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Get Operational Status Summary of All Logical Ports in the System  # noqa: E501

        Returns operational status of all logical ports. The query parameter \"source=realtime\" is not supported. Pagination is not supported for this API. The query parameters \"cursor\", \"sort_ascending\", \"sort_by\", \"page_size\" and \"included_fields\" will be ignored.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_port_status_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str attachment_id: Logical Port attachment Id
        :param str attachment_type: Type of attachment for logical port; for query only.
        :param str bridge_cluster_id: Bridge Cluster identifier
        :param bool container_ports_only: Only container VIF logical ports will be returned if true
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical port.
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str parent_vif_id: ID of the VIF of type PARENT
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str switching_profile_id: Network Profile identifier
        :param str transport_node_id: Transport node identifier
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalPortStatusSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['attachment_id', 'attachment_type', 'bridge_cluster_id', 'container_ports_only', 'cursor', 'diagnostic', 'included_fields', 'logical_switch_id', 'page_size', 'parent_vif_id', 'sort_ascending', 'sort_by', 'source', 'switching_profile_id', 'transport_node_id', 'transport_zone_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_status_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'attachment_id' in params:
            query_params.append(('attachment_id', params['attachment_id']))  # noqa: E501
        if 'attachment_type' in params:
            query_params.append(('attachment_type', params['attachment_type']))  # noqa: E501
        if 'bridge_cluster_id' in params:
            query_params.append(('bridge_cluster_id', params['bridge_cluster_id']))  # noqa: E501
        if 'container_ports_only' in params:
            query_params.append(('container_ports_only', params['container_ports_only']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'diagnostic' in params:
            query_params.append(('diagnostic', params['diagnostic']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'logical_switch_id' in params:
            query_params.append(('logical_switch_id', params['logical_switch_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'parent_vif_id' in params:
            query_params.append(('parent_vif_id', params['parent_vif_id']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'switching_profile_id' in params:
            query_params.append(('switching_profile_id', params['switching_profile_id']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501
        if 'transport_zone_id' in params:
            query_params.append(('transport_zone_id', params['transport_zone_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortStatusSummary',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_switching_profile(self, switching_profile_id, **kwargs):  # noqa: E501
        """Get Switching Profile by ID  # noqa: E501

        Returns information about a specified switching profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_switching_profile(switching_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str switching_profile_id: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_switching_profile_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_switching_profile_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
            return data

    def get_switching_profile_with_http_info(self, switching_profile_id, **kwargs):  # noqa: E501
        """Get Switching Profile by ID  # noqa: E501

        Returns information about a specified switching profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_switching_profile_with_http_info(switching_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str switching_profile_id: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['switching_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_switching_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'switching_profile_id' is set
        if ('switching_profile_id' not in params or
                params['switching_profile_id'] is None):
            raise ValueError("Missing the required parameter `switching_profile_id` when calling `get_switching_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'switching_profile_id' in params:
            path_params['switching-profile-id'] = params['switching_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles/{switching-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseSwitchingProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_switching_profile_status(self, switching_profile_id, **kwargs):  # noqa: E501
        """Get Counts of Ports and Switches Using This Switching Profile  # noqa: E501

        Get Counts of Ports and Switches Using This Switching Profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_switching_profile_status(switching_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str switching_profile_id: (required)
        :return: SwitchingProfileStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_switching_profile_status_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_switching_profile_status_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
            return data

    def get_switching_profile_status_with_http_info(self, switching_profile_id, **kwargs):  # noqa: E501
        """Get Counts of Ports and Switches Using This Switching Profile  # noqa: E501

        Get Counts of Ports and Switches Using This Switching Profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_switching_profile_status_with_http_info(switching_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str switching_profile_id: (required)
        :return: SwitchingProfileStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['switching_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_switching_profile_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'switching_profile_id' is set
        if ('switching_profile_id' not in params or
                params['switching_profile_id'] is None):
            raise ValueError("Missing the required parameter `switching_profile_id` when calling `get_switching_profile_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'switching_profile_id' in params:
            path_params['switching-profile-id'] = params['switching_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles/{switching-profile-id}/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SwitchingProfileStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_logical_ports(self, **kwargs):  # noqa: E501
        """List All Logical Ports  # noqa: E501

        Returns information about all configured logical switch ports. Logical switch ports connect to VM virtual network interface cards (NICs). Each logical port is associated with one logical switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_logical_ports(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str attachment_id: Logical Port attachment Id
        :param str attachment_type: Type of attachment for logical port; for query only.
        :param str bridge_cluster_id: Bridge Cluster identifier
        :param bool container_ports_only: Only container VIF logical ports will be returned if true
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical port.
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str parent_vif_id: ID of the VIF of type PARENT
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_id: Network Profile identifier
        :param str transport_node_id: Transport node identifier
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalPortListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_logical_ports_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_logical_ports_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_logical_ports_with_http_info(self, **kwargs):  # noqa: E501
        """List All Logical Ports  # noqa: E501

        Returns information about all configured logical switch ports. Logical switch ports connect to VM virtual network interface cards (NICs). Each logical port is associated with one logical switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_logical_ports_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str attachment_id: Logical Port attachment Id
        :param str attachment_type: Type of attachment for logical port; for query only.
        :param str bridge_cluster_id: Bridge Cluster identifier
        :param bool container_ports_only: Only container VIF logical ports will be returned if true
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical port.
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str parent_vif_id: ID of the VIF of type PARENT
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_id: Network Profile identifier
        :param str transport_node_id: Transport node identifier
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalPortListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['attachment_id', 'attachment_type', 'bridge_cluster_id', 'container_ports_only', 'cursor', 'diagnostic', 'included_fields', 'logical_switch_id', 'page_size', 'parent_vif_id', 'sort_ascending', 'sort_by', 'switching_profile_id', 'transport_node_id', 'transport_zone_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_logical_ports" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'attachment_id' in params:
            query_params.append(('attachment_id', params['attachment_id']))  # noqa: E501
        if 'attachment_type' in params:
            query_params.append(('attachment_type', params['attachment_type']))  # noqa: E501
        if 'bridge_cluster_id' in params:
            query_params.append(('bridge_cluster_id', params['bridge_cluster_id']))  # noqa: E501
        if 'container_ports_only' in params:
            query_params.append(('container_ports_only', params['container_ports_only']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'diagnostic' in params:
            query_params.append(('diagnostic', params['diagnostic']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'logical_switch_id' in params:
            query_params.append(('logical_switch_id', params['logical_switch_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'parent_vif_id' in params:
            query_params.append(('parent_vif_id', params['parent_vif_id']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'switching_profile_id' in params:
            query_params.append(('switching_profile_id', params['switching_profile_id']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501
        if 'transport_zone_id' in params:
            query_params.append(('transport_zone_id', params['transport_zone_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_switching_profiles(self, **kwargs):  # noqa: E501
        """List Switching Profiles  # noqa: E501

        Returns information about the system-default and user-configured switching profiles. Each switching profile has a unique ID, a display name, and various other read-only and configurable properties. The default switching profiles are assigned automatically to each switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_switching_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_type: comma-separated list of switching profile types, e.g. ?switching_profile_type=QosSwitchingProfile,IpDiscoverySwitchingProfile
        :return: SwitchingProfilesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_switching_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_switching_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_switching_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List Switching Profiles  # noqa: E501

        Returns information about the system-default and user-configured switching profiles. Each switching profile has a unique ID, a display name, and various other read-only and configurable properties. The default switching profiles are assigned automatically to each switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_switching_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_type: comma-separated list of switching profile types, e.g. ?switching_profile_type=QosSwitchingProfile,IpDiscoverySwitchingProfile
        :return: SwitchingProfilesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'include_system_owned', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'switching_profile_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_switching_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'include_system_owned' in params:
            query_params.append(('include_system_owned', params['include_system_owned']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'switching_profile_type' in params:
            query_params.append(('switching_profile_type', params['switching_profile_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SwitchingProfilesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_logical_port(self, body, lport_id, **kwargs):  # noqa: E501
        """Update a Logical Port  # noqa: E501

        Modifies an existing logical switch port. Parameters that can be modified include attachment_type (LOGICALROUTER, VIF), admin_state (UP or DOWN), attachment id and switching_profile_ids. You cannot modify the logical_switch_id. In other words, you cannot move an existing port from one switch to another switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_logical_port(body, lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalPort body: (required)
        :param str lport_id: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_logical_port_with_http_info(body, lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_logical_port_with_http_info(body, lport_id, **kwargs)  # noqa: E501
            return data

    def update_logical_port_with_http_info(self, body, lport_id, **kwargs):  # noqa: E501
        """Update a Logical Port  # noqa: E501

        Modifies an existing logical switch port. Parameters that can be modified include attachment_type (LOGICALROUTER, VIF), admin_state (UP or DOWN), attachment id and switching_profile_ids. You cannot modify the logical_switch_id. In other words, you cannot move an existing port from one switch to another switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_logical_port_with_http_info(body, lport_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalPort body: (required)
        :param str lport_id: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'lport_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_logical_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_logical_port`")  # noqa: E501
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `update_logical_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_switching_profile(self, body, switching_profile_id, **kwargs):  # noqa: E501
        """Update a Switching Profile  # noqa: E501

        Updates the user-configurable parameters of a switching profile. Only the qos, port-mirroring, spoof-guard and port-security switching profiles can be modified. You cannot modify the ipfix or ip-discovery switching profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_switching_profile(body, switching_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseSwitchingProfile body: (required)
        :param str switching_profile_id: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_switching_profile_with_http_info(body, switching_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_switching_profile_with_http_info(body, switching_profile_id, **kwargs)  # noqa: E501
            return data

    def update_switching_profile_with_http_info(self, body, switching_profile_id, **kwargs):  # noqa: E501
        """Update a Switching Profile  # noqa: E501

        Updates the user-configurable parameters of a switching profile. Only the qos, port-mirroring, spoof-guard and port-security switching profiles can be modified. You cannot modify the ipfix or ip-discovery switching profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_switching_profile_with_http_info(body, switching_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseSwitchingProfile body: (required)
        :param str switching_profile_id: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'switching_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_switching_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_switching_profile`")  # noqa: E501
        # verify the required parameter 'switching_profile_id' is set
        if ('switching_profile_id' not in params or
                params['switching_profile_id'] is None):
            raise ValueError("Missing the required parameter `switching_profile_id` when calling `update_switching_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'switching_profile_id' in params:
            path_params['switching-profile-id'] = params['switching_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles/{switching-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseSwitchingProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
