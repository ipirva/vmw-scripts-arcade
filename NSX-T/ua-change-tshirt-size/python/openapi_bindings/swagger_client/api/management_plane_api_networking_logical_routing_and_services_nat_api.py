# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPINetworkingLogicalRoutingAndServicesNATApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_nat_rule(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add a NAT rule in a specific logical router  # noqa: E501

        Add a NAT rule in a specific logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_nat_rule(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NatRule body: (required)
        :param str logical_router_id: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_nat_rule_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_nat_rule_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def add_nat_rule_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add a NAT rule in a specific logical router  # noqa: E501

        Add a NAT rule in a specific logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_nat_rule_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NatRule body: (required)
        :param str logical_router_id: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_nat_rule`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_nat_rules_create_multiple(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add multiple NAT rules in a specific logical router  # noqa: E501

        Create multiple NAT rules in a specific logical router. The API succeeds only when all rules are accepted and created successfully. Any one validation voilation will fail the API, no rule will be created. The ruleIds of each rules can be found from the responsed message.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_nat_rules_create_multiple(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NatRuleList body: (required)
        :param str logical_router_id: (required)
        :return: NatRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_nat_rules_create_multiple_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_nat_rules_create_multiple_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def add_nat_rules_create_multiple_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add multiple NAT rules in a specific logical router  # noqa: E501

        Create multiple NAT rules in a specific logical router. The API succeeds only when all rules are accepted and created successfully. Any one validation voilation will fail the API, no rule will be created. The ruleIds of each rules can be found from the responsed message.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_nat_rules_create_multiple_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NatRuleList body: (required)
        :param str logical_router_id: (required)
        :return: NatRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_nat_rules_create_multiple" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_nat_rules_create_multiple`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_nat_rules_create_multiple`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules?action=create_multiple', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_nat_rule(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Delete a specific NAT rule from a logical router  # noqa: E501

        Delete a specific NAT rule from a logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_nat_rule(logical_router_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_nat_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_nat_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
            return data

    def delete_nat_rule_with_http_info(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Delete a specific NAT rule from a logical router  # noqa: E501

        Delete a specific NAT rule from a logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_nat_rule_with_http_info(logical_router_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_nat_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/{rule-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nat_rule(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Get a specific NAT rule from a given logical router  # noqa: E501

        Get a specific NAT rule from a given logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nat_rule(logical_router_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nat_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nat_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_nat_rule_with_http_info(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Get a specific NAT rule from a given logical router  # noqa: E501

        Get a specific NAT rule from a given logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nat_rule_with_http_info(logical_router_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_nat_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nat_statistics_per_logical_router(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the statistics of all rules of the logical router  # noqa: E501

        Returns the summation of statistics for all rules from all nodes for the Specified Logical Router. Also gives the per transport node statistics for provided logical router. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nat_statistics_per_logical_router(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerLogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nat_statistics_per_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nat_statistics_per_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def get_nat_statistics_per_logical_router_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the statistics of all rules of the logical router  # noqa: E501

        Returns the summation of statistics for all rules from all nodes for the Specified Logical Router. Also gives the per transport node statistics for provided logical router. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nat_statistics_per_logical_router_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerLogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nat_statistics_per_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_nat_statistics_per_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatStatisticsPerLogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nat_statistics_per_rule(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Get the statistics of a specified logical router NAT Rule  # noqa: E501

        Returns the summation of statistics from all nodes for the Specified Logical Router NAT Rule. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nat_statistics_per_rule(logical_router_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nat_statistics_per_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nat_statistics_per_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_nat_statistics_per_rule_with_http_info(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Get the statistics of a specified logical router NAT Rule  # noqa: E501

        Returns the summation of statistics from all nodes for the Specified Logical Router NAT Rule. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nat_statistics_per_rule_with_http_info(logical_router_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'rule_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nat_statistics_per_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_nat_statistics_per_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_nat_statistics_per_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/{rule-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatStatisticsPerRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nat_statistics_per_transport_node(self, node_id, **kwargs):  # noqa: E501
        """Get statistics for all logical router NAT rules on a transport node  # noqa: E501

        Returns the summation of statistics for all rules from all logical routers which are present on given transport node. Only cached statistics are supported. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nat_statistics_per_transport_node(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerTransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nat_statistics_per_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nat_statistics_per_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_nat_statistics_per_transport_node_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Get statistics for all logical router NAT rules on a transport node  # noqa: E501

        Returns the summation of statistics for all rules from all logical routers which are present on given transport node. Only cached statistics are supported. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nat_statistics_per_transport_node_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerTransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nat_statistics_per_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_nat_statistics_per_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/statistics/nat-rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatStatisticsPerTransportNode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_nat_rules(self, logical_router_id, **kwargs):  # noqa: E501
        """List NAT rules of the logical router  # noqa: E501

        Returns paginated list of all user defined NAT rules of the specific logical router. If a rule_type is provided, only the given type of rules will be returned. If no rule_type is specified, the rule_type will be defaulted to NATv4, i.e. only the NATv4 rules will be listed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_nat_rules(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str rule_type: Action type for getting NAT rules
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NatRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_nat_rules_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_nat_rules_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_nat_rules_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """List NAT rules of the logical router  # noqa: E501

        Returns paginated list of all user defined NAT rules of the specific logical router. If a rule_type is provided, only the given type of rules will be returned. If no rule_type is specified, the rule_type will be defaulted to NATv4, i.e. only the NATv4 rules will be listed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_nat_rules_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str rule_type: Action type for getting NAT rules
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NatRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'rule_type', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_nat_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_nat_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'rule_type' in params:
            query_params.append(('rule_type', params['rule_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_nat_rule(self, body, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Update a specific NAT rule from a given logical router  # noqa: E501

        Update a specific NAT rule from a given logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_nat_rule(body, logical_router_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NatRule body: (required)
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_nat_rule_with_http_info(body, logical_router_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_nat_rule_with_http_info(body, logical_router_id, rule_id, **kwargs)  # noqa: E501
            return data

    def update_nat_rule_with_http_info(self, body, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Update a specific NAT rule from a given logical router  # noqa: E501

        Update a specific NAT rule from a given logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_nat_rule_with_http_info(body, logical_router_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NatRule body: (required)
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_nat_rule`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_nat_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `update_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/{rule-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
