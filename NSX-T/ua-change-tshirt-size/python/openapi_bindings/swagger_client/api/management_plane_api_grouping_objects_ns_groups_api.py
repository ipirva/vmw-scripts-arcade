# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPIGroupingObjectsNSGroupsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_or_remove_ns_group_expression(self, body, action, ns_group_id, **kwargs):  # noqa: E501
        """Add NSGroup expression  # noqa: E501

        Add/remove the expressions passed in the request body to/from the NSGroup   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_or_remove_ns_group_expression(body, action, ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NSGroupExpressionList body: (required)
        :param str action: Specifies addition or removal action (required)
        :param str ns_group_id: NSGroup Id (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_or_remove_ns_group_expression_with_http_info(body, action, ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_or_remove_ns_group_expression_with_http_info(body, action, ns_group_id, **kwargs)  # noqa: E501
            return data

    def add_or_remove_ns_group_expression_with_http_info(self, body, action, ns_group_id, **kwargs):  # noqa: E501
        """Add NSGroup expression  # noqa: E501

        Add/remove the expressions passed in the request body to/from the NSGroup   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_or_remove_ns_group_expression_with_http_info(body, action, ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NSGroupExpressionList body: (required)
        :param str action: Specifies addition or removal action (required)
        :param str ns_group_id: NSGroup Id (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'action', 'ns_group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_or_remove_ns_group_expression" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_or_remove_ns_group_expression`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `add_or_remove_ns_group_expression`")  # noqa: E501
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `add_or_remove_ns_group_expression`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ns_group(self, body, **kwargs):  # noqa: E501
        """Create NSGroup  # noqa: E501

        Creates a new NSGroup that can group NSX resources - VIFs, Lports and LSwitches as well as the grouping objects - IPSet, MACSet and other NSGroups. For NSGroups containing VM criteria(both static and dynamic), system VMs will not be included as members. This filter applies at VM level only. Exceptions are as follows: 1. LogicalPorts and VNI of System VMs will be included in NSGroup if the criteria  is based on LogicalPort, LogicalSwitch or VNI directly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ns_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NSGroup body: (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ns_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ns_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_ns_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create NSGroup  # noqa: E501

        Creates a new NSGroup that can group NSX resources - VIFs, Lports and LSwitches as well as the grouping objects - IPSet, MACSet and other NSGroups. For NSGroups containing VM criteria(both static and dynamic), system VMs will not be included as members. This filter applies at VM level only. Exceptions are as follows: 1. LogicalPorts and VNI of System VMs will be included in NSGroup if the criteria  is based on LogicalPort, LogicalSwitch or VNI directly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ns_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NSGroup body: (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ns_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_ns_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ns_profile(self, body, **kwargs):  # noqa: E501
        """Create NSProfile  # noqa: E501

        Creates a new NSProfile which allows users to encapsulate attribute and sub-attributes of network services. Rules for using attributes and sub-attributes in single NSProfile 1. One type of attribute can't have multiple occurrences. ( Example -  Attribute type APP_ID can be used only once per NSProfile.) 2. Values for an attribute are mentioned as array of strings.  ( Example - For type APP_ID , values can be mentioned as [\"SSL\",\"FTP\"].) 3. If sub-attribtes are mentioned for an attribute, then only single  value is allowed for that attribute. 4. To get a list of supported  attributes and sub-attributes fire the following REST API  GET https://&lt;nsx-mgr&gt;/api/v1/ns-profiles/attributes   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ns_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NSProfile body: (required)
        :return: NSProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ns_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ns_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_ns_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create NSProfile  # noqa: E501

        Creates a new NSProfile which allows users to encapsulate attribute and sub-attributes of network services. Rules for using attributes and sub-attributes in single NSProfile 1. One type of attribute can't have multiple occurrences. ( Example -  Attribute type APP_ID can be used only once per NSProfile.) 2. Values for an attribute are mentioned as array of strings.  ( Example - For type APP_ID , values can be mentioned as [\"SSL\",\"FTP\"].) 3. If sub-attribtes are mentioned for an attribute, then only single  value is allowed for that attribute. 4. To get a list of supported  attributes and sub-attributes fire the following REST API  GET https://&lt;nsx-mgr&gt;/api/v1/ns-profiles/attributes   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ns_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NSProfile body: (required)
        :return: NSProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ns_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_ns_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ns_group(self, ns_group_id, **kwargs):  # noqa: E501
        """Delete NSGroup  # noqa: E501

        Deletes the specified NSGroup. By default, if the NSGroup is added to another NSGroup, it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ns_group(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ns_group_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ns_group_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def delete_ns_group_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Delete NSGroup  # noqa: E501

        Deletes the specified NSGroup. By default, if the NSGroup is added to another NSGroup, it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ns_group_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ns_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `delete_ns_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_consolidated_effective_ip_address_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get consolidated Effective IPAddress translated from the NSGroup  # noqa: E501

        Returns consolidated effective ip address members of the specified NSGroup. Applicable in case of federated environment. The response contains site-wise list of consolidated effective IP address members. In the response, for the local-site, the list will contain static and dynamicaly translated IPs. For the remote sites, the list will contain only the dynamically translated IPs. The static IPs will not be seen in the response of this API. Hence, user can refer to the local-site Ip response in the API results or the group definition to see the static IP membership of the Group. This API is applicable only for NSGroups containing either VirtualMachine, VIF, LogicalSwitch, LogicalPort or IPSet member type. For NSGroups containing other member types,it returns an empty list. Use the cursor value in the response to fetch the next page. If there is no cursor value for a response, it implies the last page in the results for the query.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_consolidated_effective_ip_address_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str ip_filter: IP address, range, or subnet
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str site_id: UUID of the site from which the effective IP addresses are to be fetched 
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ConsolidatedEffectiveIPAddressMemberListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_consolidated_effective_ip_address_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_consolidated_effective_ip_address_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_consolidated_effective_ip_address_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get consolidated Effective IPAddress translated from the NSGroup  # noqa: E501

        Returns consolidated effective ip address members of the specified NSGroup. Applicable in case of federated environment. The response contains site-wise list of consolidated effective IP address members. In the response, for the local-site, the list will contain static and dynamicaly translated IPs. For the remote sites, the list will contain only the dynamically translated IPs. The static IPs will not be seen in the response of this API. Hence, user can refer to the local-site Ip response in the API results or the group definition to see the static IP membership of the Group. This API is applicable only for NSGroups containing either VirtualMachine, VIF, LogicalSwitch, LogicalPort or IPSet member type. For NSGroups containing other member types,it returns an empty list. Use the cursor value in the response to fetch the next page. If there is no cursor value for a response, it implies the last page in the results for the query.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_consolidated_effective_ip_address_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str ip_filter: IP address, range, or subnet
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str site_id: UUID of the site from which the effective IP addresses are to be fetched 
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ConsolidatedEffectiveIPAddressMemberListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'ip_filter', 'page_size', 'site_id', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_consolidated_effective_ip_address_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_consolidated_effective_ip_address_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'ip_filter' in params:
            query_params.append(('ip_filter', params['ip_filter']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/consolidated-effective-ip-address-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolidatedEffectiveIPAddressMemberListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_active_directory_groups(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Directory Groups of the specified NSGroup.  # noqa: E501

        Returns effective directory groups which are members of the specified NSGroup. This API is applicable only for NSGroups containing DirectoryGroup member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_active_directory_groups(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_active_directory_groups_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_active_directory_groups_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_active_directory_groups_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Directory Groups of the specified NSGroup.  # noqa: E501

        Returns effective directory groups which are members of the specified NSGroup. This API is applicable only for NSGroups containing DirectoryGroup member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_active_directory_groups_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_active_directory_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_active_directory_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-directory-group-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_cloud_native_service_instances(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Cloud Native Service Instances of the specified NSGroup.  # noqa: E501

        Returns effective cloud native service instances of the specified NSGroup. This API is applicable only for NSGroups containing CloudNativeServiceInstance member type. For NSGroups containing other member types,it returns an empty list. target_id in response is external_id of CloudNativeServiceInstance   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_cloud_native_service_instances(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_cloud_native_service_instances_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_cloud_native_service_instances_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_cloud_native_service_instances_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Cloud Native Service Instances of the specified NSGroup.  # noqa: E501

        Returns effective cloud native service instances of the specified NSGroup. This API is applicable only for NSGroups containing CloudNativeServiceInstance member type. For NSGroups containing other member types,it returns an empty list. target_id in response is external_id of CloudNativeServiceInstance   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_cloud_native_service_instances_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_cloud_native_service_instances" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_cloud_native_service_instances`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-cloud-native-service-instance-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_ip_address_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective IPAddress translated from the NSGroup  # noqa: E501

        Returns effective ip address members of the specified NSGroup. This API is applicable only for NSGroups containing either VirtualMachine, VIF, LogicalSwitch, LogicalPort or IPSet member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_ip_address_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveIPAddressMemberListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_ip_address_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_ip_address_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_ip_address_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective IPAddress translated from the NSGroup  # noqa: E501

        Returns effective ip address members of the specified NSGroup. This API is applicable only for NSGroups containing either VirtualMachine, VIF, LogicalSwitch, LogicalPort or IPSet member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_ip_address_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveIPAddressMemberListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_ip_address_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_ip_address_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-ip-address-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveIPAddressMemberListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_ip_set_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective IPSets of the specified NSGroup.  # noqa: E501

        Returns effective IPSets which are members of the specified NSGroup. This API is applicable only for NSGroups containing IPSet member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_ip_set_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_ip_set_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_ip_set_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_ip_set_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective IPSets of the specified NSGroup.  # noqa: E501

        Returns effective IPSets which are members of the specified NSGroup. This API is applicable only for NSGroups containing IPSet member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_ip_set_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_ip_set_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_ip_set_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-ipset-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_logical_port_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Logical Ports translated from the NSgroup  # noqa: E501

        Returns effective logical port members of the specified NSGroup. This API is applicable only for NSGroups containing either VirtualMachines, LogicalSwitch or LogicalPort member types.For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_logical_port_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_logical_port_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_logical_port_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_logical_port_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Logical Ports translated from the NSgroup  # noqa: E501

        Returns effective logical port members of the specified NSGroup. This API is applicable only for NSGroups containing either VirtualMachines, LogicalSwitch or LogicalPort member types.For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_logical_port_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_logical_port_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_logical_port_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-logical-port-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_logical_switch_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective switch members translated from the NSGroup  # noqa: E501

        Returns effective logical switch members of the specified NSGroup. This API is applicable for NSGroups containing LogicalSwitch members. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_logical_switch_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_logical_switch_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_logical_switch_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_logical_switch_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective switch members translated from the NSGroup  # noqa: E501

        Returns effective logical switch members of the specified NSGroup. This API is applicable for NSGroups containing LogicalSwitch members. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_logical_switch_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_logical_switch_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_logical_switch_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-logical-switch-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_physical_server_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Physical Server Memebers of the specified NSGroup.  # noqa: E501

        Returns effective physical server members of the specified NSGroup. This API is applicable only for NSGroups containing Physical Server member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_physical_server_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_physical_server_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_physical_server_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_physical_server_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Physical Server Memebers of the specified NSGroup.  # noqa: E501

        Returns effective physical server members of the specified NSGroup. This API is applicable only for NSGroups containing Physical Server member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_physical_server_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_physical_server_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_physical_server_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-physical-server-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_transport_node_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get effective transport node members translated from the NSGroup  # noqa: E501

        Returns effective transport node members of the specified NSGroup. This API is applicable only for NSGroups containing TransportNode member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_transport_node_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_transport_node_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_transport_node_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_transport_node_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get effective transport node members translated from the NSGroup  # noqa: E501

        Returns effective transport node members of the specified NSGroup. This API is applicable only for NSGroups containing TransportNode member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_transport_node_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_transport_node_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_transport_node_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-transport-node-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_vif_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get effective VIF members translated from the NSGroup  # noqa: E501

        Returns effective VIF members of the specified NSGroup. This API is applicable only for NSGroups containing either VirtualMachines or VIF member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_vif_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VirtualNetworkInterfaceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_vif_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_vif_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_vif_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get effective VIF members translated from the NSGroup  # noqa: E501

        Returns effective VIF members of the specified NSGroup. This API is applicable only for NSGroups containing either VirtualMachines or VIF member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_vif_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VirtualNetworkInterfaceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_vif_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_vif_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-vif-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualNetworkInterfaceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_virtual_machine_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Virtual Machine members of the specified NSGroup.  # noqa: E501

        Returns effective virtual machine members of the specified NSGroup. This API is applicable only for NSGroups containing VirtualMachine member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_virtual_machine_members(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VirtualMachineListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_effective_virtual_machine_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_virtual_machine_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_virtual_machine_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Virtual Machine members of the specified NSGroup.  # noqa: E501

        Returns effective virtual machine members of the specified NSGroup. This API is applicable only for NSGroups containing VirtualMachine member type. For NSGroups containing other member types,it returns an empty list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_effective_virtual_machine_members_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VirtualMachineListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_virtual_machine_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_virtual_machine_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-virtual-machine-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualMachineListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_member_types(self, ns_group_id, **kwargs):  # noqa: E501
        """Get member types from NSGroup  # noqa: E501

        Returns member types for a specified NSGroup including child NSGroups. This considers static members and members added via membership criteria only   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_member_types(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberTypeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_member_types_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_member_types_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_member_types_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get member types from NSGroup  # noqa: E501

        Returns member types for a specified NSGroup including child NSGroups. This considers static members and members added via membership criteria only   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_member_types_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberTypeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_member_types" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_member_types`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/member-types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberTypeListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_associations(self, nsgroup_id, service_type, **kwargs):  # noqa: E501
        """Get services to which the given nsgroup belongs to   # noqa: E501

        Returns information about services that are associated with the given NSGroup. The service name is passed by service_type parameter   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_associations(nsgroup_id, service_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str nsgroup_id: (required)
        :param str service_type: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool fetch_parentgroup_associations: Fetch complete list of associated resources considering nesting 
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceAssociationListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_associations_with_http_info(nsgroup_id, service_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_associations_with_http_info(nsgroup_id, service_type, **kwargs)  # noqa: E501
            return data

    def get_service_associations_with_http_info(self, nsgroup_id, service_type, **kwargs):  # noqa: E501
        """Get services to which the given nsgroup belongs to   # noqa: E501

        Returns information about services that are associated with the given NSGroup. The service name is passed by service_type parameter   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_associations_with_http_info(nsgroup_id, service_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str nsgroup_id: (required)
        :param str service_type: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool fetch_parentgroup_associations: Fetch complete list of associated resources considering nesting 
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceAssociationListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['nsgroup_id', 'service_type', 'cursor', 'fetch_parentgroup_associations', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'nsgroup_id' is set
        if ('nsgroup_id' not in params or
                params['nsgroup_id'] is None):
            raise ValueError("Missing the required parameter `nsgroup_id` when calling `get_service_associations`")  # noqa: E501
        # verify the required parameter 'service_type' is set
        if ('service_type' not in params or
                params['service_type'] is None):
            raise ValueError("Missing the required parameter `service_type` when calling `get_service_associations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'nsgroup_id' in params:
            path_params['nsgroup-id'] = params['nsgroup_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'fetch_parentgroup_associations' in params:
            query_params.append(('fetch_parentgroup_associations', params['fetch_parentgroup_associations']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'service_type' in params:
            query_params.append(('service_type', params['service_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{nsgroup-id}/service-associations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceAssociationListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unassociated_virtual_machines(self, **kwargs):  # noqa: E501
        """Get the list of all the virtual machines that are not a part of any existing NSGroup.  # noqa: E501

        Get the list of all the virtual machines that are not a part of any existing NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unassociated_virtual_machines(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str display_name: Display Name of the virtual machine
        :param str external_id: External id of the virtual machine
        :param str host_id: Id of the host where this vif is located
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: UnassociatedVMListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_unassociated_virtual_machines_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_unassociated_virtual_machines_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_unassociated_virtual_machines_with_http_info(self, **kwargs):  # noqa: E501
        """Get the list of all the virtual machines that are not a part of any existing NSGroup.  # noqa: E501

        Get the list of all the virtual machines that are not a part of any existing NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unassociated_virtual_machines_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str display_name: Display Name of the virtual machine
        :param str external_id: External id of the virtual machine
        :param str host_id: Id of the host where this vif is located
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: UnassociatedVMListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'display_name', 'external_id', 'host_id', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unassociated_virtual_machines" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'display_name' in params:
            query_params.append(('display_name', params['display_name']))  # noqa: E501
        if 'external_id' in params:
            query_params.append(('external_id', params['external_id']))  # noqa: E501
        if 'host_id' in params:
            query_params.append(('host_id', params['host_id']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/unassociated-virtual-machines', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UnassociatedVMListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ns_groups(self, **kwargs):  # noqa: E501
        """List NSGroups  # noqa: E501

        List the NSGroups in a paginated format. The page size is restricted to 50 NSGroups so that the size of the response remains small even in the worst case. Optionally, specify valid member types as request parameter to filter NSGroups.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_ns_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str member_types: Specify member types to filter corresponding NSGroups 
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool populate_references: Populate metadata of resource referenced by NSGroupExpressions 
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NSGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_ns_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ns_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ns_groups_with_http_info(self, **kwargs):  # noqa: E501
        """List NSGroups  # noqa: E501

        List the NSGroups in a paginated format. The page size is restricted to 50 NSGroups so that the size of the response remains small even in the worst case. Optionally, specify valid member types as request parameter to filter NSGroups.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_ns_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str member_types: Specify member types to filter corresponding NSGroups 
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool populate_references: Populate metadata of resource referenced by NSGroupExpressions 
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NSGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'member_types', 'page_size', 'populate_references', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ns_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'member_types' in params:
            query_params.append(('member_types', params['member_types']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'populate_references' in params:
            query_params.append(('populate_references', params['populate_references']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroupListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ns_group(self, ns_group_id, **kwargs):  # noqa: E501
        """Read NSGroup  # noqa: E501

        Returns information about the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_ns_group(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param bool populate_references: Populate metadata of resource referenced by NSGroupExpressions 
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_ns_group_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ns_group_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def read_ns_group_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Read NSGroup  # noqa: E501

        Returns information about the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_ns_group_with_http_info(ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ns_group_id: NSGroup Id (required)
        :param bool populate_references: Populate metadata of resource referenced by NSGroupExpressions 
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'populate_references']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ns_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `read_ns_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'populate_references' in params:
            query_params.append(('populate_references', params['populate_references']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ns_group(self, body, ns_group_id, **kwargs):  # noqa: E501
        """Update NSGroup  # noqa: E501

        Updates the specified NSGroup. Modifiable parameters include the description, display_name and members. For NSGroups containing VM criteria(both static and dynamic), system VMs will not be included as members. This filter applies at VM level only. Exceptions are as follows. 1. LogicalPorts and VNI of system VMs will be included in NSGroup if the criteria  is based on LogicalPort, LogicalSwitch or VNI directly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ns_group(body, ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NSGroup body: (required)
        :param str ns_group_id: NSGroup Id (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ns_group_with_http_info(body, ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ns_group_with_http_info(body, ns_group_id, **kwargs)  # noqa: E501
            return data

    def update_ns_group_with_http_info(self, body, ns_group_id, **kwargs):  # noqa: E501
        """Update NSGroup  # noqa: E501

        Updates the specified NSGroup. Modifiable parameters include the description, display_name and members. For NSGroups containing VM criteria(both static and dynamic), system VMs will not be included as members. This filter applies at VM level only. Exceptions are as follows. 1. LogicalPorts and VNI of system VMs will be included in NSGroup if the criteria  is based on LogicalPort, LogicalSwitch or VNI directly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ns_group_with_http_info(body, ns_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NSGroup body: (required)
        :param str ns_group_id: NSGroup Id (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ns_group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ns_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_ns_group`")  # noqa: E501
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `update_ns_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
