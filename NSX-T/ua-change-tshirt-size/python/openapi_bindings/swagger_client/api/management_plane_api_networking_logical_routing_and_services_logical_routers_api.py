# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPINetworkingLogicalRoutingAndServicesLogicalRoutersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_logical_router(self, body, **kwargs):  # noqa: E501
        """Create a Logical Router  # noqa: E501

        Creates a logical router. The required parameters are router_type (TIER0 or TIER1) and edge_cluster_id (TIER0 only). Optional parameters include internal and external transit network addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_logical_router(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalRouter body: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_logical_router_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_logical_router_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_logical_router_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Logical Router  # noqa: E501

        Creates a logical router. The required parameters are router_type (TIER0 or TIER1) and edge_cluster_id (TIER0 only). Optional parameters include internal and external transit network addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_logical_router_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalRouter body: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_logical_router(self, logical_router_id, **kwargs):  # noqa: E501
        """Delete a Logical Router  # noqa: E501

        Deletes the specified logical router. You must delete associated logical router ports before you can delete a logical router. Otherwise use force delete which will delete all related ports and other entities associated with that LR. To force delete logical router pass force=true in query param.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_logical_router(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param bool cascade_delete_linked_ports: Flag to specify whether to delete related logical switch ports
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def delete_logical_router_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Delete a Logical Router  # noqa: E501

        Deletes the specified logical router. You must delete associated logical router ports before you can delete a logical router. Otherwise use force delete which will delete all related ports and other entities associated with that LR. To force delete logical router pass force=true in query param.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_logical_router_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param bool cascade_delete_linked_ports: Flag to specify whether to delete related logical switch ports
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cascade_delete_linked_ports', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cascade_delete_linked_ports' in params:
            query_params.append(('cascade_delete_linked_ports', params['cascade_delete_linked_ports']))  # noqa: E501
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bgp_neighbor_advertised_routes(self, logical_router_id, neighbor_id, **kwargs):  # noqa: E501
        """Get BGP neighbor advertised routes  # noqa: E501

        Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbor_advertised_routes(logical_router_id, neighbor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str neighbor_id: (required)
        :return: BgpNeighborRouteDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bgp_neighbor_advertised_routes_with_http_info(logical_router_id, neighbor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bgp_neighbor_advertised_routes_with_http_info(logical_router_id, neighbor_id, **kwargs)  # noqa: E501
            return data

    def get_bgp_neighbor_advertised_routes_with_http_info(self, logical_router_id, neighbor_id, **kwargs):  # noqa: E501
        """Get BGP neighbor advertised routes  # noqa: E501

        Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbor_advertised_routes_with_http_info(logical_router_id, neighbor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str neighbor_id: (required)
        :return: BgpNeighborRouteDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'neighbor_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bgp_neighbor_advertised_routes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_bgp_neighbor_advertised_routes`")  # noqa: E501
        # verify the required parameter 'neighbor_id' is set
        if ('neighbor_id' not in params or
                params['neighbor_id'] is None):
            raise ValueError("Missing the required parameter `neighbor_id` when calling `get_bgp_neighbor_advertised_routes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'neighbor_id' in params:
            path_params['neighbor-id'] = params['neighbor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{neighbor-id}/advertised-routes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighborRouteDetails',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bgp_neighbor_advertised_routes_in_csv_format_csv(self, logical_router_id, neighbor_id, **kwargs):  # noqa: E501
        """Get BGP neighbor advertised routes in CSV format   # noqa: E501

        Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbor_advertised_routes_in_csv_format_csv(logical_router_id, neighbor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str neighbor_id: (required)
        :return: BgpNeighborRouteDetailsInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bgp_neighbor_advertised_routes_in_csv_format_csv_with_http_info(logical_router_id, neighbor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bgp_neighbor_advertised_routes_in_csv_format_csv_with_http_info(logical_router_id, neighbor_id, **kwargs)  # noqa: E501
            return data

    def get_bgp_neighbor_advertised_routes_in_csv_format_csv_with_http_info(self, logical_router_id, neighbor_id, **kwargs):  # noqa: E501
        """Get BGP neighbor advertised routes in CSV format   # noqa: E501

        Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbor_advertised_routes_in_csv_format_csv_with_http_info(logical_router_id, neighbor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str neighbor_id: (required)
        :return: BgpNeighborRouteDetailsInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'neighbor_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bgp_neighbor_advertised_routes_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_bgp_neighbor_advertised_routes_in_csv_format_csv`")  # noqa: E501
        # verify the required parameter 'neighbor_id' is set
        if ('neighbor_id' not in params or
                params['neighbor_id'] is None):
            raise ValueError("Missing the required parameter `neighbor_id` when calling `get_bgp_neighbor_advertised_routes_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'neighbor_id' in params:
            path_params['neighbor-id'] = params['neighbor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{neighbor-id}/advertised-routes?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighborRouteDetailsInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bgp_neighbor_routes(self, logical_router_id, neighbor_id, **kwargs):  # noqa: E501
        """Get BGP neighbor learned routes  # noqa: E501

        Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbor_routes(logical_router_id, neighbor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str neighbor_id: (required)
        :return: BgpNeighborRouteDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bgp_neighbor_routes_with_http_info(logical_router_id, neighbor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bgp_neighbor_routes_with_http_info(logical_router_id, neighbor_id, **kwargs)  # noqa: E501
            return data

    def get_bgp_neighbor_routes_with_http_info(self, logical_router_id, neighbor_id, **kwargs):  # noqa: E501
        """Get BGP neighbor learned routes  # noqa: E501

        Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbor_routes_with_http_info(logical_router_id, neighbor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str neighbor_id: (required)
        :return: BgpNeighborRouteDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'neighbor_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bgp_neighbor_routes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_bgp_neighbor_routes`")  # noqa: E501
        # verify the required parameter 'neighbor_id' is set
        if ('neighbor_id' not in params or
                params['neighbor_id'] is None):
            raise ValueError("Missing the required parameter `neighbor_id` when calling `get_bgp_neighbor_routes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'neighbor_id' in params:
            path_params['neighbor-id'] = params['neighbor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{neighbor-id}/routes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighborRouteDetails',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bgp_neighbor_routes_in_csv_format_csv(self, logical_router_id, neighbor_id, **kwargs):  # noqa: E501
        """Get BGP neighbor learned routes in CSV format   # noqa: E501

        Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbor_routes_in_csv_format_csv(logical_router_id, neighbor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str neighbor_id: (required)
        :return: BgpNeighborRouteDetailsInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bgp_neighbor_routes_in_csv_format_csv_with_http_info(logical_router_id, neighbor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bgp_neighbor_routes_in_csv_format_csv_with_http_info(logical_router_id, neighbor_id, **kwargs)  # noqa: E501
            return data

    def get_bgp_neighbor_routes_in_csv_format_csv_with_http_info(self, logical_router_id, neighbor_id, **kwargs):  # noqa: E501
        """Get BGP neighbor learned routes in CSV format   # noqa: E501

        Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbor_routes_in_csv_format_csv_with_http_info(logical_router_id, neighbor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str neighbor_id: (required)
        :return: BgpNeighborRouteDetailsInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'neighbor_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bgp_neighbor_routes_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_bgp_neighbor_routes_in_csv_format_csv`")  # noqa: E501
        # verify the required parameter 'neighbor_id' is set
        if ('neighbor_id' not in params or
                params['neighbor_id'] is None):
            raise ValueError("Missing the required parameter `neighbor_id` when calling `get_bgp_neighbor_routes_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'neighbor_id' in params:
            path_params['neighbor-id'] = params['neighbor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{neighbor-id}/routes?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighborRouteDetailsInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bgp_neighbors_status(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the status of all the BGP neighbors for the Logical Router of the given id  # noqa: E501

        Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \"transport_node_id=<transportnode_id>\" needs to be specified. Query parameter \"source=realtime\" is the only supported source.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbors_status(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: Transport node id
        :return: BgpNeighborsStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bgp_neighbors_status_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bgp_neighbors_status_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def get_bgp_neighbors_status_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the status of all the BGP neighbors for the Logical Router of the given id  # noqa: E501

        Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \"transport_node_id=<transportnode_id>\" needs to be specified. Query parameter \"source=realtime\" is the only supported source.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bgp_neighbors_status_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: Transport node id
        :return: BgpNeighborsStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bgp_neighbors_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_bgp_neighbors_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighborsStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_forwarding_table(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get FIB table on a specified node for a logical router  # noqa: E501

        Returns the FIB for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_forwarding_table(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str network_prefix: IPv4 or IPv6 CIDR Block
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_forwarding_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_forwarding_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_forwarding_table_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get FIB table on a specified node for a logical router  # noqa: E501

        Returns the FIB for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_forwarding_table_with_http_info(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str network_prefix: IPv4 or IPv6 CIDR Block
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'cursor', 'included_fields', 'network_prefix', 'page_size', 'sort_ascending', 'sort_by', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_forwarding_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_forwarding_table`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_forwarding_table`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'network_prefix' in params:
            query_params.append(('network_prefix', params['network_prefix']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/forwarding-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_forwarding_table_in_csv_format_csv(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get FIB table on a specified node for a logical router  # noqa: E501

        Returns the FIB table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_forwarding_table_in_csv_format_csv(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str network_prefix: IPv4 or IPv6 CIDR Block
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_forwarding_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_forwarding_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_forwarding_table_in_csv_format_csv_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get FIB table on a specified node for a logical router  # noqa: E501

        Returns the FIB table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_forwarding_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str network_prefix: IPv4 or IPv6 CIDR Block
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'network_prefix', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_forwarding_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_forwarding_table_in_csv_format_csv`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_forwarding_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'network_prefix' in params:
            query_params.append(('network_prefix', params['network_prefix']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/forwarding-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTableInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_route_table(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get route table on a given node for a logical router  # noqa: E501

        Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and /logical-routers/<logical-router-id>/routing/forwarding-table for FIB. Returns the route table for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_route_table(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_route_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_route_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_route_table_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get route table on a given node for a logical router  # noqa: E501

        Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and /logical-routers/<logical-router-id>/routing/forwarding-table for FIB. Returns the route table for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_route_table_with_http_info(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_route_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_route_table`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_route_table`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_route_table_in_csv_format_csv(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get route table on a node for a logical router  # noqa: E501

        Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and /logical-routers/<logical-router-id>/routing/forwarding-table for FIB. Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_route_table_in_csv_format_csv(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_route_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_route_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_route_table_in_csv_format_csv_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get route table on a node for a logical router  # noqa: E501

        Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and /logical-routers/<logical-router-id>/routing/forwarding-table for FIB. Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_route_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_route_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_route_table_in_csv_format_csv`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_route_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTableInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_routing_table(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get RIB table on a specified node for a logical router  # noqa: E501

        Returns the route table(RIB) for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, parameter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. To filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_routing_table(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str network_prefix: IPv4 or IPv6 CIDR Block
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str route_source: Route source filter parameter
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str vrf_table: VRF filter parameter
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_routing_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_routing_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_routing_table_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get RIB table on a specified node for a logical router  # noqa: E501

        Returns the route table(RIB) for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, parameter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. To filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_routing_table_with_http_info(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str network_prefix: IPv4 or IPv6 CIDR Block
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str route_source: Route source filter parameter
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str vrf_table: VRF filter parameter
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'cursor', 'included_fields', 'network_prefix', 'page_size', 'route_source', 'sort_ascending', 'sort_by', 'source', 'vrf_table']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_routing_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_routing_table`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_routing_table`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'network_prefix' in params:
            query_params.append(('network_prefix', params['network_prefix']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'route_source' in params:
            query_params.append(('route_source', params['route_source']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501
        if 'vrf_table' in params:
            query_params.append(('vrf_table', params['vrf_table']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/routing-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_routing_table_in_csv_format_csv(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get RIB table on a specified node for a logical router  # noqa: E501

        Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. To filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_routing_table_in_csv_format_csv(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str network_prefix: IPv4 or IPv6 CIDR Block
        :param str route_source: Route source filter parameter
        :param str source: Data source type.
        :param str vrf_table: VRF filter parameter
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_routing_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_routing_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_routing_table_in_csv_format_csv_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get RIB table on a specified node for a logical router  # noqa: E501

        Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. To filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_routing_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str network_prefix: IPv4 or IPv6 CIDR Block
        :param str route_source: Route source filter parameter
        :param str source: Data source type.
        :param str vrf_table: VRF filter parameter
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'network_prefix', 'route_source', 'source', 'vrf_table']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_routing_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_routing_table_in_csv_format_csv`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_routing_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'network_prefix' in params:
            query_params.append(('network_prefix', params['network_prefix']))  # noqa: E501
        if 'route_source' in params:
            query_params.append(('route_source', params['route_source']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501
        if 'vrf_table' in params:
            query_params.append(('vrf_table', params['vrf_table']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/routing-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTableInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_state(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Logical Router  # noqa: E501

        Return realized state information of a logical router. Any configuration update that affects the logical router can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of logical router, static routes, etc.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_state(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: LogicalRouterState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_state_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_state_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_state_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Logical Router  # noqa: E501

        Return realized state information of a logical router. Any configuration update that affects the logical router can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of logical router, static routes, etc.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_state_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: LogicalRouterState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'barrier_id', 'request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501
        if 'request_id' in params:
            query_params.append(('request_id', params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_status(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the status for the Logical Router of the given id  # noqa: E501

        Returns status for the Logical Router of the given id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_status(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str source: Data source type.
        :return: LogicalRouterStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_router_status_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_status_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_status_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the status for the Logical Router of the given id  # noqa: E501

        Returns status for the Logical Router of the given id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_router_status_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str source: Data source type.
        :return: LogicalRouterStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_service_router_cluster_state(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Logical Service Router Cluster  # noqa: E501

        Return realized state information of a logical service router cluster. Any configuration update that affects the logical service router cluster can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of nat, bgp, bfd, etc.  What is a Service Router? When a service cannot be distributed is enabled on a Logical Router, a Service Router (SR) is instantiated. Some examples of services that are not distributed are NAT, DHCP server, Metadata Proxy, Edge Firewall, Load Balancer and so on.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_service_router_cluster_state(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: LogicalServiceRouterClusterState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logical_service_router_cluster_state_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_service_router_cluster_state_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def get_logical_service_router_cluster_state_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Logical Service Router Cluster  # noqa: E501

        Return realized state information of a logical service router cluster. Any configuration update that affects the logical service router cluster can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of nat, bgp, bfd, etc.  What is a Service Router? When a service cannot be distributed is enabled on a Logical Router, a Service Router (SR) is instantiated. Some examples of services that are not distributed are NAT, DHCP server, Metadata Proxy, Edge Firewall, Load Balancer and so on.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logical_service_router_cluster_state_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: LogicalServiceRouterClusterState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'barrier_id', 'request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_service_router_cluster_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_service_router_cluster_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501
        if 'request_id' in params:
            query_params.append(('request_id', params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/service-cluster/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalServiceRouterClusterState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_logical_routers(self, **kwargs):  # noqa: E501
        """List Logical Routers  # noqa: E501

        Returns information about all logical routers, including the UUID, internal and external transit network addresses, and the router type (TIER0 or TIER1). You can get information for only TIER0 routers or only the TIER1 routers by including the router_type query parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_logical_routers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str router_type: Type of Logical Router
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str vrfs_on_logical_router_id: List all VRFs on the specified logical router.
        :return: LogicalRouterListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_logical_routers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_logical_routers_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_logical_routers_with_http_info(self, **kwargs):  # noqa: E501
        """List Logical Routers  # noqa: E501

        Returns information about all logical routers, including the UUID, internal and external transit network addresses, and the router type (TIER0 or TIER1). You can get information for only TIER0 routers or only the TIER1 routers by including the router_type query parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_logical_routers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str router_type: Type of Logical Router
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str vrfs_on_logical_router_id: List all VRFs on the specified logical router.
        :return: LogicalRouterListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'router_type', 'sort_ascending', 'sort_by', 'vrfs_on_logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_logical_routers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'router_type' in params:
            query_params.append(('router_type', params['router_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'vrfs_on_logical_router_id' in params:
            query_params.append(('vrfs_on_logical_router_id', params['vrfs_on_logical_router_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def re_allocate_service_routers_reallocate(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Re allocate edge node placement of TIER1 service routers  # noqa: E501

        API to re allocate edge node placement for TIER1 logical router. You can re-allocate service routers of TIER1 in same edge cluster or different edge cluster. You can also place edge nodes manually and provide maximum two indices for HA mode ACTIVE_STANDBY. To re-allocate on new edge cluster you must have existing edge cluster for TIER1 logical router. This will be disruptive operation and all existing statistics of logical router will be remove.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.re_allocate_service_routers_reallocate(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceRouterAllocationConfig body: (required)
        :param str logical_router_id: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.re_allocate_service_routers_reallocate_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.re_allocate_service_routers_reallocate_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def re_allocate_service_routers_reallocate_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Re allocate edge node placement of TIER1 service routers  # noqa: E501

        API to re allocate edge node placement for TIER1 logical router. You can re-allocate service routers of TIER1 in same edge cluster or different edge cluster. You can also place edge nodes manually and provide maximum two indices for HA mode ACTIVE_STANDBY. To re-allocate on new edge cluster you must have existing edge cluster for TIER1 logical router. This will be disruptive operation and all existing statistics of logical router will be remove.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.re_allocate_service_routers_reallocate_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceRouterAllocationConfig body: (required)
        :param str logical_router_id: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method re_allocate_service_routers_reallocate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `re_allocate_service_routers_reallocate`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `re_allocate_service_routers_reallocate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}?action=reallocate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def re_process_logical_router_reprocess(self, logical_router_id, **kwargs):  # noqa: E501
        """Reprocesses a logical router configuration and publish updates to controller  # noqa: E501

        Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc. Any missing Updates are published to controller.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.re_process_logical_router_reprocess(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.re_process_logical_router_reprocess_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.re_process_logical_router_reprocess_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def re_process_logical_router_reprocess_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Reprocesses a logical router configuration and publish updates to controller  # noqa: E501

        Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc. Any missing Updates are published to controller.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.re_process_logical_router_reprocess_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method re_process_logical_router_reprocess" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `re_process_logical_router_reprocess`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}?action=reprocess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_logical_router(self, logical_router_id, **kwargs):  # noqa: E501
        """Read Logical Router  # noqa: E501

        Returns information about the specified logical router.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_logical_router(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_logical_router_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read Logical Router  # noqa: E501

        Returns information about the specified logical router.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_logical_router_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_logical_router(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update a Logical Router  # noqa: E501

        Modifies the specified logical router. Modifiable attributes include the internal_transit_network, external_transit_networks, and edge_cluster_id (for TIER0 routers).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_logical_router(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalRouter body: (required)
        :param str logical_router_id: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_logical_router_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_logical_router_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def update_logical_router_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update a Logical Router  # noqa: E501

        Modifies the specified logical router. Modifiable attributes include the internal_transit_network, external_transit_networks, and edge_cluster_id (for TIER0 routers).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_logical_router_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogicalRouter body: (required)
        :param str logical_router_id: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_logical_router`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
