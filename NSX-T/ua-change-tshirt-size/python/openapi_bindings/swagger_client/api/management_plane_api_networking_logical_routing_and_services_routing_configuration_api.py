# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPINetworkingLogicalRoutingAndServicesRoutingConfigurationApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_bgp_neighbor(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add a new BGP Neighbor on a Logical Router  # noqa: E501

        Add a new BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_bgp_neighbor(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BgpNeighbor body: (required)
        :param str logical_router_id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_bgp_neighbor_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_bgp_neighbor_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def add_bgp_neighbor_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add a new BGP Neighbor on a Logical Router  # noqa: E501

        Add a new BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_bgp_neighbor_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BgpNeighbor body: (required)
        :param str logical_router_id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_ip_prefix_list(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add IPPrefixList on a Logical Router  # noqa: E501

        Adds a new IPPrefixList on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ip_prefix_list(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IPPrefixList body: (required)
        :param str logical_router_id: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_ip_prefix_list_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_ip_prefix_list_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def add_ip_prefix_list_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add IPPrefixList on a Logical Router  # noqa: E501

        Adds a new IPPrefixList on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ip_prefix_list_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IPPrefixList body: (required)
        :param str logical_router_id: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ip_prefix_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_ip_prefix_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPPrefixList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_route_map(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add RouteMap on a Logical Router  # noqa: E501

        Adds a new RouteMap on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_route_map(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouteMap body: (required)
        :param str logical_router_id: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_route_map_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_route_map_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def add_route_map_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add RouteMap on a Logical Router  # noqa: E501

        Adds a new RouteMap on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_route_map_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouteMap body: (required)
        :param str logical_router_id: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_route_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_route_map`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_route_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouteMap',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_static_route(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add Static Routes on a Logical Router  # noqa: E501

        Adds a new static route on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_static_route(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StaticRoute body: (required)
        :param str logical_router_id: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_static_route_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_static_route_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def add_static_route_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Add Static Routes on a Logical Router  # noqa: E501

        Adds a new static route on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_static_route_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StaticRoute body: (required)
        :param str logical_router_id: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_static_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_static_route`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_static_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticRoute',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bgp_community_list(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Create a new BGP community list on a logical router  # noqa: E501

        Add a new BGP Community List on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bgp_community_list(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BGPCommunityList body: (required)
        :param str logical_router_id: (required)
        :return: BGPCommunityList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_bgp_community_list_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_bgp_community_list_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def create_bgp_community_list_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Create a new BGP community list on a logical router  # noqa: E501

        Add a new BGP Community List on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bgp_community_list_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BGPCommunityList body: (required)
        :param str logical_router_id: (required)
        :return: BGPCommunityList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bgp_community_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_bgp_community_list`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `create_bgp_community_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/community-lists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BGPCommunityList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dad_profile(self, body, **kwargs):  # noqa: E501
        """Create a new DADProfile  # noqa: E501

        Adds a new DADProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dad_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DADProfile body: (required)
        :return: DADProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dad_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dad_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_dad_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new DADProfile  # noqa: E501

        Adds a new DADProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dad_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DADProfile body: (required)
        :return: DADProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dad_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_dad_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/dad-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DADProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ndra_profile(self, body, **kwargs):  # noqa: E501
        """Create a new NDRA Profile  # noqa: E501

        Adds a new NDRAProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ndra_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NDRAProfile body: (required)
        :return: NDRAProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ndra_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ndra_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_ndra_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new NDRA Profile  # noqa: E501

        Adds a new NDRAProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ndra_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NDRAProfile body: (required)
        :return: NDRAProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ndra_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_ndra_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/nd-ra-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NDRAProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_bgp_community_list(self, logical_router_id, community_list_id, **kwargs):  # noqa: E501
        """Delete a specific BGP community list from a logical router  # noqa: E501

        Delete a specific BGP community list from a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_bgp_community_list(logical_router_id, community_list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str community_list_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_bgp_community_list_with_http_info(logical_router_id, community_list_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_bgp_community_list_with_http_info(logical_router_id, community_list_id, **kwargs)  # noqa: E501
            return data

    def delete_bgp_community_list_with_http_info(self, logical_router_id, community_list_id, **kwargs):  # noqa: E501
        """Delete a specific BGP community list from a logical router  # noqa: E501

        Delete a specific BGP community list from a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_bgp_community_list_with_http_info(logical_router_id, community_list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str community_list_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'community_list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_bgp_community_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_bgp_community_list`")  # noqa: E501
        # verify the required parameter 'community_list_id' is set
        if ('community_list_id' not in params or
                params['community_list_id'] is None):
            raise ValueError("Missing the required parameter `community_list_id` when calling `delete_bgp_community_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'community_list_id' in params:
            path_params['community-list-id'] = params['community_list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/community-lists/{community-list-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_bgp_neighbor(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific BGP Neighbor on a Logical Router  # noqa: E501

        Delete a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_bgp_neighbor(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def delete_bgp_neighbor_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific BGP Neighbor on a Logical Router  # noqa: E501

        Delete a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_bgp_neighbor_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dad_profile(self, dad_profile_id, **kwargs):  # noqa: E501
        """Delete DAD Profile  # noqa: E501

        Delete DADProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dad_profile(dad_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dad_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dad_profile_with_http_info(dad_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dad_profile_with_http_info(dad_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_dad_profile_with_http_info(self, dad_profile_id, **kwargs):  # noqa: E501
        """Delete DAD Profile  # noqa: E501

        Delete DADProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dad_profile_with_http_info(dad_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dad_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dad_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dad_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dad_profile_id' is set
        if ('dad_profile_id' not in params or
                params['dad_profile_id'] is None):
            raise ValueError("Missing the required parameter `dad_profile_id` when calling `delete_dad_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dad_profile_id' in params:
            path_params['dad-profile-id'] = params['dad_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/dad-profiles/{dad-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ip_prefix_list(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific IPPrefixList on a Logical Router  # noqa: E501

        Deletes a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ip_prefix_list(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ip_prefix_list_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ip_prefix_list_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def delete_ip_prefix_list_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific IPPrefixList on a Logical Router  # noqa: E501

        Deletes a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ip_prefix_list_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ip_prefix_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_ip_prefix_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ndra_profile(self, nd_ra_profile_id, **kwargs):  # noqa: E501
        """Delete NDRA Profile  # noqa: E501

        Delete NDRAProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ndra_profile(nd_ra_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str nd_ra_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ndra_profile_with_http_info(nd_ra_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ndra_profile_with_http_info(nd_ra_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_ndra_profile_with_http_info(self, nd_ra_profile_id, **kwargs):  # noqa: E501
        """Delete NDRA Profile  # noqa: E501

        Delete NDRAProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ndra_profile_with_http_info(nd_ra_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str nd_ra_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['nd_ra_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ndra_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'nd_ra_profile_id' is set
        if ('nd_ra_profile_id' not in params or
                params['nd_ra_profile_id'] is None):
            raise ValueError("Missing the required parameter `nd_ra_profile_id` when calling `delete_ndra_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'nd_ra_profile_id' in params:
            path_params['nd-ra-profile-id'] = params['nd_ra_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/nd-ra-profiles/{nd-ra-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_route_map(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific RouteMap on a Logical Router  # noqa: E501

        Deletes a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_route_map(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_route_map_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_route_map_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def delete_route_map_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific RouteMap on a Logical Router  # noqa: E501

        Deletes a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_route_map_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_route_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_route_map`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_route_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_static_route(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific Static Route on a Logical Router  # noqa: E501

        Deletes a specific static route on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_static_route(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_static_route_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_static_route_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def delete_static_route_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific Static Route on a Logical Router  # noqa: E501

        Deletes a specific static route on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_static_route_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_static_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_static_route`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_static_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_bgp_community_lists(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated list of BGP community lists on a logical router  # noqa: E501

        Paginated list of BGP Community Lists on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_bgp_community_lists(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BGPCommunityListListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_bgp_community_lists_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_bgp_community_lists_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_bgp_community_lists_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated list of BGP community lists on a logical router  # noqa: E501

        Paginated list of BGP Community Lists on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_bgp_community_lists_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BGPCommunityListListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_bgp_community_lists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_bgp_community_lists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/community-lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BGPCommunityListListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_bgp_neighbors(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated list of BGP Neighbors on a Logical Router  # noqa: E501

        Paginated list of BGP Neighbors on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_bgp_neighbors(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BgpNeighborListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_bgp_neighbors_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_bgp_neighbors_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_bgp_neighbors_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated list of BGP Neighbors on a Logical Router  # noqa: E501

        Paginated list of BGP Neighbors on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_bgp_neighbors_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BgpNeighborListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_bgp_neighbors" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_bgp_neighbors`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighborListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dad_profiles(self, **kwargs):  # noqa: E501
        """Read All IPV6 DADProfiles  # noqa: E501

        Returns all IPv6 DADProfiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dad_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DADProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_dad_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dad_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dad_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Read All IPV6 DADProfiles  # noqa: E501

        Returns all IPv6 DADProfiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dad_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DADProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dad_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/dad-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DADProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ip_prefix_lists(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of IPPrefixLists  # noqa: E501

        Paginated List of IPPrefixLists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_ip_prefix_lists(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IPPrefixListListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_ip_prefix_lists_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_ip_prefix_lists_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_ip_prefix_lists_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of IPPrefixLists  # noqa: E501

        Paginated List of IPPrefixLists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_ip_prefix_lists_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IPPrefixListListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ip_prefix_lists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_ip_prefix_lists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPPrefixListListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ndra_profiles(self, **kwargs):  # noqa: E501
        """Read All IPV6 NDRA Profiles  # noqa: E501

        Returns all IPv6 NDRA Profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_ndra_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NDRAProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_ndra_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ndra_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ndra_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Read All IPV6 NDRA Profiles  # noqa: E501

        Returns all IPv6 NDRA Profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_ndra_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NDRAProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ndra_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/nd-ra-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NDRAProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_route_maps(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of RouteMaps  # noqa: E501

        Paginated List of RouteMaps  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_route_maps(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RouteMapListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_route_maps_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_route_maps_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_route_maps_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of RouteMaps  # noqa: E501

        Paginated List of RouteMaps  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_route_maps_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RouteMapListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_route_maps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_route_maps`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouteMapListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_static_routes(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of Static Routes  # noqa: E501

        Returns information about configured static routes, including the network address and next hops for each static route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_static_routes(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: StaticRouteListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_static_routes_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_static_routes_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_static_routes_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of Static Routes  # noqa: E501

        Returns information about configured static routes, including the network address and next hops for each static route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_static_routes_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: StaticRouteListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_static_routes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_static_routes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticRouteListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_advertise_rule_list(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Advertisement Rules on a Logical Router  # noqa: E501

        Returns the advertisement rule list for the specified TIER1 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_advertise_rule_list(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: AdvertiseRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_advertise_rule_list_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_advertise_rule_list_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_advertise_rule_list_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Advertisement Rules on a Logical Router  # noqa: E501

        Returns the advertisement rule list for the specified TIER1 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_advertise_rule_list_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: AdvertiseRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_advertise_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_advertise_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/advertisement/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertiseRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_advertisement_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Advertisement Configuration on a Logical Router  # noqa: E501

        Returns information about the routes to be advertised by the specified TIER1 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_advertisement_config(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: AdvertisementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_advertisement_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_advertisement_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_advertisement_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Advertisement Configuration on a Logical Router  # noqa: E501

        Returns information about the routes to be advertised by the specified TIER1 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_advertisement_config_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: AdvertisementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_advertisement_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_advertisement_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/advertisement', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertisementConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_bgp_community_list(self, logical_router_id, community_list_id, **kwargs):  # noqa: E501
        """Read a specific BGP community list from a logical router  # noqa: E501

        Read a specific BGP community list from a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_bgp_community_list(logical_router_id, community_list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str community_list_id: (required)
        :return: BGPCommunityList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_bgp_community_list_with_http_info(logical_router_id, community_list_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_bgp_community_list_with_http_info(logical_router_id, community_list_id, **kwargs)  # noqa: E501
            return data

    def read_bgp_community_list_with_http_info(self, logical_router_id, community_list_id, **kwargs):  # noqa: E501
        """Read a specific BGP community list from a logical router  # noqa: E501

        Read a specific BGP community list from a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_bgp_community_list_with_http_info(logical_router_id, community_list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str community_list_id: (required)
        :return: BGPCommunityList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'community_list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_bgp_community_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_bgp_community_list`")  # noqa: E501
        # verify the required parameter 'community_list_id' is set
        if ('community_list_id' not in params or
                params['community_list_id'] is None):
            raise ValueError("Missing the required parameter `community_list_id` when calling `read_bgp_community_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'community_list_id' in params:
            path_params['community-list-id'] = params['community_list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/community-lists/{community-list-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BGPCommunityList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_bgp_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the BGP Configuration on a Logical Router  # noqa: E501

        Returns information about the BGP configuration on a specified logical router. Information includes whether or not the BGP configuration is enabled, the AS number, and whether or not graceful restart is enabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_bgp_config(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: BgpConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_bgp_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_bgp_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_bgp_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the BGP Configuration on a Logical Router  # noqa: E501

        Returns information about the BGP configuration on a specified logical router. Information includes whether or not the BGP configuration is enabled, the AS number, and whether or not graceful restart is enabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_bgp_config_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: BgpConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_bgp_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_bgp_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_bgp_neighbor(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Read a specific BGP Neighbor on a Logical Router  # noqa: E501

        Read a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_bgp_neighbor(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_bgp_neighbor_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Read a specific BGP Neighbor on a Logical Router  # noqa: E501

        Read a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_bgp_neighbor_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_bgp_neighbor_with_password_show_sensitive_data(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Read a specific BGP Neighbor with password on a Logical Router  # noqa: E501

        Read a specific BGP Neighbor details with password on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_bgp_neighbor_with_password_show_sensitive_data(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_bgp_neighbor_with_password_show_sensitive_data_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_bgp_neighbor_with_password_show_sensitive_data_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_bgp_neighbor_with_password_show_sensitive_data_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Read a specific BGP Neighbor with password on a Logical Router  # noqa: E501

        Read a specific BGP Neighbor details with password on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_bgp_neighbor_with_password_show_sensitive_data_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_bgp_neighbor_with_password_show_sensitive_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_bgp_neighbor_with_password_show_sensitive_data`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_bgp_neighbor_with_password_show_sensitive_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}?action=show-sensitive-data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dad_profile(self, dad_profile_id, **kwargs):  # noqa: E501
        """Read specified IPV6 DADProfile  # noqa: E501

        Returns information about specified IPv6 DADProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dad_profile(dad_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dad_profile_id: (required)
        :return: DADProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_dad_profile_with_http_info(dad_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dad_profile_with_http_info(dad_profile_id, **kwargs)  # noqa: E501
            return data

    def read_dad_profile_with_http_info(self, dad_profile_id, **kwargs):  # noqa: E501
        """Read specified IPV6 DADProfile  # noqa: E501

        Returns information about specified IPv6 DADProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_dad_profile_with_http_info(dad_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str dad_profile_id: (required)
        :return: DADProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dad_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dad_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dad_profile_id' is set
        if ('dad_profile_id' not in params or
                params['dad_profile_id'] is None):
            raise ValueError("Missing the required parameter `dad_profile_id` when calling `read_dad_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dad_profile_id' in params:
            path_params['dad-profile-id'] = params['dad_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/dad-profiles/{dad-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DADProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_debug_info_text(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the debug information for the logical router  # noqa: E501

        API to download below information as text which will be used for debugging and troubleshooting. 1) Logical router sub-components and ports. 2) Routing configuration as sent to central control plane. 3) TIER1 advertised network information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_debug_info_text(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_debug_info_text_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_debug_info_text_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_debug_info_text_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the debug information for the logical router  # noqa: E501

        API to download below information as text which will be used for debugging and troubleshooting. 1) Logical router sub-components and ports. 2) Routing configuration as sent to central control plane. 3) TIER1 advertised network information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_debug_info_text_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_debug_info_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_debug_info_text`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/debug-info?format=text', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ip_prefix_list(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific IPPrefixList on a Logical Router  # noqa: E501

        Read a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_ip_prefix_list(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_ip_prefix_list_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ip_prefix_list_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_ip_prefix_list_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific IPPrefixList on a Logical Router  # noqa: E501

        Read a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_ip_prefix_list_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ip_prefix_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_ip_prefix_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPPrefixList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ndra_profile(self, nd_ra_profile_id, **kwargs):  # noqa: E501
        """Read specified IPV6 NDRA Profile  # noqa: E501

        Returns information about specified IPv6 NDRA Profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_ndra_profile(nd_ra_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str nd_ra_profile_id: (required)
        :return: NDRAProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_ndra_profile_with_http_info(nd_ra_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ndra_profile_with_http_info(nd_ra_profile_id, **kwargs)  # noqa: E501
            return data

    def read_ndra_profile_with_http_info(self, nd_ra_profile_id, **kwargs):  # noqa: E501
        """Read specified IPV6 NDRA Profile  # noqa: E501

        Returns information about specified IPv6 NDRA Profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_ndra_profile_with_http_info(nd_ra_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str nd_ra_profile_id: (required)
        :return: NDRAProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['nd_ra_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ndra_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'nd_ra_profile_id' is set
        if ('nd_ra_profile_id' not in params or
                params['nd_ra_profile_id'] is None):
            raise ValueError("Missing the required parameter `nd_ra_profile_id` when calling `read_ndra_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'nd_ra_profile_id' in params:
            path_params['nd-ra-profile-id'] = params['nd_ra_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/nd-ra-profiles/{nd-ra-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NDRAProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_redistribution_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Redistribution Configuration on a Logical Router  # noqa: E501

        Returns information about configured route redistribution for the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_redistribution_config(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: RedistributionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_redistribution_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_redistribution_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_redistribution_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Redistribution Configuration on a Logical Router  # noqa: E501

        Returns information about configured route redistribution for the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_redistribution_config_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: RedistributionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_redistribution_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_redistribution_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/redistribution', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RedistributionConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_redistribution_rule_list(self, logical_router_id, **kwargs):  # noqa: E501
        """Read All the Redistribution Rules on a Logical Router  # noqa: E501

        Returns all the route redistribution rules for the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_redistribution_rule_list(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: RedistributionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_redistribution_rule_list_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_redistribution_rule_list_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_redistribution_rule_list_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read All the Redistribution Rules on a Logical Router  # noqa: E501

        Returns all the route redistribution rules for the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_redistribution_rule_list_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: RedistributionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_redistribution_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_redistribution_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/redistribution/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RedistributionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_route_map(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific RouteMap on a Logical Router  # noqa: E501

        Read a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_route_map(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_route_map_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_route_map_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_route_map_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific RouteMap on a Logical Router  # noqa: E501

        Read a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_route_map_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_route_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_route_map`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_route_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouteMap',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_routing_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Routing Configuration  # noqa: E501

        Returns the routing configuration for a specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_routing_config(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: RoutingConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_routing_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_routing_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_routing_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Routing Configuration  # noqa: E501

        Returns the routing configuration for a specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_routing_config_with_http_info(logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :return: RoutingConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_routing_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_routing_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoutingConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_static_route(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific Static Route on a Logical Router  # noqa: E501

        Read a specific static routes on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_static_route(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_static_route_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_static_route_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_static_route_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific Static Route on a Logical Router  # noqa: E501

        Read a specific static routes on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_static_route_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_static_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_static_route`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_static_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticRoute',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def un_set_password_on_bgp_neighbor(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Unset/Delete password property on specific BGP Neighbor on Logical Router  # noqa: E501

        Unset/Delete the password property on the specific BGP Neighbor. No other property of the BgpNeighbor can be updated using this API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.un_set_password_on_bgp_neighbor(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param str action:
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.un_set_password_on_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.un_set_password_on_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def un_set_password_on_bgp_neighbor_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Unset/Delete password property on specific BGP Neighbor on Logical Router  # noqa: E501

        Unset/Delete the password property on the specific BGP Neighbor. No other property of the BgpNeighbor can be updated using this API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.un_set_password_on_bgp_neighbor_with_http_info(logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param str action:
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method un_set_password_on_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `un_set_password_on_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `un_set_password_on_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_advertise_rule_list(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the Advertisement Rules on a Logical Router  # noqa: E501

        Modifies the advertisement rules on the specified logical router. The PUT request must include all the rules with the networks parameter. Modifiable parameters are networks, display_name, and description. Set the rules list to empty to delete/clear all rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_advertise_rule_list(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdvertiseRuleList body: (required)
        :param str logical_router_id: (required)
        :return: AdvertiseRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_advertise_rule_list_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_advertise_rule_list_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def update_advertise_rule_list_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the Advertisement Rules on a Logical Router  # noqa: E501

        Modifies the advertisement rules on the specified logical router. The PUT request must include all the rules with the networks parameter. Modifiable parameters are networks, display_name, and description. Set the rules list to empty to delete/clear all rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_advertise_rule_list_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdvertiseRuleList body: (required)
        :param str logical_router_id: (required)
        :return: AdvertiseRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_advertise_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_advertise_rule_list`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_advertise_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/advertisement/rules', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertiseRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_advertisement_config(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the Advertisement Configuration on a Logical Router  # noqa: E501

        Modifies the route advertisement configuration on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_advertisement_config(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdvertisementConfig body: (required)
        :param str logical_router_id: (required)
        :return: AdvertisementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_advertisement_config_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_advertisement_config_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def update_advertisement_config_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the Advertisement Configuration on a Logical Router  # noqa: E501

        Modifies the route advertisement configuration on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_advertisement_config_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdvertisementConfig body: (required)
        :param str logical_router_id: (required)
        :return: AdvertisementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_advertisement_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_advertisement_config`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_advertisement_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/advertisement', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertisementConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bgp_community_list(self, body, logical_router_id, community_list_id, **kwargs):  # noqa: E501
        """Update a specific BGP community list from a logical router  # noqa: E501

        Update a specific BGP community list from a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bgp_community_list(body, logical_router_id, community_list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BGPCommunityList body: (required)
        :param str logical_router_id: (required)
        :param str community_list_id: (required)
        :return: BGPCommunityList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_bgp_community_list_with_http_info(body, logical_router_id, community_list_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bgp_community_list_with_http_info(body, logical_router_id, community_list_id, **kwargs)  # noqa: E501
            return data

    def update_bgp_community_list_with_http_info(self, body, logical_router_id, community_list_id, **kwargs):  # noqa: E501
        """Update a specific BGP community list from a logical router  # noqa: E501

        Update a specific BGP community list from a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bgp_community_list_with_http_info(body, logical_router_id, community_list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BGPCommunityList body: (required)
        :param str logical_router_id: (required)
        :param str community_list_id: (required)
        :return: BGPCommunityList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id', 'community_list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bgp_community_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_bgp_community_list`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_bgp_community_list`")  # noqa: E501
        # verify the required parameter 'community_list_id' is set
        if ('community_list_id' not in params or
                params['community_list_id'] is None):
            raise ValueError("Missing the required parameter `community_list_id` when calling `update_bgp_community_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'community_list_id' in params:
            path_params['community-list-id'] = params['community_list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/community-lists/{community-list-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BGPCommunityList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bgp_community_list_old(self, body, logical_router_id, community_list_id, **kwargs):  # noqa: E501
        """Update a specific BGP community list from a logical router  # noqa: E501

        Update a specific BGP community list from a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bgp_community_list_old(body, logical_router_id, community_list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BGPCommunityList body: (required)
        :param str logical_router_id: (required)
        :param str community_list_id: (required)
        :return: BGPCommunityList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_bgp_community_list_old_with_http_info(body, logical_router_id, community_list_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bgp_community_list_old_with_http_info(body, logical_router_id, community_list_id, **kwargs)  # noqa: E501
            return data

    def update_bgp_community_list_old_with_http_info(self, body, logical_router_id, community_list_id, **kwargs):  # noqa: E501
        """Update a specific BGP community list from a logical router  # noqa: E501

        Update a specific BGP community list from a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bgp_community_list_old_with_http_info(body, logical_router_id, community_list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BGPCommunityList body: (required)
        :param str logical_router_id: (required)
        :param str community_list_id: (required)
        :return: BGPCommunityList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id', 'community_list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bgp_community_list_old" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_bgp_community_list_old`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_bgp_community_list_old`")  # noqa: E501
        # verify the required parameter 'community_list_id' is set
        if ('community_list_id' not in params or
                params['community_list_id'] is None):
            raise ValueError("Missing the required parameter `community_list_id` when calling `update_bgp_community_list_old`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'community_list_id' in params:
            path_params['community-list-id'] = params['community_list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/communty-lists/{community-list-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BGPCommunityList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bgp_config(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the BGP Configuration on a Logical Router  # noqa: E501

        Modifies the BGP configuration on a specified TIER0 logical router. Modifiable parameters include enabled, graceful_restart, as_number.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bgp_config(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BgpConfig body: (required)
        :param str logical_router_id: (required)
        :return: BgpConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_bgp_config_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bgp_config_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def update_bgp_config_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the BGP Configuration on a Logical Router  # noqa: E501

        Modifies the BGP configuration on a specified TIER0 logical router. Modifiable parameters include enabled, graceful_restart, as_number.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bgp_config_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BgpConfig body: (required)
        :param str logical_router_id: (required)
        :return: BgpConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bgp_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_bgp_config`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_bgp_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bgp_neighbor(self, body, logical_router_id, id, **kwargs):  # noqa: E501
        """Update a specific BGP Neighbor on a Logical Router  # noqa: E501

        Update a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bgp_neighbor(body, logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BgpNeighbor body: (required)
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_bgp_neighbor_with_http_info(body, logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bgp_neighbor_with_http_info(body, logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def update_bgp_neighbor_with_http_info(self, body, logical_router_id, id, **kwargs):  # noqa: E501
        """Update a specific BGP Neighbor on a Logical Router  # noqa: E501

        Update a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bgp_neighbor_with_http_info(body, logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BgpNeighbor body: (required)
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dad_profile(self, body, dad_profile_id, **kwargs):  # noqa: E501
        """Update DADProfile  # noqa: E501

        Update DADProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dad_profile(body, dad_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DADProfile body: (required)
        :param str dad_profile_id: (required)
        :return: DADProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dad_profile_with_http_info(body, dad_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dad_profile_with_http_info(body, dad_profile_id, **kwargs)  # noqa: E501
            return data

    def update_dad_profile_with_http_info(self, body, dad_profile_id, **kwargs):  # noqa: E501
        """Update DADProfile  # noqa: E501

        Update DADProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dad_profile_with_http_info(body, dad_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DADProfile body: (required)
        :param str dad_profile_id: (required)
        :return: DADProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'dad_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dad_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dad_profile`")  # noqa: E501
        # verify the required parameter 'dad_profile_id' is set
        if ('dad_profile_id' not in params or
                params['dad_profile_id'] is None):
            raise ValueError("Missing the required parameter `dad_profile_id` when calling `update_dad_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dad_profile_id' in params:
            path_params['dad-profile-id'] = params['dad_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/dad-profiles/{dad-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DADProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ip_prefix_list(self, body, logical_router_id, id, **kwargs):  # noqa: E501
        """Update a specific IPPrefixList on a Logical Router  # noqa: E501

        Update a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ip_prefix_list(body, logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IPPrefixList body: (required)
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ip_prefix_list_with_http_info(body, logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ip_prefix_list_with_http_info(body, logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def update_ip_prefix_list_with_http_info(self, body, logical_router_id, id, **kwargs):  # noqa: E501
        """Update a specific IPPrefixList on a Logical Router  # noqa: E501

        Update a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ip_prefix_list_with_http_info(body, logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IPPrefixList body: (required)
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ip_prefix_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_ip_prefix_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPPrefixList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ndra_profile(self, body, nd_ra_profile_id, **kwargs):  # noqa: E501
        """Update NDRA Profile  # noqa: E501

        Update NDRAProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ndra_profile(body, nd_ra_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NDRAProfile body: (required)
        :param str nd_ra_profile_id: (required)
        :return: NDRAProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ndra_profile_with_http_info(body, nd_ra_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ndra_profile_with_http_info(body, nd_ra_profile_id, **kwargs)  # noqa: E501
            return data

    def update_ndra_profile_with_http_info(self, body, nd_ra_profile_id, **kwargs):  # noqa: E501
        """Update NDRA Profile  # noqa: E501

        Update NDRAProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ndra_profile_with_http_info(body, nd_ra_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NDRAProfile body: (required)
        :param str nd_ra_profile_id: (required)
        :return: NDRAProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'nd_ra_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ndra_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_ndra_profile`")  # noqa: E501
        # verify the required parameter 'nd_ra_profile_id' is set
        if ('nd_ra_profile_id' not in params or
                params['nd_ra_profile_id'] is None):
            raise ValueError("Missing the required parameter `nd_ra_profile_id` when calling `update_ndra_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'nd_ra_profile_id' in params:
            path_params['nd-ra-profile-id'] = params['nd_ra_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipv6/nd-ra-profiles/{nd-ra-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NDRAProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_redistribution_config(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the Redistribution Configuration on a Logical Router  # noqa: E501

        Modifies existing route redistribution rules for the specified TIER0 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_redistribution_config(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RedistributionConfig body: (required)
        :param str logical_router_id: (required)
        :return: RedistributionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_redistribution_config_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_redistribution_config_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def update_redistribution_config_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the Redistribution Configuration on a Logical Router  # noqa: E501

        Modifies existing route redistribution rules for the specified TIER0 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_redistribution_config_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RedistributionConfig body: (required)
        :param str logical_router_id: (required)
        :return: RedistributionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_redistribution_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_redistribution_config`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_redistribution_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/redistribution', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RedistributionConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_redistribution_rule_list(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update All the Redistribution Rules on a Logical Router  # noqa: E501

        Modifies all route redistribution rules for the specified TIER0 logical router. Set the rules list to empty to delete/clear all rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_redistribution_rule_list(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RedistributionRuleList body: (required)
        :param str logical_router_id: (required)
        :return: RedistributionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_redistribution_rule_list_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_redistribution_rule_list_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def update_redistribution_rule_list_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update All the Redistribution Rules on a Logical Router  # noqa: E501

        Modifies all route redistribution rules for the specified TIER0 logical router. Set the rules list to empty to delete/clear all rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_redistribution_rule_list_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RedistributionRuleList body: (required)
        :param str logical_router_id: (required)
        :return: RedistributionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_redistribution_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_redistribution_rule_list`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_redistribution_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/redistribution/rules', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RedistributionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_route_map(self, body, logical_router_id, id, **kwargs):  # noqa: E501
        """Update a specific RouteMap on a Logical Router  # noqa: E501

        Update a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_route_map(body, logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouteMap body: (required)
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_route_map_with_http_info(body, logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_route_map_with_http_info(body, logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def update_route_map_with_http_info(self, body, logical_router_id, id, **kwargs):  # noqa: E501
        """Update a specific RouteMap on a Logical Router  # noqa: E501

        Update a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_route_map_with_http_info(body, logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouteMap body: (required)
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_route_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_route_map`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_route_map`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_route_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouteMap',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_routing_config(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the Routing Configuration  # noqa: E501

        Modifies the routing configuration for a specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_routing_config(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RoutingConfig body: (required)
        :param str logical_router_id: (required)
        :return: RoutingConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_routing_config_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_routing_config_with_http_info(body, logical_router_id, **kwargs)  # noqa: E501
            return data

    def update_routing_config_with_http_info(self, body, logical_router_id, **kwargs):  # noqa: E501
        """Update the Routing Configuration  # noqa: E501

        Modifies the routing configuration for a specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_routing_config_with_http_info(body, logical_router_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RoutingConfig body: (required)
        :param str logical_router_id: (required)
        :return: RoutingConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_routing_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_routing_config`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_routing_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoutingConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_static_route(self, body, logical_router_id, id, **kwargs):  # noqa: E501
        """Update a specific Static Route Rule on a Logical Router  # noqa: E501

        Update a specific static route on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_static_route(body, logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StaticRoute body: (required)
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_static_route_with_http_info(body, logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_static_route_with_http_info(body, logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def update_static_route_with_http_info(self, body, logical_router_id, id, **kwargs):  # noqa: E501
        """Update a specific Static Route Rule on a Logical Router  # noqa: E501

        Update a specific static route on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_static_route_with_http_info(body, logical_router_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StaticRoute body: (required)
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'logical_router_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_static_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_static_route`")  # noqa: E501
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_static_route`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_static_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticRoute',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
