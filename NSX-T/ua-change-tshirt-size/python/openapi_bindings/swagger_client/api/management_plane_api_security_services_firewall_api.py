# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneAPISecurityServicesFirewallApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_member_add_member(self, body, **kwargs):  # noqa: E501
        """Add a new object in the exclude list  # noqa: E501

        Add a new object in the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_member_add_member(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ResourceReference body: (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_member_add_member_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_member_add_member_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_member_add_member_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add a new object in the exclude list  # noqa: E501

        Add a new object in the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_member_add_member_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ResourceReference body: (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_member_add_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_member_add_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist?action=add_member', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceReference',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_rule_in_section(self, body, section_id, **kwargs):  # noqa: E501
        """Add a Single Rule in a Section  # noqa: E501

        Adds a new firewall rule in existing firewall section. Adding firewall rule to a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale content to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_rule_in_section(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallRule body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_rule_in_section_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_rule_in_section_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def add_rule_in_section_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Add a Single Rule in a Section  # noqa: E501

        Adds a new firewall rule in existing firewall section. Adding firewall rule to a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale content to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_rule_in_section_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallRule body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_rule_in_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_rule_in_section`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `add_rule_in_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_rules_in_section_create_multiple(self, body, section_id, **kwargs):  # noqa: E501
        """Add Multiple Rules in a Section  # noqa: E501

        Create multiple firewall rules in existing firewall section bounded by limit of 1000 firewall rules per section. Adding multiple firewall rules in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_rules_in_section_create_multiple(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallRuleList body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_rules_in_section_create_multiple_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_rules_in_section_create_multiple_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def add_rules_in_section_create_multiple_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Add Multiple Rules in a Section  # noqa: E501

        Create multiple firewall rules in existing firewall section bounded by limit of 1000 firewall rules per section. Adding multiple firewall rules in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_rules_in_section_create_multiple_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallRuleList body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_rules_in_section_create_multiple" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_rules_in_section_create_multiple`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `add_rules_in_section_create_multiple`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules?action=create_multiple', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_section(self, body, **kwargs):  # noqa: E501
        """Create a New Empty Section  # noqa: E501

        Creates new empty firewall section in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_section(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSection body: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_section_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_section_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_section_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a New Empty Section  # noqa: E501

        Creates new empty firewall section in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_section_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSection body: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_section_with_rules_create_with_rules(self, body, **kwargs):  # noqa: E501
        """Create a Section with Rules  # noqa: E501

        Creates a new firewall section with rules. The limit on the number of rules is defined by maxItems in collection types for FirewallRule (FirewallRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number of rule references is not supported.  Instead, to create sections, use: POST /api/v1/firewall/sections  To create rules, use: POST /api/v1/firewall/sections/&lt;section-id&gt;/rules   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_section_with_rules_create_with_rules(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionRuleList body: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_section_with_rules_create_with_rules_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_section_with_rules_create_with_rules_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_section_with_rules_create_with_rules_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Section with Rules  # noqa: E501

        Creates a new firewall section with rules. The limit on the number of rules is defined by maxItems in collection types for FirewallRule (FirewallRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number of rule references is not supported.  Instead, to create sections, use: POST /api/v1/firewall/sections  To create rules, use: POST /api/v1/firewall/sections/&lt;section-id&gt;/rules   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_section_with_rules_create_with_rules_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionRuleList body: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_section_with_rules_create_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_section_with_rules_create_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections?action=create_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_member_if_exists_check_if_exists(self, object_id, **kwargs):  # noqa: E501
        """Check if the object a member of the exclude list  # noqa: E501

        Check if the object a member of the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_member_if_exists_check_if_exists(object_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: identifier of the object (required)
        :param bool deep_check: Check all parents
        :param str object_type: Object type of an entity
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.check_member_if_exists_check_if_exists_with_http_info(object_id, **kwargs)  # noqa: E501
        else:
            (data) = self.check_member_if_exists_check_if_exists_with_http_info(object_id, **kwargs)  # noqa: E501
            return data

    def check_member_if_exists_check_if_exists_with_http_info(self, object_id, **kwargs):  # noqa: E501
        """Check if the object a member of the exclude list  # noqa: E501

        Check if the object a member of the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_member_if_exists_check_if_exists_with_http_info(object_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: identifier of the object (required)
        :param bool deep_check: Check all parents
        :param str object_type: Object type of an entity
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'deep_check', 'object_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_member_if_exists_check_if_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params or
                params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `check_member_if_exists_check_if_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'deep_check' in params:
            query_params.append(('deep_check', params['deep_check']))  # noqa: E501
        if 'object_id' in params:
            query_params.append(('object_id', params['object_id']))  # noqa: E501
        if 'object_type' in params:
            query_params.append(('object_type', params['object_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist?action=check_if_exists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceReference',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_firewall_profile(self, body, **kwargs):  # noqa: E501
        """Create a firewall profile.  # noqa: E501

        Create a firewall profile with values provided. It creates profile based resource_type in the payload.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_firewall_profile(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseFirewallProfile body: (required)
        :return: BaseFirewallProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_firewall_profile_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_firewall_profile_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_firewall_profile_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a firewall profile.  # noqa: E501

        Create a firewall profile with values provided. It creates profile based resource_type in the payload.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_firewall_profile_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseFirewallProfile body: (required)
        :return: BaseFirewallProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_firewall_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_firewall_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseFirewallProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_firewall_profile(self, profile_id, **kwargs):  # noqa: E501
        """Delete a firewall profile.  # noqa: E501

        Deletes a firewall profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_firewall_profile(profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_firewall_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_firewall_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
            return data

    def delete_firewall_profile_with_http_info(self, profile_id, **kwargs):  # noqa: E501
        """Delete a firewall profile.  # noqa: E501

        Deletes a firewall profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_firewall_profile_with_http_info(profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_firewall_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `delete_firewall_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/profiles/{profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_rule(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Delete an Existing Rule  # noqa: E501

        Delete existing firewall rule in a firewall section. Deleting firewall rule in a section modifies parent section and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_rule(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def delete_rule_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Delete an Existing Rule  # noqa: E501

        Delete existing firewall rule in a firewall section. Deleting firewall rule in a section modifies parent section and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_rule_with_http_info(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `delete_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_section(self, section_id, **kwargs):  # noqa: E501
        """Delete an Existing Section and Its Associated Rules  # noqa: E501

        Removes firewall section from the system. Firewall section with rules can only be deleted by passing \"cascade=true\" parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_section(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param bool cascade: Flag to cascade delete of this object to all it's child objects.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_section_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_section_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def delete_section_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Delete an Existing Section and Its Associated Rules  # noqa: E501

        Removes firewall section from the system. Firewall section with rules can only be deleted by passing \"cascade=true\" parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_section_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param bool cascade: Flag to cascade delete of this object to all it's child objects.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'cascade']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `delete_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_firewall_on_target_resource_disable_firewall(self, context_type, id, **kwargs):  # noqa: E501
        """Disable firewall on target resource in dfw context  # noqa: E501

        Disable firewall on target resource in dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_firewall_on_target_resource_disable_firewall(context_type, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :param str id: (required)
        :return: TargetResourceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_firewall_on_target_resource_disable_firewall_with_http_info(context_type, id, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_firewall_on_target_resource_disable_firewall_with_http_info(context_type, id, **kwargs)  # noqa: E501
            return data

    def disable_firewall_on_target_resource_disable_firewall_with_http_info(self, context_type, id, **kwargs):  # noqa: E501
        """Disable firewall on target resource in dfw context  # noqa: E501

        Disable firewall on target resource in dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_firewall_on_target_resource_disable_firewall_with_http_info(context_type, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :param str id: (required)
        :return: TargetResourceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['context_type', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_firewall_on_target_resource_disable_firewall" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `disable_firewall_on_target_resource_disable_firewall`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `disable_firewall_on_target_resource_disable_firewall`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status/{context-type}/{id}?action=disable_firewall', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TargetResourceStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_firewall_on_target_resource_enable_firewall(self, context_type, id, **kwargs):  # noqa: E501
        """Enable firewall on target resource in dfw context  # noqa: E501

        Enable firewall on target resource in dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_firewall_on_target_resource_enable_firewall(context_type, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :param str id: (required)
        :return: TargetResourceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_firewall_on_target_resource_enable_firewall_with_http_info(context_type, id, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_firewall_on_target_resource_enable_firewall_with_http_info(context_type, id, **kwargs)  # noqa: E501
            return data

    def enable_firewall_on_target_resource_enable_firewall_with_http_info(self, context_type, id, **kwargs):  # noqa: E501
        """Enable firewall on target resource in dfw context  # noqa: E501

        Enable firewall on target resource in dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_firewall_on_target_resource_enable_firewall_with_http_info(context_type, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :param str id: (required)
        :return: TargetResourceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['context_type', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_firewall_on_target_resource_enable_firewall" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `enable_firewall_on_target_resource_enable_firewall`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `enable_firewall_on_target_resource_enable_firewall`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status/{context-type}/{id}?action=enable_firewall', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TargetResourceStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_exclude_list(self, **kwargs):  # noqa: E501
        """Get list of entities in exclude list  # noqa: E501

        Get list of entities in exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_exclude_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_exclude_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_exclude_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_exclude_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of entities in exclude list  # noqa: E501

        Get list of entities in exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_exclude_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_exclude_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExcludeList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_profile(self, profile_id, **kwargs):  # noqa: E501
        """Get all firewall session timer profiles.  # noqa: E501

        Return firewall session timer profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_profile(profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str profile_id: (required)
        :return: BaseFirewallProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_firewall_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
            return data

    def get_firewall_profile_with_http_info(self, profile_id, **kwargs):  # noqa: E501
        """Get all firewall session timer profiles.  # noqa: E501

        Return firewall session timer profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_profile_with_http_info(profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str profile_id: (required)
        :return: BaseFirewallProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `get_firewall_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/profiles/{profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseFirewallProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_section_stats(self, section_id, **kwargs):  # noqa: E501
        """Get Firewall section level statistics section  # noqa: E501

        Get aggregated statistics for all rules for a given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes, sessions counters and popularity index for a firewall rule and overall session count, max session count and max popularity index for all firewall rules on transport nodes or edge nodes. Aggregated statistics like maximum popularity index, maximum session count and total session count are computed with lower frequency compared to individual generic rule statistics, hence they may have a computation delay up to 15 minutes to reflect in response to this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_section_stats(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str source: Data source type.
        :return: FirewallStatsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_firewall_section_stats_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_section_stats_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_firewall_section_stats_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get Firewall section level statistics section  # noqa: E501

        Get aggregated statistics for all rules for a given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes, sessions counters and popularity index for a firewall rule and overall session count, max session count and max popularity index for all firewall rules on transport nodes or edge nodes. Aggregated statistics like maximum popularity index, maximum session count and total session count are computed with lower frequency compared to individual generic rule statistics, hence they may have a computation delay up to 15 minutes to reflect in response to this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_section_stats_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str source: Data source type.
        :return: FirewallStatsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_section_stats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_firewall_section_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStatsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_stats(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get Firewall rule level statistics  # noqa: E501

        Get aggregated statistics for a rule for given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes, sessions counters and popularity index for a firewall rule and overall session count, max session count and max popularity index for all firewall rules on transport nodes or edge nodes. Aggregated statistics like maximum popularity index, maximum session count and total session count are computed with lower frequency compared to individual generic rule statistics, hence they may have a computation delay up to 15 minutes to reflect in response to this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_stats(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: FirewallStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_firewall_stats_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_stats_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_firewall_stats_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get Firewall rule level statistics  # noqa: E501

        Get aggregated statistics for a rule for given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes, sessions counters and popularity index for a firewall rule and overall session count, max session count and max popularity index for all firewall rules on transport nodes or edge nodes. Aggregated statistics like maximum popularity index, maximum session count and total session count are computed with lower frequency compared to individual generic rule statistics, hence they may have a computation delay up to 15 minutes to reflect in response to this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_stats_with_http_info(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: FirewallStats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_stats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_firewall_stats`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_firewall_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStats',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_status(self, context_type, **kwargs):  # noqa: E501
        """Get firewall global status for dfw context  # noqa: E501

        Get firewall global status for dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_status(context_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :return: FirewallStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_firewall_status_with_http_info(context_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_status_with_http_info(context_type, **kwargs)  # noqa: E501
            return data

    def get_firewall_status_with_http_info(self, context_type, **kwargs):  # noqa: E501
        """Get firewall global status for dfw context  # noqa: E501

        Get firewall global status for dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_status_with_http_info(context_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :return: FirewallStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['context_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `get_firewall_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status/{context-type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_status_on_target_resource(self, context_type, id, **kwargs):  # noqa: E501
        """Get firewall status for target resource in dfw context  # noqa: E501

        Get firewall status for target resource in dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_status_on_target_resource(context_type, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :param str id: (required)
        :return: TargetResourceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_firewall_status_on_target_resource_with_http_info(context_type, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_status_on_target_resource_with_http_info(context_type, id, **kwargs)  # noqa: E501
            return data

    def get_firewall_status_on_target_resource_with_http_info(self, context_type, id, **kwargs):  # noqa: E501
        """Get firewall status for target resource in dfw context  # noqa: E501

        Get firewall status for target resource in dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firewall_status_on_target_resource_with_http_info(context_type, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str context_type: (required)
        :param str id: (required)
        :return: TargetResourceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['context_type', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_status_on_target_resource" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `get_firewall_status_on_target_resource`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_firewall_status_on_target_resource`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status/{context-type}/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TargetResourceStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Read an Existing Rule  # noqa: E501

        Return existing firewall rule information in a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_rule_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Read an Existing Rule  # noqa: E501

        Return existing firewall rule information in a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_with_http_info(section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule_state(self, rule_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Firewall Rule  # noqa: E501

        Return realized state information of a firewall rule. Returned response is same as rule's section realization state response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_state(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: RuleState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rule_state_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_state_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def get_rule_state_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Firewall Rule  # noqa: E501

        Return realized state information of a firewall rule. Returned response is same as rule's section realization state response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_state_with_http_info(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: RuleState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id', 'barrier_id', 'request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_rule_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501
        if 'request_id' in params:
            query_params.append(('request_id', params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/rules/{rule-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rules(self, section_id, **kwargs):  # noqa: E501
        """Get All the Rules for a Section  # noqa: E501

        Return all firewall rule(s) information for a given firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rules(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str applied_tos: AppliedTo's referenced by this section or section's Distributed Service Rules .
        :param str context_profiles: Limits results to sections having rules with specific Context Profiles.
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool deep_search: Toggle to search with direct or indirect references.
        :param str destinations: Destinations referenced by this section's Distributed Service Rules .
        :param str extended_sources: Limits results to sections having rules with specific Extended Sources.
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool search_invalid_references: Return invalid references in results.
        :param str services: NSService referenced by this section's Distributed Service Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Distributed Service Rules .
        :return: FirewallRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rules_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rules_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_rules_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get All the Rules for a Section  # noqa: E501

        Return all firewall rule(s) information for a given firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rules_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param str applied_tos: AppliedTo's referenced by this section or section's Distributed Service Rules .
        :param str context_profiles: Limits results to sections having rules with specific Context Profiles.
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool deep_search: Toggle to search with direct or indirect references.
        :param str destinations: Destinations referenced by this section's Distributed Service Rules .
        :param str extended_sources: Limits results to sections having rules with specific Extended Sources.
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool search_invalid_references: Return invalid references in results.
        :param str services: NSService referenced by this section's Distributed Service Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Distributed Service Rules .
        :return: FirewallRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'applied_tos', 'context_profiles', 'cursor', 'deep_search', 'destinations', 'extended_sources', 'filter_type', 'included_fields', 'page_size', 'search_invalid_references', 'services', 'sort_ascending', 'sort_by', 'sources']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'context_profiles' in params:
            query_params.append(('context_profiles', params['context_profiles']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'deep_search' in params:
            query_params.append(('deep_search', params['deep_search']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'extended_sources' in params:
            query_params.append(('extended_sources', params['extended_sources']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'search_invalid_references' in params:
            query_params.append(('search_invalid_references', params['search_invalid_references']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_section(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section  # noqa: E501

        Returns information about firewall section for the identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_section(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_section_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_section_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_section_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section  # noqa: E501

        Returns information about firewall section for the identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_section_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_section_state(self, section_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Firewall Section  # noqa: E501

        Return realized state information of a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_section_state(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: FirewallSectionState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_section_state_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_section_state_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_section_state_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Firewall Section  # noqa: E501

        Return realized state information of a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_section_state_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :param int barrier_id:
        :param str request_id: Realization request ID
        :return: FirewallSectionState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'barrier_id', 'request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_section_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_section_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501
        if 'request_id' in params:
            query_params.append(('request_id', params['request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_section_with_rules_list_with_rules(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section, Including Rules  # noqa: E501

        Returns firewall section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number rule references is not supported.  Instead, to read firewall rules, use: GET /api/v1/firewall/sections/&lt;section-id&gt;/rules with the appropriate page_size.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_section_with_rules_list_with_rules(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_section_with_rules_list_with_rules_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_section_with_rules_list_with_rules_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_section_with_rules_list_with_rules_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section, Including Rules  # noqa: E501

        Returns firewall section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number rule references is not supported.  Instead, to read firewall rules, use: GET /api/v1/firewall/sections/&lt;section-id&gt;/rules with the appropriate page_size.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_section_with_rules_list_with_rules_with_http_info(section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_id: (required)
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_section_with_rules_list_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_section_with_rules_list_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=list_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sections_summary(self, **kwargs):  # noqa: E501
        """Get the summary of sections in the firewall configuration.  # noqa: E501

        List the summary of number of sections and number of rules for each firewall category (L2DFW, L3DFW).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sections_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: Data source type.
        :return: FirewallSectionsSummaryList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sections_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_sections_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_sections_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Get the summary of sections in the firewall configuration.  # noqa: E501

        List the summary of number of sections and number of rules for each firewall category (L2DFW, L3DFW).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sections_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: Data source type.
        :return: FirewallSectionsSummaryList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sections_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionsSummaryList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_firewall_profiles(self, resource_type, **kwargs):  # noqa: E501
        """Get firewall profiles available.  # noqa: E501

        List all the firewall profiles available by requested resource_type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_firewall_profiles(resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_type: Profile resource type (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: FirewallProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_firewall_profiles_with_http_info(resource_type, **kwargs)  # noqa: E501
        else:
            (data) = self.list_firewall_profiles_with_http_info(resource_type, **kwargs)  # noqa: E501
            return data

    def list_firewall_profiles_with_http_info(self, resource_type, **kwargs):  # noqa: E501
        """Get firewall profiles available.  # noqa: E501

        List all the firewall profiles available by requested resource_type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_firewall_profiles_with_http_info(resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_type: Profile resource type (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: FirewallProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_type', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_firewall_profiles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in params or
                params['resource_type'] is None):
            raise ValueError("Missing the required parameter `resource_type` when calling `list_firewall_profiles`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_firewall_status(self, **kwargs):  # noqa: E501
        """List all firewall status for supported contexts  # noqa: E501

        List all firewall status for supported contexts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_firewall_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: FirewallStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_firewall_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_firewall_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_firewall_status_with_http_info(self, **kwargs):  # noqa: E501
        """List all firewall status for supported contexts  # noqa: E501

        List all firewall status for supported contexts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_firewall_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: FirewallStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_firewall_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_sections(self, **kwargs):  # noqa: E501
        """List All Firewall Sections  # noqa: E501

        List all firewall section in paginated form. A default page size is limited to 1000 firewall sections. By default list of section is filtered by LAYER3 type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sections(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str applied_tos: AppliedTo's referenced by this section or section's Distributed Service Rules .
        :param str context_profiles: Limits results to sections having rules with specific Context Profiles.
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool deep_search: Toggle to search with direct or indirect references.
        :param str destinations: Destinations referenced by this section's Distributed Service Rules .
        :param str enforced_on: Type of attachment for logical port; for query only.
        :param str exclude_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str extended_sources: Limits results to sections having rules with specific Extended Sources.
        :param str filter_type: Filter type
        :param str include_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param bool locked: Limit results to sections which are locked/unlocked
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool search_invalid_references: Return invalid references in results.
        :param str search_scope: Limit result to sections of a specific enforcement point
        :param str services: NSService referenced by this section's Distributed Service Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Distributed Service Rules .
        :param str type: Section Type
        :return: FirewallSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_sections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_sections_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_sections_with_http_info(self, **kwargs):  # noqa: E501
        """List All Firewall Sections  # noqa: E501

        List all firewall section in paginated form. A default page size is limited to 1000 firewall sections. By default list of section is filtered by LAYER3 type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sections_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str applied_tos: AppliedTo's referenced by this section or section's Distributed Service Rules .
        :param str context_profiles: Limits results to sections having rules with specific Context Profiles.
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool deep_search: Toggle to search with direct or indirect references.
        :param str destinations: Destinations referenced by this section's Distributed Service Rules .
        :param str enforced_on: Type of attachment for logical port; for query only.
        :param str exclude_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str extended_sources: Limits results to sections having rules with specific Extended Sources.
        :param str filter_type: Filter type
        :param str include_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param bool locked: Limit results to sections which are locked/unlocked
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool search_invalid_references: Return invalid references in results.
        :param str search_scope: Limit result to sections of a specific enforcement point
        :param str services: NSService referenced by this section's Distributed Service Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Distributed Service Rules .
        :param str type: Section Type
        :return: FirewallSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applied_tos', 'context_profiles', 'cursor', 'deep_search', 'destinations', 'enforced_on', 'exclude_applied_to_type', 'extended_sources', 'filter_type', 'include_applied_to_type', 'included_fields', 'locked', 'page_size', 'search_invalid_references', 'search_scope', 'services', 'sort_ascending', 'sort_by', 'sources', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_sections" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'context_profiles' in params:
            query_params.append(('context_profiles', params['context_profiles']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'deep_search' in params:
            query_params.append(('deep_search', params['deep_search']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'enforced_on' in params:
            query_params.append(('enforced_on', params['enforced_on']))  # noqa: E501
        if 'exclude_applied_to_type' in params:
            query_params.append(('exclude_applied_to_type', params['exclude_applied_to_type']))  # noqa: E501
        if 'extended_sources' in params:
            query_params.append(('extended_sources', params['extended_sources']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'include_applied_to_type' in params:
            query_params.append(('include_applied_to_type', params['include_applied_to_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'locked' in params:
            query_params.append(('locked', params['locked']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'search_invalid_references' in params:
            query_params.append(('search_invalid_references', params['search_invalid_references']))  # noqa: E501
        if 'search_scope' in params:
            query_params.append(('search_scope', params['search_scope']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def lock_section_lock(self, body, section_id, **kwargs):  # noqa: E501
        """Lock a section  # noqa: E501

        Lock a section   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.lock_section_lock(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionLock body: (required)
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.lock_section_lock_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.lock_section_lock_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def lock_section_lock_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Lock a section  # noqa: E501

        Lock a section   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.lock_section_lock_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionLock body: (required)
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method lock_section_lock" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `lock_section_lock`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `lock_section_lock`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=lock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_firewall_rule(self, rule_id, **kwargs):  # noqa: E501
        """Read an Existing Rule  # noqa: E501

        Return existing firewall rule information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_firewall_rule(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_id: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_firewall_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_firewall_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def read_firewall_rule_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Read an Existing Rule  # noqa: E501

        Return existing firewall rule information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_firewall_rule_with_http_info(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_id: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_firewall_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `read_firewall_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_member_remove_member(self, object_id, **kwargs):  # noqa: E501
        """Remove an existing object from the exclude list  # noqa: E501

        Remove an existing object from the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_member_remove_member(object_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: identifier of the object (required)
        :param bool deep_check: Check all parents
        :param str object_type: Object type of an entity
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_member_remove_member_with_http_info(object_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_member_remove_member_with_http_info(object_id, **kwargs)  # noqa: E501
            return data

    def remove_member_remove_member_with_http_info(self, object_id, **kwargs):  # noqa: E501
        """Remove an existing object from the exclude list  # noqa: E501

        Remove an existing object from the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_member_remove_member_with_http_info(object_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: identifier of the object (required)
        :param bool deep_check: Check all parents
        :param str object_type: Object type of an entity
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'deep_check', 'object_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_member_remove_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params or
                params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `remove_member_remove_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'deep_check' in params:
            query_params.append(('deep_check', params['deep_check']))  # noqa: E501
        if 'object_id' in params:
            query_params.append(('object_id', params['object_id']))  # noqa: E501
        if 'object_type' in params:
            query_params.append(('object_type', params['object_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist?action=remove_member', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceReference',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_firewall_rule_stats_reset(self, category, **kwargs):  # noqa: E501
        """Reset firewall rule statistics  # noqa: E501

        Sets firewall rule statistics counter to zero. This operation is supported for given category, for example: L3DFW i.e. for all layer3 firewall (transport nodes only) rules or L3EDGE i.e. for all layer3 edge firewall (edge nodes only) rules or L3BRIDGEPORT i.e. for all layer3 bridge port firewall (bridge ports only) rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_firewall_rule_stats_reset(category, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str category: Aggregation statistic category (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_firewall_rule_stats_reset_with_http_info(category, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_firewall_rule_stats_reset_with_http_info(category, **kwargs)  # noqa: E501
            return data

    def reset_firewall_rule_stats_reset_with_http_info(self, category, **kwargs):  # noqa: E501
        """Reset firewall rule statistics  # noqa: E501

        Sets firewall rule statistics counter to zero. This operation is supported for given category, for example: L3DFW i.e. for all layer3 firewall (transport nodes only) rules or L3EDGE i.e. for all layer3 edge firewall (edge nodes only) rules or L3BRIDGEPORT i.e. for all layer3 bridge port firewall (bridge ports only) rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_firewall_rule_stats_reset_with_http_info(category, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str category: Aggregation statistic category (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_firewall_rule_stats_reset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category' is set
        if ('category' not in params or
                params['category'] is None):
            raise ValueError("Missing the required parameter `category` when calling `reset_firewall_rule_stats_reset`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/stats?action=reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_rule_revise(self, body, section_id, rule_id, **kwargs):  # noqa: E501
        """Update an Existing Rule and Reorder the Rule  # noqa: E501

        Modifies existing firewall rule along with relative position among other firewall rules inside a firewall section. Revising firewall rule in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_rule_revise(body, section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallRule body: (required)
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revise_rule_revise_with_http_info(body, section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_rule_revise_with_http_info(body, section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def revise_rule_revise_with_http_info(self, body, section_id, rule_id, **kwargs):  # noqa: E501
        """Update an Existing Rule and Reorder the Rule  # noqa: E501

        Modifies existing firewall rule along with relative position among other firewall rules inside a firewall section. Revising firewall rule in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_rule_revise_with_http_info(body, section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallRule body: (required)
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'rule_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_rule_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `revise_rule_revise`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_rule_revise`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `revise_rule_revise`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_section_revise(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Position  # noqa: E501

        Modifies an existing firewall section along with its relative position among other firewall sections in the system. Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_section_revise(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSection body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revise_section_revise_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_section_revise_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def revise_section_revise_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Position  # noqa: E501

        Modifies an existing firewall section along with its relative position among other firewall sections in the system. Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_section_revise_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSection body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_section_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `revise_section_revise`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_section_revise`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_section_with_rules_revise_with_rules(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section with Rules  # noqa: E501

        Modifies an existing firewall section along with its relative position among other firewall sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/firewall/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;  Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_section_with_rules_revise_with_rules(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionRuleList body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revise_section_with_rules_revise_with_rules_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_section_with_rules_revise_with_rules_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def revise_section_with_rules_revise_with_rules_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section with Rules  # noqa: E501

        Modifies an existing firewall section along with its relative position among other firewall sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/firewall/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;  Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revise_section_with_rules_revise_with_rules_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionRuleList body: (required)
        :param str section_id: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'id', 'operation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_section_with_rules_revise_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `revise_section_with_rules_revise_with_rules`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_section_with_rules_revise_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=revise_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unlock_section_unlock(self, body, section_id, **kwargs):  # noqa: E501
        """Unlock a section  # noqa: E501

        Unlock a section   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_section_unlock(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionLock body: (required)
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unlock_section_unlock_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unlock_section_unlock_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def unlock_section_unlock_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Unlock a section  # noqa: E501

        Unlock a section   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_section_unlock_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionLock body: (required)
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unlock_section_unlock" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `unlock_section_unlock`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `unlock_section_unlock`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=unlock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_exclude_list(self, body, **kwargs):  # noqa: E501
        """Modify exclude list  # noqa: E501

        Modify exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_exclude_list(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExcludeList body: (required)
        :return: ExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_exclude_list_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_exclude_list_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def update_exclude_list_with_http_info(self, body, **kwargs):  # noqa: E501
        """Modify exclude list  # noqa: E501

        Modify exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_exclude_list_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExcludeList body: (required)
        :return: ExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_exclude_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_exclude_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExcludeList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_firewall_profile(self, body, profile_id, **kwargs):  # noqa: E501
        """Update a firewall profile.  # noqa: E501

        Update user configurable properties of firewall profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_firewall_profile(body, profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseFirewallProfile body: (required)
        :param str profile_id: (required)
        :return: BaseFirewallProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_firewall_profile_with_http_info(body, profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_firewall_profile_with_http_info(body, profile_id, **kwargs)  # noqa: E501
            return data

    def update_firewall_profile_with_http_info(self, body, profile_id, **kwargs):  # noqa: E501
        """Update a firewall profile.  # noqa: E501

        Update user configurable properties of firewall profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_firewall_profile_with_http_info(body, profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BaseFirewallProfile body: (required)
        :param str profile_id: (required)
        :return: BaseFirewallProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_firewall_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_firewall_profile`")  # noqa: E501
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `update_firewall_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/profiles/{profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseFirewallProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_firewall_status(self, body, context_type, **kwargs):  # noqa: E501
        """Update global firewall status for dfw context  # noqa: E501

        Update global firewall status for dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_firewall_status(body, context_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallStatus body: (required)
        :param str context_type: (required)
        :return: FirewallStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_firewall_status_with_http_info(body, context_type, **kwargs)  # noqa: E501
        else:
            (data) = self.update_firewall_status_with_http_info(body, context_type, **kwargs)  # noqa: E501
            return data

    def update_firewall_status_with_http_info(self, body, context_type, **kwargs):  # noqa: E501
        """Update global firewall status for dfw context  # noqa: E501

        Update global firewall status for dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_firewall_status_with_http_info(body, context_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallStatus body: (required)
        :param str context_type: (required)
        :return: FirewallStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'context_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_firewall_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_firewall_status`")  # noqa: E501
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `update_firewall_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status/{context-type}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_rule(self, body, section_id, rule_id, **kwargs):  # noqa: E501
        """Update an Existing Rule  # noqa: E501

        Modifies existing firewall rule in a firewall section. Updating firewall rule in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_rule(body, section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallRule body: (required)
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_rule_with_http_info(body, section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_rule_with_http_info(body, section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def update_rule_with_http_info(self, body, section_id, rule_id, **kwargs):  # noqa: E501
        """Update an Existing Rule  # noqa: E501

        Modifies existing firewall rule in a firewall section. Updating firewall rule in a section modifies parent section entity and simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_rule_with_http_info(body, section_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallRule body: (required)
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_rule`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `update_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_section(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section  # noqa: E501

        Modifies the specified section, but does not modify the section's associated rules. Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_section(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSection body: (required)
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_section_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_section_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def update_section_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section  # noqa: E501

        Modifies the specified section, but does not modify the section's associated rules. Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_section_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSection body: (required)
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_section`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_section_with_rules_update_with_rules(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Rules  # noqa: E501

        Modifies existing firewall section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;  Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_section_with_rules_update_with_rules(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionRuleList body: (required)
        :param str section_id: (required)
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_section_with_rules_update_with_rules_with_http_info(body, section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_section_with_rules_update_with_rules_with_http_info(body, section_id, **kwargs)  # noqa: E501
            return data

    def update_section_with_rules_update_with_rules_with_http_info(self, body, section_id, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Rules  # noqa: E501

        Modifies existing firewall section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;  Simultaneous update (modify) operations on same section are not allowed to prevent overwriting stale contents to firewall section. If a concurrent update is performed, HTTP response code 409 will be returned to the client operating on stale data. That client should retrieve the firewall section again and re-apply its update.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_section_with_rules_update_with_rules_with_http_info(body, section_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FirewallSectionRuleList body: (required)
        :param str section_id: (required)
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'section_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_section_with_rules_update_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_section_with_rules_update_with_rules`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_section_with_rules_update_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=update_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
