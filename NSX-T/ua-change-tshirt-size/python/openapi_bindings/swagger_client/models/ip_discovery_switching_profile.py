# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.base_switching_profile import BaseSwitchingProfile  # noqa: F401,E501

class IpDiscoverySwitchingProfile(BaseSwitchingProfile):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'arp_snooping_enabled': 'bool',
        'arp_bindings_limit': 'int',
        'dhcpv6_snooping_enabled': 'bool',
        'nd_snooping_enabled': 'bool',
        'vm_tools_v6_enabled': 'bool',
        'dhcp_snooping_enabled': 'bool',
        'arp_nd_binding_timeout': 'int',
        'vm_tools_enabled': 'bool',
        'trust_on_first_use_enabled': 'bool',
        'nd_bindings_limit': 'int',
        'duplicate_ip_detection': 'DuplicateIPDetection'
    }
    if hasattr(BaseSwitchingProfile, "swagger_types"):
        swagger_types.update(BaseSwitchingProfile.swagger_types)

    attribute_map = {
        'arp_snooping_enabled': 'arp_snooping_enabled',
        'arp_bindings_limit': 'arp_bindings_limit',
        'dhcpv6_snooping_enabled': 'dhcpv6_snooping_enabled',
        'nd_snooping_enabled': 'nd_snooping_enabled',
        'vm_tools_v6_enabled': 'vm_tools_v6_enabled',
        'dhcp_snooping_enabled': 'dhcp_snooping_enabled',
        'arp_nd_binding_timeout': 'arp_nd_binding_timeout',
        'vm_tools_enabled': 'vm_tools_enabled',
        'trust_on_first_use_enabled': 'trust_on_first_use_enabled',
        'nd_bindings_limit': 'nd_bindings_limit',
        'duplicate_ip_detection': 'duplicate_ip_detection'
    }
    if hasattr(BaseSwitchingProfile, "attribute_map"):
        attribute_map.update(BaseSwitchingProfile.attribute_map)

    def __init__(self, arp_snooping_enabled=True, arp_bindings_limit=1, dhcpv6_snooping_enabled=False, nd_snooping_enabled=False, vm_tools_v6_enabled=False, dhcp_snooping_enabled=True, arp_nd_binding_timeout=10, vm_tools_enabled=True, trust_on_first_use_enabled=True, nd_bindings_limit=3, duplicate_ip_detection=None, *args, **kwargs):  # noqa: E501
        """IpDiscoverySwitchingProfile - a model defined in Swagger"""  # noqa: E501
        self._arp_snooping_enabled = None
        self._arp_bindings_limit = None
        self._dhcpv6_snooping_enabled = None
        self._nd_snooping_enabled = None
        self._vm_tools_v6_enabled = None
        self._dhcp_snooping_enabled = None
        self._arp_nd_binding_timeout = None
        self._vm_tools_enabled = None
        self._trust_on_first_use_enabled = None
        self._nd_bindings_limit = None
        self._duplicate_ip_detection = None
        self.discriminator = None
        if arp_snooping_enabled is not None:
            self.arp_snooping_enabled = arp_snooping_enabled
        if arp_bindings_limit is not None:
            self.arp_bindings_limit = arp_bindings_limit
        if dhcpv6_snooping_enabled is not None:
            self.dhcpv6_snooping_enabled = dhcpv6_snooping_enabled
        if nd_snooping_enabled is not None:
            self.nd_snooping_enabled = nd_snooping_enabled
        if vm_tools_v6_enabled is not None:
            self.vm_tools_v6_enabled = vm_tools_v6_enabled
        if dhcp_snooping_enabled is not None:
            self.dhcp_snooping_enabled = dhcp_snooping_enabled
        if arp_nd_binding_timeout is not None:
            self.arp_nd_binding_timeout = arp_nd_binding_timeout
        if vm_tools_enabled is not None:
            self.vm_tools_enabled = vm_tools_enabled
        if trust_on_first_use_enabled is not None:
            self.trust_on_first_use_enabled = trust_on_first_use_enabled
        if nd_bindings_limit is not None:
            self.nd_bindings_limit = nd_bindings_limit
        if duplicate_ip_detection is not None:
            self.duplicate_ip_detection = duplicate_ip_detection
        BaseSwitchingProfile.__init__(self, *args, **kwargs)

    @property
    def arp_snooping_enabled(self):
        """Gets the arp_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501

        Indicates whether ARP snooping is enabled  # noqa: E501

        :return: The arp_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: bool
        """
        return self._arp_snooping_enabled

    @arp_snooping_enabled.setter
    def arp_snooping_enabled(self, arp_snooping_enabled):
        """Sets the arp_snooping_enabled of this IpDiscoverySwitchingProfile.

        Indicates whether ARP snooping is enabled  # noqa: E501

        :param arp_snooping_enabled: The arp_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: bool
        """

        self._arp_snooping_enabled = arp_snooping_enabled

    @property
    def arp_bindings_limit(self):
        """Gets the arp_bindings_limit of this IpDiscoverySwitchingProfile.  # noqa: E501

        Indicates the number of arp snooped IP addresses to be remembered per LogicalPort. Decreasing this value, will retain the latest bindings from the existing list of address bindings. Increasing this value will retain existing bindings and also learn any new address bindings discovered on the port until the new limit is reached. This limit only applies to IPv4 addresses and is independent of the nd_bindings_limit used for IPv6 snooping.  # noqa: E501

        :return: The arp_bindings_limit of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: int
        """
        return self._arp_bindings_limit

    @arp_bindings_limit.setter
    def arp_bindings_limit(self, arp_bindings_limit):
        """Sets the arp_bindings_limit of this IpDiscoverySwitchingProfile.

        Indicates the number of arp snooped IP addresses to be remembered per LogicalPort. Decreasing this value, will retain the latest bindings from the existing list of address bindings. Increasing this value will retain existing bindings and also learn any new address bindings discovered on the port until the new limit is reached. This limit only applies to IPv4 addresses and is independent of the nd_bindings_limit used for IPv6 snooping.  # noqa: E501

        :param arp_bindings_limit: The arp_bindings_limit of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: int
        """

        self._arp_bindings_limit = arp_bindings_limit

    @property
    def dhcpv6_snooping_enabled(self):
        """Gets the dhcpv6_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501

        This option is the IPv6 equivalent of DHCP snooping.  # noqa: E501

        :return: The dhcpv6_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: bool
        """
        return self._dhcpv6_snooping_enabled

    @dhcpv6_snooping_enabled.setter
    def dhcpv6_snooping_enabled(self, dhcpv6_snooping_enabled):
        """Sets the dhcpv6_snooping_enabled of this IpDiscoverySwitchingProfile.

        This option is the IPv6 equivalent of DHCP snooping.  # noqa: E501

        :param dhcpv6_snooping_enabled: The dhcpv6_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: bool
        """

        self._dhcpv6_snooping_enabled = dhcpv6_snooping_enabled

    @property
    def nd_snooping_enabled(self):
        """Gets the nd_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501

        This option is the IPv6 equivalent of ARP snooping.  # noqa: E501

        :return: The nd_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: bool
        """
        return self._nd_snooping_enabled

    @nd_snooping_enabled.setter
    def nd_snooping_enabled(self, nd_snooping_enabled):
        """Sets the nd_snooping_enabled of this IpDiscoverySwitchingProfile.

        This option is the IPv6 equivalent of ARP snooping.  # noqa: E501

        :param nd_snooping_enabled: The nd_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: bool
        """

        self._nd_snooping_enabled = nd_snooping_enabled

    @property
    def vm_tools_v6_enabled(self):
        """Gets the vm_tools_v6_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501

        This option is only supported on ESX where vm-tools is installed.  # noqa: E501

        :return: The vm_tools_v6_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: bool
        """
        return self._vm_tools_v6_enabled

    @vm_tools_v6_enabled.setter
    def vm_tools_v6_enabled(self, vm_tools_v6_enabled):
        """Sets the vm_tools_v6_enabled of this IpDiscoverySwitchingProfile.

        This option is only supported on ESX where vm-tools is installed.  # noqa: E501

        :param vm_tools_v6_enabled: The vm_tools_v6_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: bool
        """

        self._vm_tools_v6_enabled = vm_tools_v6_enabled

    @property
    def dhcp_snooping_enabled(self):
        """Gets the dhcp_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501

        Indicates whether DHCP snooping is enabled  # noqa: E501

        :return: The dhcp_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: bool
        """
        return self._dhcp_snooping_enabled

    @dhcp_snooping_enabled.setter
    def dhcp_snooping_enabled(self, dhcp_snooping_enabled):
        """Sets the dhcp_snooping_enabled of this IpDiscoverySwitchingProfile.

        Indicates whether DHCP snooping is enabled  # noqa: E501

        :param dhcp_snooping_enabled: The dhcp_snooping_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: bool
        """

        self._dhcp_snooping_enabled = dhcp_snooping_enabled

    @property
    def arp_nd_binding_timeout(self):
        """Gets the arp_nd_binding_timeout of this IpDiscoverySwitchingProfile.  # noqa: E501

        This property controls the ARP and ND cache timeout period.It is recommended that this property be greater than the ARP/ND cache timeout on the VM.   # noqa: E501

        :return: The arp_nd_binding_timeout of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: int
        """
        return self._arp_nd_binding_timeout

    @arp_nd_binding_timeout.setter
    def arp_nd_binding_timeout(self, arp_nd_binding_timeout):
        """Sets the arp_nd_binding_timeout of this IpDiscoverySwitchingProfile.

        This property controls the ARP and ND cache timeout period.It is recommended that this property be greater than the ARP/ND cache timeout on the VM.   # noqa: E501

        :param arp_nd_binding_timeout: The arp_nd_binding_timeout of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: int
        """

        self._arp_nd_binding_timeout = arp_nd_binding_timeout

    @property
    def vm_tools_enabled(self):
        """Gets the vm_tools_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501

        This option is only supported on ESX where vm-tools is installed.  # noqa: E501

        :return: The vm_tools_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: bool
        """
        return self._vm_tools_enabled

    @vm_tools_enabled.setter
    def vm_tools_enabled(self, vm_tools_enabled):
        """Sets the vm_tools_enabled of this IpDiscoverySwitchingProfile.

        This option is only supported on ESX where vm-tools is installed.  # noqa: E501

        :param vm_tools_enabled: The vm_tools_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: bool
        """

        self._vm_tools_enabled = vm_tools_enabled

    @property
    def trust_on_first_use_enabled(self):
        """Gets the trust_on_first_use_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501

        ARP snooping being inherently susceptible to ARP spoofing, uses a turst-on-fisrt-use (TOFU) paradigm where only the first IP address discovered via ARP snooping is trusted. The remaining are ignored. In order to allow for more flexibility, we allow the user to configure how many ARP snooped address bindings should be trusted for the lifetime of the logical port. This is controlled by the arp_bindings_limit property in the IP Discovery profile. We refer to this extension of TOFU as N-TOFU. However, if TOFU is disabled, then N ARP snooped IP addresses will be trusted until they are timed out, where N is configured by arp_bindings_limit.   # noqa: E501

        :return: The trust_on_first_use_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: bool
        """
        return self._trust_on_first_use_enabled

    @trust_on_first_use_enabled.setter
    def trust_on_first_use_enabled(self, trust_on_first_use_enabled):
        """Sets the trust_on_first_use_enabled of this IpDiscoverySwitchingProfile.

        ARP snooping being inherently susceptible to ARP spoofing, uses a turst-on-fisrt-use (TOFU) paradigm where only the first IP address discovered via ARP snooping is trusted. The remaining are ignored. In order to allow for more flexibility, we allow the user to configure how many ARP snooped address bindings should be trusted for the lifetime of the logical port. This is controlled by the arp_bindings_limit property in the IP Discovery profile. We refer to this extension of TOFU as N-TOFU. However, if TOFU is disabled, then N ARP snooped IP addresses will be trusted until they are timed out, where N is configured by arp_bindings_limit.   # noqa: E501

        :param trust_on_first_use_enabled: The trust_on_first_use_enabled of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: bool
        """

        self._trust_on_first_use_enabled = trust_on_first_use_enabled

    @property
    def nd_bindings_limit(self):
        """Gets the nd_bindings_limit of this IpDiscoverySwitchingProfile.  # noqa: E501

        Indicates the number of neighbor-discovery snooped IP addresses to be remembered per LogicalPort. Decreasing this value, will retain the latest bindings from the existing list of address bindings. Increasing this value will retain existing bindings and also learn any new address bindings discovered on the port until the new limit is reached. This limit only applies to IPv6 addresses and is independent of the arp_bindings_limit used for IPv4 snooping.  # noqa: E501

        :return: The nd_bindings_limit of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: int
        """
        return self._nd_bindings_limit

    @nd_bindings_limit.setter
    def nd_bindings_limit(self, nd_bindings_limit):
        """Sets the nd_bindings_limit of this IpDiscoverySwitchingProfile.

        Indicates the number of neighbor-discovery snooped IP addresses to be remembered per LogicalPort. Decreasing this value, will retain the latest bindings from the existing list of address bindings. Increasing this value will retain existing bindings and also learn any new address bindings discovered on the port until the new limit is reached. This limit only applies to IPv6 addresses and is independent of the arp_bindings_limit used for IPv4 snooping.  # noqa: E501

        :param nd_bindings_limit: The nd_bindings_limit of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: int
        """

        self._nd_bindings_limit = nd_bindings_limit

    @property
    def duplicate_ip_detection(self):
        """Gets the duplicate_ip_detection of this IpDiscoverySwitchingProfile.  # noqa: E501


        :return: The duplicate_ip_detection of this IpDiscoverySwitchingProfile.  # noqa: E501
        :rtype: DuplicateIPDetection
        """
        return self._duplicate_ip_detection

    @duplicate_ip_detection.setter
    def duplicate_ip_detection(self, duplicate_ip_detection):
        """Sets the duplicate_ip_detection of this IpDiscoverySwitchingProfile.


        :param duplicate_ip_detection: The duplicate_ip_detection of this IpDiscoverySwitchingProfile.  # noqa: E501
        :type: DuplicateIPDetection
        """

        self._duplicate_ip_detection = duplicate_ip_detection

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(IpDiscoverySwitchingProfile, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IpDiscoverySwitchingProfile):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
