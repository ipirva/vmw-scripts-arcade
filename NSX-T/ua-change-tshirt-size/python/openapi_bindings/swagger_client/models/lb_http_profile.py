# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.lb_app_profile import LbAppProfile  # noqa: F401,E501

class LbHttpProfile(LbAppProfile):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'response_buffering': 'bool',
        'response_timeout': 'int',
        'request_body_size': 'int',
        'ntlm': 'bool',
        'request_header_size': 'int',
        'http_redirect_to_https': 'bool',
        'response_header_size': 'int',
        'idle_timeout': 'int',
        'server_keep_alive': 'bool',
        'http_redirect_to': 'str',
        'x_forwarded_for': 'str'
    }
    if hasattr(LbAppProfile, "swagger_types"):
        swagger_types.update(LbAppProfile.swagger_types)

    attribute_map = {
        'response_buffering': 'response_buffering',
        'response_timeout': 'response_timeout',
        'request_body_size': 'request_body_size',
        'ntlm': 'ntlm',
        'request_header_size': 'request_header_size',
        'http_redirect_to_https': 'http_redirect_to_https',
        'response_header_size': 'response_header_size',
        'idle_timeout': 'idle_timeout',
        'server_keep_alive': 'server_keep_alive',
        'http_redirect_to': 'http_redirect_to',
        'x_forwarded_for': 'x_forwarded_for'
    }
    if hasattr(LbAppProfile, "attribute_map"):
        attribute_map.update(LbAppProfile.attribute_map)

    def __init__(self, response_buffering=False, response_timeout=60, request_body_size=None, ntlm=None, request_header_size=1024, http_redirect_to_https=False, response_header_size=4096, idle_timeout=15, server_keep_alive=None, http_redirect_to=None, x_forwarded_for=None, *args, **kwargs):  # noqa: E501
        """LbHttpProfile - a model defined in Swagger"""  # noqa: E501
        self._response_buffering = None
        self._response_timeout = None
        self._request_body_size = None
        self._ntlm = None
        self._request_header_size = None
        self._http_redirect_to_https = None
        self._response_header_size = None
        self._idle_timeout = None
        self._server_keep_alive = None
        self._http_redirect_to = None
        self._x_forwarded_for = None
        self.discriminator = None
        if response_buffering is not None:
            self.response_buffering = response_buffering
        if response_timeout is not None:
            self.response_timeout = response_timeout
        if request_body_size is not None:
            self.request_body_size = request_body_size
        if ntlm is not None:
            self.ntlm = ntlm
        if request_header_size is not None:
            self.request_header_size = request_header_size
        if http_redirect_to_https is not None:
            self.http_redirect_to_https = http_redirect_to_https
        if response_header_size is not None:
            self.response_header_size = response_header_size
        if idle_timeout is not None:
            self.idle_timeout = idle_timeout
        if server_keep_alive is not None:
            self.server_keep_alive = server_keep_alive
        if http_redirect_to is not None:
            self.http_redirect_to = http_redirect_to
        if x_forwarded_for is not None:
            self.x_forwarded_for = x_forwarded_for
        LbAppProfile.__init__(self, *args, **kwargs)

    @property
    def response_buffering(self):
        """Gets the response_buffering of this LbHttpProfile.  # noqa: E501

        When buffering is disabled, the response is passed to a client synchronously, immediately as it is received. When buffering is enabled, LB receives a response from the backend server as soon as possible, saving it into the buffers.   # noqa: E501

        :return: The response_buffering of this LbHttpProfile.  # noqa: E501
        :rtype: bool
        """
        return self._response_buffering

    @response_buffering.setter
    def response_buffering(self, response_buffering):
        """Sets the response_buffering of this LbHttpProfile.

        When buffering is disabled, the response is passed to a client synchronously, immediately as it is received. When buffering is enabled, LB receives a response from the backend server as soon as possible, saving it into the buffers.   # noqa: E501

        :param response_buffering: The response_buffering of this LbHttpProfile.  # noqa: E501
        :type: bool
        """

        self._response_buffering = response_buffering

    @property
    def response_timeout(self):
        """Gets the response_timeout of this LbHttpProfile.  # noqa: E501

        If server doesn't send any packet within this time, the connection is closed.   # noqa: E501

        :return: The response_timeout of this LbHttpProfile.  # noqa: E501
        :rtype: int
        """
        return self._response_timeout

    @response_timeout.setter
    def response_timeout(self, response_timeout):
        """Sets the response_timeout of this LbHttpProfile.

        If server doesn't send any packet within this time, the connection is closed.   # noqa: E501

        :param response_timeout: The response_timeout of this LbHttpProfile.  # noqa: E501
        :type: int
        """

        self._response_timeout = response_timeout

    @property
    def request_body_size(self):
        """Gets the request_body_size of this LbHttpProfile.  # noqa: E501

        If it is not specified, it means that request body size is unlimited.   # noqa: E501

        :return: The request_body_size of this LbHttpProfile.  # noqa: E501
        :rtype: int
        """
        return self._request_body_size

    @request_body_size.setter
    def request_body_size(self, request_body_size):
        """Sets the request_body_size of this LbHttpProfile.

        If it is not specified, it means that request body size is unlimited.   # noqa: E501

        :param request_body_size: The request_body_size of this LbHttpProfile.  # noqa: E501
        :type: int
        """

        self._request_body_size = request_body_size

    @property
    def ntlm(self):
        """Gets the ntlm of this LbHttpProfile.  # noqa: E501

        NTLM is an authentication protocol that can be used over HTTP. If the flag is set to true, LB will use NTLM challenge/response methodology. This property is deprecated. Please use the property server_keep_alive in order to keep the backend server connection alive for the client connection. When create a new profile, if both ntlm and server_keep_alive are set as different values, ERROR will be reported. When update an existing profile, if either ntlm or server_keep_alive value is changed, both of them are updated with the changed value.   # noqa: E501

        :return: The ntlm of this LbHttpProfile.  # noqa: E501
        :rtype: bool
        """
        return self._ntlm

    @ntlm.setter
    def ntlm(self, ntlm):
        """Sets the ntlm of this LbHttpProfile.

        NTLM is an authentication protocol that can be used over HTTP. If the flag is set to true, LB will use NTLM challenge/response methodology. This property is deprecated. Please use the property server_keep_alive in order to keep the backend server connection alive for the client connection. When create a new profile, if both ntlm and server_keep_alive are set as different values, ERROR will be reported. When update an existing profile, if either ntlm or server_keep_alive value is changed, both of them are updated with the changed value.   # noqa: E501

        :param ntlm: The ntlm of this LbHttpProfile.  # noqa: E501
        :type: bool
        """

        self._ntlm = ntlm

    @property
    def request_header_size(self):
        """Gets the request_header_size of this LbHttpProfile.  # noqa: E501

        A request with header equal to or below this size is guaranteed to be processed. A request with header larger than request_header_size will be processed up to 32K bytes on best effort basis.   # noqa: E501

        :return: The request_header_size of this LbHttpProfile.  # noqa: E501
        :rtype: int
        """
        return self._request_header_size

    @request_header_size.setter
    def request_header_size(self, request_header_size):
        """Sets the request_header_size of this LbHttpProfile.

        A request with header equal to or below this size is guaranteed to be processed. A request with header larger than request_header_size will be processed up to 32K bytes on best effort basis.   # noqa: E501

        :param request_header_size: The request_header_size of this LbHttpProfile.  # noqa: E501
        :type: int
        """

        self._request_header_size = request_header_size

    @property
    def http_redirect_to_https(self):
        """Gets the http_redirect_to_https of this LbHttpProfile.  # noqa: E501

        Certain secure applications may want to force communication over SSL, but instead of rejecting non-SSL connections, they may choose to redirect the client automatically to use SSL.   # noqa: E501

        :return: The http_redirect_to_https of this LbHttpProfile.  # noqa: E501
        :rtype: bool
        """
        return self._http_redirect_to_https

    @http_redirect_to_https.setter
    def http_redirect_to_https(self, http_redirect_to_https):
        """Sets the http_redirect_to_https of this LbHttpProfile.

        Certain secure applications may want to force communication over SSL, but instead of rejecting non-SSL connections, they may choose to redirect the client automatically to use SSL.   # noqa: E501

        :param http_redirect_to_https: The http_redirect_to_https of this LbHttpProfile.  # noqa: E501
        :type: bool
        """

        self._http_redirect_to_https = http_redirect_to_https

    @property
    def response_header_size(self):
        """Gets the response_header_size of this LbHttpProfile.  # noqa: E501

        A response with header larger than response_header_size will be dropped.   # noqa: E501

        :return: The response_header_size of this LbHttpProfile.  # noqa: E501
        :rtype: int
        """
        return self._response_header_size

    @response_header_size.setter
    def response_header_size(self, response_header_size):
        """Sets the response_header_size of this LbHttpProfile.

        A response with header larger than response_header_size will be dropped.   # noqa: E501

        :param response_header_size: The response_header_size of this LbHttpProfile.  # noqa: E501
        :type: int
        """

        self._response_header_size = response_header_size

    @property
    def idle_timeout(self):
        """Gets the idle_timeout of this LbHttpProfile.  # noqa: E501

        It is used to specify the HTTP application idle timeout, it means that how long the load balancer will keep the connection idle to wait for the client to send the next keep-alive request. It is not a TCP socket setting.   # noqa: E501

        :return: The idle_timeout of this LbHttpProfile.  # noqa: E501
        :rtype: int
        """
        return self._idle_timeout

    @idle_timeout.setter
    def idle_timeout(self, idle_timeout):
        """Sets the idle_timeout of this LbHttpProfile.

        It is used to specify the HTTP application idle timeout, it means that how long the load balancer will keep the connection idle to wait for the client to send the next keep-alive request. It is not a TCP socket setting.   # noqa: E501

        :param idle_timeout: The idle_timeout of this LbHttpProfile.  # noqa: E501
        :type: int
        """

        self._idle_timeout = idle_timeout

    @property
    def server_keep_alive(self):
        """Gets the server_keep_alive of this LbHttpProfile.  # noqa: E501

        If server_keep_alive is true, it means the backend connection will keep alive for the client connection. Every client connection is tied 1:1 with the corresponding server-side connection. If server_keep_alive is false, it means the backend connection won't keep alive for the client connection. The default value is false. If server_keep_alive is not specified for API input, its value in API output will be the same with the property ntlm.   # noqa: E501

        :return: The server_keep_alive of this LbHttpProfile.  # noqa: E501
        :rtype: bool
        """
        return self._server_keep_alive

    @server_keep_alive.setter
    def server_keep_alive(self, server_keep_alive):
        """Sets the server_keep_alive of this LbHttpProfile.

        If server_keep_alive is true, it means the backend connection will keep alive for the client connection. Every client connection is tied 1:1 with the corresponding server-side connection. If server_keep_alive is false, it means the backend connection won't keep alive for the client connection. The default value is false. If server_keep_alive is not specified for API input, its value in API output will be the same with the property ntlm.   # noqa: E501

        :param server_keep_alive: The server_keep_alive of this LbHttpProfile.  # noqa: E501
        :type: bool
        """

        self._server_keep_alive = server_keep_alive

    @property
    def http_redirect_to(self):
        """Gets the http_redirect_to of this LbHttpProfile.  # noqa: E501

        If a website is temporarily down or has moved, incoming requests for that virtual server can be temporarily redirected to a URL   # noqa: E501

        :return: The http_redirect_to of this LbHttpProfile.  # noqa: E501
        :rtype: str
        """
        return self._http_redirect_to

    @http_redirect_to.setter
    def http_redirect_to(self, http_redirect_to):
        """Sets the http_redirect_to of this LbHttpProfile.

        If a website is temporarily down or has moved, incoming requests for that virtual server can be temporarily redirected to a URL   # noqa: E501

        :param http_redirect_to: The http_redirect_to of this LbHttpProfile.  # noqa: E501
        :type: str
        """

        self._http_redirect_to = http_redirect_to

    @property
    def x_forwarded_for(self):
        """Gets the x_forwarded_for of this LbHttpProfile.  # noqa: E501

        When X-Forwareded-For is configured, X-Forwarded-Proto and X-Forwarded-Port information is added automatically. The two additional header information can be also modified or deleted in load balancer rules.   # noqa: E501

        :return: The x_forwarded_for of this LbHttpProfile.  # noqa: E501
        :rtype: str
        """
        return self._x_forwarded_for

    @x_forwarded_for.setter
    def x_forwarded_for(self, x_forwarded_for):
        """Sets the x_forwarded_for of this LbHttpProfile.

        When X-Forwareded-For is configured, X-Forwarded-Proto and X-Forwarded-Port information is added automatically. The two additional header information can be also modified or deleted in load balancer rules.   # noqa: E501

        :param x_forwarded_for: The x_forwarded_for of this LbHttpProfile.  # noqa: E501
        :type: str
        """
        allowed_values = ["INSERT", "REPLACE"]  # noqa: E501
        if x_forwarded_for not in allowed_values:
            raise ValueError(
                "Invalid value for `x_forwarded_for` ({0}), must be one of {1}"  # noqa: E501
                .format(x_forwarded_for, allowed_values)
            )

        self._x_forwarded_for = x_forwarded_for

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LbHttpProfile, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LbHttpProfile):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
