# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.managed_resource import ManagedResource  # noqa: F401,E501

class LbPool(ManagedResource):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'member_group': 'PoolMemberGroup',
        'snat_translation': 'LbSnatTranslation',
        'algorithm': 'str',
        'members': 'list[PoolMember]',
        'passive_monitor_id': 'str',
        'tcp_multiplexing_number': 'int',
        'active_monitor_ids': 'list[str]',
        'tcp_multiplexing_enabled': 'bool',
        'min_active_members': 'int'
    }
    if hasattr(ManagedResource, "swagger_types"):
        swagger_types.update(ManagedResource.swagger_types)

    attribute_map = {
        'member_group': 'member_group',
        'snat_translation': 'snat_translation',
        'algorithm': 'algorithm',
        'members': 'members',
        'passive_monitor_id': 'passive_monitor_id',
        'tcp_multiplexing_number': 'tcp_multiplexing_number',
        'active_monitor_ids': 'active_monitor_ids',
        'tcp_multiplexing_enabled': 'tcp_multiplexing_enabled',
        'min_active_members': 'min_active_members'
    }
    if hasattr(ManagedResource, "attribute_map"):
        attribute_map.update(ManagedResource.attribute_map)

    def __init__(self, member_group=None, snat_translation=None, algorithm='ROUND_ROBIN', members=None, passive_monitor_id=None, tcp_multiplexing_number=6, active_monitor_ids=None, tcp_multiplexing_enabled=False, min_active_members=1, *args, **kwargs):  # noqa: E501
        """LbPool - a model defined in Swagger"""  # noqa: E501
        self._member_group = None
        self._snat_translation = None
        self._algorithm = None
        self._members = None
        self._passive_monitor_id = None
        self._tcp_multiplexing_number = None
        self._active_monitor_ids = None
        self._tcp_multiplexing_enabled = None
        self._min_active_members = None
        self.discriminator = None
        if member_group is not None:
            self.member_group = member_group
        if snat_translation is not None:
            self.snat_translation = snat_translation
        if algorithm is not None:
            self.algorithm = algorithm
        if members is not None:
            self.members = members
        if passive_monitor_id is not None:
            self.passive_monitor_id = passive_monitor_id
        if tcp_multiplexing_number is not None:
            self.tcp_multiplexing_number = tcp_multiplexing_number
        if active_monitor_ids is not None:
            self.active_monitor_ids = active_monitor_ids
        if tcp_multiplexing_enabled is not None:
            self.tcp_multiplexing_enabled = tcp_multiplexing_enabled
        if min_active_members is not None:
            self.min_active_members = min_active_members
        ManagedResource.__init__(self, *args, **kwargs)

    @property
    def member_group(self):
        """Gets the member_group of this LbPool.  # noqa: E501


        :return: The member_group of this LbPool.  # noqa: E501
        :rtype: PoolMemberGroup
        """
        return self._member_group

    @member_group.setter
    def member_group(self, member_group):
        """Sets the member_group of this LbPool.


        :param member_group: The member_group of this LbPool.  # noqa: E501
        :type: PoolMemberGroup
        """

        self._member_group = member_group

    @property
    def snat_translation(self):
        """Gets the snat_translation of this LbPool.  # noqa: E501


        :return: The snat_translation of this LbPool.  # noqa: E501
        :rtype: LbSnatTranslation
        """
        return self._snat_translation

    @snat_translation.setter
    def snat_translation(self, snat_translation):
        """Sets the snat_translation of this LbPool.


        :param snat_translation: The snat_translation of this LbPool.  # noqa: E501
        :type: LbSnatTranslation
        """

        self._snat_translation = snat_translation

    @property
    def algorithm(self):
        """Gets the algorithm of this LbPool.  # noqa: E501

        Load balancing algorithm, configurable per pool controls how the incoming connections are distributed among the members.   # noqa: E501

        :return: The algorithm of this LbPool.  # noqa: E501
        :rtype: str
        """
        return self._algorithm

    @algorithm.setter
    def algorithm(self, algorithm):
        """Sets the algorithm of this LbPool.

        Load balancing algorithm, configurable per pool controls how the incoming connections are distributed among the members.   # noqa: E501

        :param algorithm: The algorithm of this LbPool.  # noqa: E501
        :type: str
        """
        allowed_values = ["ROUND_ROBIN", "WEIGHTED_ROUND_ROBIN", "LEAST_CONNECTION", "WEIGHTED_LEAST_CONNECTION", "IP_HASH"]  # noqa: E501
        if algorithm not in allowed_values:
            raise ValueError(
                "Invalid value for `algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(algorithm, allowed_values)
            )

        self._algorithm = algorithm

    @property
    def members(self):
        """Gets the members of this LbPool.  # noqa: E501

        Server pool consists of one or more pool members. Each pool member is identified, typically, by an IP address and a port.   # noqa: E501

        :return: The members of this LbPool.  # noqa: E501
        :rtype: list[PoolMember]
        """
        return self._members

    @members.setter
    def members(self, members):
        """Sets the members of this LbPool.

        Server pool consists of one or more pool members. Each pool member is identified, typically, by an IP address and a port.   # noqa: E501

        :param members: The members of this LbPool.  # noqa: E501
        :type: list[PoolMember]
        """

        self._members = members

    @property
    def passive_monitor_id(self):
        """Gets the passive_monitor_id of this LbPool.  # noqa: E501

        Passive healthchecks are disabled by default and can be enabled by attaching a passive health monitor to a server pool. Each time a client connection to a pool member fails, its failed count is incremented. For pools bound to L7 virtual servers, a connection is considered to be failed and failed count is incremented if any TCP connection errors (e.g. TCP RST or failure to send data) or SSL handshake failures occur. For pools bound to L4 virtual servers, if no response is received to a TCP SYN sent to the pool member or if a TCP RST is received in response to a TCP SYN, then the pool member is considered to have failed and the failed count is incremented.   # noqa: E501

        :return: The passive_monitor_id of this LbPool.  # noqa: E501
        :rtype: str
        """
        return self._passive_monitor_id

    @passive_monitor_id.setter
    def passive_monitor_id(self, passive_monitor_id):
        """Sets the passive_monitor_id of this LbPool.

        Passive healthchecks are disabled by default and can be enabled by attaching a passive health monitor to a server pool. Each time a client connection to a pool member fails, its failed count is incremented. For pools bound to L7 virtual servers, a connection is considered to be failed and failed count is incremented if any TCP connection errors (e.g. TCP RST or failure to send data) or SSL handshake failures occur. For pools bound to L4 virtual servers, if no response is received to a TCP SYN sent to the pool member or if a TCP RST is received in response to a TCP SYN, then the pool member is considered to have failed and the failed count is incremented.   # noqa: E501

        :param passive_monitor_id: The passive_monitor_id of this LbPool.  # noqa: E501
        :type: str
        """

        self._passive_monitor_id = passive_monitor_id

    @property
    def tcp_multiplexing_number(self):
        """Gets the tcp_multiplexing_number of this LbPool.  # noqa: E501

        The maximum number of TCP connections per pool that are idly kept alive for sending future client requests.   # noqa: E501

        :return: The tcp_multiplexing_number of this LbPool.  # noqa: E501
        :rtype: int
        """
        return self._tcp_multiplexing_number

    @tcp_multiplexing_number.setter
    def tcp_multiplexing_number(self, tcp_multiplexing_number):
        """Sets the tcp_multiplexing_number of this LbPool.

        The maximum number of TCP connections per pool that are idly kept alive for sending future client requests.   # noqa: E501

        :param tcp_multiplexing_number: The tcp_multiplexing_number of this LbPool.  # noqa: E501
        :type: int
        """

        self._tcp_multiplexing_number = tcp_multiplexing_number

    @property
    def active_monitor_ids(self):
        """Gets the active_monitor_ids of this LbPool.  # noqa: E501

        In case of active healthchecks, load balancer itself initiates new connections (or sends ICMP ping) to the servers periodically to check their health, completely independent of any data traffic. Active healthchecks are disabled by default and can be enabled for a server pool by binding a health monitor to the pool. If multiple active monitors are configured, the pool member status is UP only when the health check status for all the monitors are UP.   # noqa: E501

        :return: The active_monitor_ids of this LbPool.  # noqa: E501
        :rtype: list[str]
        """
        return self._active_monitor_ids

    @active_monitor_ids.setter
    def active_monitor_ids(self, active_monitor_ids):
        """Sets the active_monitor_ids of this LbPool.

        In case of active healthchecks, load balancer itself initiates new connections (or sends ICMP ping) to the servers periodically to check their health, completely independent of any data traffic. Active healthchecks are disabled by default and can be enabled for a server pool by binding a health monitor to the pool. If multiple active monitors are configured, the pool member status is UP only when the health check status for all the monitors are UP.   # noqa: E501

        :param active_monitor_ids: The active_monitor_ids of this LbPool.  # noqa: E501
        :type: list[str]
        """

        self._active_monitor_ids = active_monitor_ids

    @property
    def tcp_multiplexing_enabled(self):
        """Gets the tcp_multiplexing_enabled of this LbPool.  # noqa: E501

        TCP multiplexing allows the same TCP connection between load balancer and the backend server to be used for sending multiple client requests from different client TCP connections.   # noqa: E501

        :return: The tcp_multiplexing_enabled of this LbPool.  # noqa: E501
        :rtype: bool
        """
        return self._tcp_multiplexing_enabled

    @tcp_multiplexing_enabled.setter
    def tcp_multiplexing_enabled(self, tcp_multiplexing_enabled):
        """Sets the tcp_multiplexing_enabled of this LbPool.

        TCP multiplexing allows the same TCP connection between load balancer and the backend server to be used for sending multiple client requests from different client TCP connections.   # noqa: E501

        :param tcp_multiplexing_enabled: The tcp_multiplexing_enabled of this LbPool.  # noqa: E501
        :type: bool
        """

        self._tcp_multiplexing_enabled = tcp_multiplexing_enabled

    @property
    def min_active_members(self):
        """Gets the min_active_members of this LbPool.  # noqa: E501

        A pool is considered active if there are at least certain minimum number of members.   # noqa: E501

        :return: The min_active_members of this LbPool.  # noqa: E501
        :rtype: int
        """
        return self._min_active_members

    @min_active_members.setter
    def min_active_members(self, min_active_members):
        """Sets the min_active_members of this LbPool.

        A pool is considered active if there are at least certain minimum number of members.   # noqa: E501

        :param min_active_members: The min_active_members of this LbPool.  # noqa: E501
        :type: int
        """

        self._min_active_members = min_active_members

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LbPool, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LbPool):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
