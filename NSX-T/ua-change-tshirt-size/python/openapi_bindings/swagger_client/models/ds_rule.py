# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.embedded_resource import EmbeddedResource  # noqa: F401,E501

class DSRule(EmbeddedResource):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'is_default': 'bool',
        'direction': 'str',
        'rule_tag': 'str',
        'ip_protocol': 'str',
        'notes': 'str',
        'applied_tos': 'list[ResourceReference]',
        'logged': 'bool',
        'disabled': 'bool',
        'sources': 'list[ResourceReference]',
        'action': 'str',
        'priority': 'int',
        'sources_excluded': 'bool',
        'destinations_excluded': 'bool',
        'destinations': 'list[ResourceReference]'
    }
    if hasattr(EmbeddedResource, "swagger_types"):
        swagger_types.update(EmbeddedResource.swagger_types)

    attribute_map = {
        'is_default': 'is_default',
        'direction': 'direction',
        'rule_tag': 'rule_tag',
        'ip_protocol': 'ip_protocol',
        'notes': 'notes',
        'applied_tos': 'applied_tos',
        'logged': 'logged',
        'disabled': 'disabled',
        'sources': 'sources',
        'action': 'action',
        'priority': 'priority',
        'sources_excluded': 'sources_excluded',
        'destinations_excluded': 'destinations_excluded',
        'destinations': 'destinations'
    }
    if hasattr(EmbeddedResource, "attribute_map"):
        attribute_map.update(EmbeddedResource.attribute_map)

    def __init__(self, is_default=None, direction='IN_OUT', rule_tag=None, ip_protocol='IPV4_IPV6', notes=None, applied_tos=None, logged=False, disabled=False, sources=None, action=None, priority=None, sources_excluded=False, destinations_excluded=False, destinations=None, *args, **kwargs):  # noqa: E501
        """DSRule - a model defined in Swagger"""  # noqa: E501
        self._is_default = None
        self._direction = None
        self._rule_tag = None
        self._ip_protocol = None
        self._notes = None
        self._applied_tos = None
        self._logged = None
        self._disabled = None
        self._sources = None
        self._action = None
        self._priority = None
        self._sources_excluded = None
        self._destinations_excluded = None
        self._destinations = None
        self.discriminator = None
        if is_default is not None:
            self.is_default = is_default
        if direction is not None:
            self.direction = direction
        if rule_tag is not None:
            self.rule_tag = rule_tag
        if ip_protocol is not None:
            self.ip_protocol = ip_protocol
        if notes is not None:
            self.notes = notes
        if applied_tos is not None:
            self.applied_tos = applied_tos
        if logged is not None:
            self.logged = logged
        if disabled is not None:
            self.disabled = disabled
        if sources is not None:
            self.sources = sources
        self.action = action
        if priority is not None:
            self.priority = priority
        if sources_excluded is not None:
            self.sources_excluded = sources_excluded
        if destinations_excluded is not None:
            self.destinations_excluded = destinations_excluded
        if destinations is not None:
            self.destinations = destinations
        EmbeddedResource.__init__(self, *args, **kwargs)

    @property
    def is_default(self):
        """Gets the is_default of this DSRule.  # noqa: E501

        Flag to indicate whether rule is default.  # noqa: E501

        :return: The is_default of this DSRule.  # noqa: E501
        :rtype: bool
        """
        return self._is_default

    @is_default.setter
    def is_default(self, is_default):
        """Sets the is_default of this DSRule.

        Flag to indicate whether rule is default.  # noqa: E501

        :param is_default: The is_default of this DSRule.  # noqa: E501
        :type: bool
        """

        self._is_default = is_default

    @property
    def direction(self):
        """Gets the direction of this DSRule.  # noqa: E501

        Rule direction in case of stateless distributed service rules. This will only considered if section level parameter is set to stateless. Default to IN_OUT if not specified.  # noqa: E501

        :return: The direction of this DSRule.  # noqa: E501
        :rtype: str
        """
        return self._direction

    @direction.setter
    def direction(self, direction):
        """Sets the direction of this DSRule.

        Rule direction in case of stateless distributed service rules. This will only considered if section level parameter is set to stateless. Default to IN_OUT if not specified.  # noqa: E501

        :param direction: The direction of this DSRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["IN", "OUT", "IN_OUT"]  # noqa: E501
        if direction not in allowed_values:
            raise ValueError(
                "Invalid value for `direction` ({0}), must be one of {1}"  # noqa: E501
                .format(direction, allowed_values)
            )

        self._direction = direction

    @property
    def rule_tag(self):
        """Gets the rule_tag of this DSRule.  # noqa: E501

        User level field which will be printed in CLI and packet logs.  # noqa: E501

        :return: The rule_tag of this DSRule.  # noqa: E501
        :rtype: str
        """
        return self._rule_tag

    @rule_tag.setter
    def rule_tag(self, rule_tag):
        """Sets the rule_tag of this DSRule.

        User level field which will be printed in CLI and packet logs.  # noqa: E501

        :param rule_tag: The rule_tag of this DSRule.  # noqa: E501
        :type: str
        """

        self._rule_tag = rule_tag

    @property
    def ip_protocol(self):
        """Gets the ip_protocol of this DSRule.  # noqa: E501

        Type of IP packet that should be matched while enforcing the rule.  # noqa: E501

        :return: The ip_protocol of this DSRule.  # noqa: E501
        :rtype: str
        """
        return self._ip_protocol

    @ip_protocol.setter
    def ip_protocol(self, ip_protocol):
        """Sets the ip_protocol of this DSRule.

        Type of IP packet that should be matched while enforcing the rule.  # noqa: E501

        :param ip_protocol: The ip_protocol of this DSRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["IPV4", "IPV6", "IPV4_IPV6"]  # noqa: E501
        if ip_protocol not in allowed_values:
            raise ValueError(
                "Invalid value for `ip_protocol` ({0}), must be one of {1}"  # noqa: E501
                .format(ip_protocol, allowed_values)
            )

        self._ip_protocol = ip_protocol

    @property
    def notes(self):
        """Gets the notes of this DSRule.  # noqa: E501

        User notes specific to the rule.  # noqa: E501

        :return: The notes of this DSRule.  # noqa: E501
        :rtype: str
        """
        return self._notes

    @notes.setter
    def notes(self, notes):
        """Sets the notes of this DSRule.

        User notes specific to the rule.  # noqa: E501

        :param notes: The notes of this DSRule.  # noqa: E501
        :type: str
        """

        self._notes = notes

    @property
    def applied_tos(self):
        """Gets the applied_tos of this DSRule.  # noqa: E501

        List of object where rule will be enforced. The section level field overrides this one. Null will be treated as any.  # noqa: E501

        :return: The applied_tos of this DSRule.  # noqa: E501
        :rtype: list[ResourceReference]
        """
        return self._applied_tos

    @applied_tos.setter
    def applied_tos(self, applied_tos):
        """Sets the applied_tos of this DSRule.

        List of object where rule will be enforced. The section level field overrides this one. Null will be treated as any.  # noqa: E501

        :param applied_tos: The applied_tos of this DSRule.  # noqa: E501
        :type: list[ResourceReference]
        """

        self._applied_tos = applied_tos

    @property
    def logged(self):
        """Gets the logged of this DSRule.  # noqa: E501

        Flag to enable packet logging. Default is disabled.  # noqa: E501

        :return: The logged of this DSRule.  # noqa: E501
        :rtype: bool
        """
        return self._logged

    @logged.setter
    def logged(self, logged):
        """Sets the logged of this DSRule.

        Flag to enable packet logging. Default is disabled.  # noqa: E501

        :param logged: The logged of this DSRule.  # noqa: E501
        :type: bool
        """

        self._logged = logged

    @property
    def disabled(self):
        """Gets the disabled of this DSRule.  # noqa: E501

        Flag to disable rule. Disabled will only be persisted but never provisioned/realized.  # noqa: E501

        :return: The disabled of this DSRule.  # noqa: E501
        :rtype: bool
        """
        return self._disabled

    @disabled.setter
    def disabled(self, disabled):
        """Sets the disabled of this DSRule.

        Flag to disable rule. Disabled will only be persisted but never provisioned/realized.  # noqa: E501

        :param disabled: The disabled of this DSRule.  # noqa: E501
        :type: bool
        """

        self._disabled = disabled

    @property
    def sources(self):
        """Gets the sources of this DSRule.  # noqa: E501

        List of sources. Null will be treated as any.  # noqa: E501

        :return: The sources of this DSRule.  # noqa: E501
        :rtype: list[ResourceReference]
        """
        return self._sources

    @sources.setter
    def sources(self, sources):
        """Sets the sources of this DSRule.

        List of sources. Null will be treated as any.  # noqa: E501

        :param sources: The sources of this DSRule.  # noqa: E501
        :type: list[ResourceReference]
        """

        self._sources = sources

    @property
    def action(self):
        """Gets the action of this DSRule.  # noqa: E501

        Action enforced on the packets which matches the distributed service rule. Currently DS Layer supports below actions. ALLOW           - Forward any packet when a rule with this action gets a match (Used by Firewall). DROP            - Drop any packet when a rule with this action gets a match. Packets won't go further(Used by Firewall). REJECT          - Terminate TCP connection by sending TCP reset for a packet when a rule with this action gets a match (Used by Firewall). REDIRECT        - Redirect any packet to a partner appliance when a rule with this action gets a match (Used by Service Insertion). DO_NOT_REDIRECT - Do not redirect any packet to a partner appliance when a rule with this action gets a match (Used by Service Insertion). DETECT          - Detect IDS Signatures. ALLOW_CONTINUE  - Allows rules to jump from this rule. Action on matching rules in the destination category will decide next step. Application is default destination until new categories are supported to jump to. DETECT_PREVENT  - Detect and Prevent IDS Signatures.  # noqa: E501

        :return: The action of this DSRule.  # noqa: E501
        :rtype: str
        """
        return self._action

    @action.setter
    def action(self, action):
        """Sets the action of this DSRule.

        Action enforced on the packets which matches the distributed service rule. Currently DS Layer supports below actions. ALLOW           - Forward any packet when a rule with this action gets a match (Used by Firewall). DROP            - Drop any packet when a rule with this action gets a match. Packets won't go further(Used by Firewall). REJECT          - Terminate TCP connection by sending TCP reset for a packet when a rule with this action gets a match (Used by Firewall). REDIRECT        - Redirect any packet to a partner appliance when a rule with this action gets a match (Used by Service Insertion). DO_NOT_REDIRECT - Do not redirect any packet to a partner appliance when a rule with this action gets a match (Used by Service Insertion). DETECT          - Detect IDS Signatures. ALLOW_CONTINUE  - Allows rules to jump from this rule. Action on matching rules in the destination category will decide next step. Application is default destination until new categories are supported to jump to. DETECT_PREVENT  - Detect and Prevent IDS Signatures.  # noqa: E501

        :param action: The action of this DSRule.  # noqa: E501
        :type: str
        """
        if action is None:
            raise ValueError("Invalid value for `action`, must not be `None`")  # noqa: E501
        allowed_values = ["ALLOW", "DROP", "REJECT", "REDIRECT", "DO_NOT_REDIRECT", "DETECT", "ALLOW_CONTINUE", "DETECT_PREVENT"]  # noqa: E501
        if action not in allowed_values:
            raise ValueError(
                "Invalid value for `action` ({0}), must be one of {1}"  # noqa: E501
                .format(action, allowed_values)
            )

        self._action = action

    @property
    def priority(self):
        """Gets the priority of this DSRule.  # noqa: E501

        Priority of the rule.  # noqa: E501

        :return: The priority of this DSRule.  # noqa: E501
        :rtype: int
        """
        return self._priority

    @priority.setter
    def priority(self, priority):
        """Sets the priority of this DSRule.

        Priority of the rule.  # noqa: E501

        :param priority: The priority of this DSRule.  # noqa: E501
        :type: int
        """

        self._priority = priority

    @property
    def sources_excluded(self):
        """Gets the sources_excluded of this DSRule.  # noqa: E501

        Negation of the source.  # noqa: E501

        :return: The sources_excluded of this DSRule.  # noqa: E501
        :rtype: bool
        """
        return self._sources_excluded

    @sources_excluded.setter
    def sources_excluded(self, sources_excluded):
        """Sets the sources_excluded of this DSRule.

        Negation of the source.  # noqa: E501

        :param sources_excluded: The sources_excluded of this DSRule.  # noqa: E501
        :type: bool
        """

        self._sources_excluded = sources_excluded

    @property
    def destinations_excluded(self):
        """Gets the destinations_excluded of this DSRule.  # noqa: E501

        Negation of the destination.  # noqa: E501

        :return: The destinations_excluded of this DSRule.  # noqa: E501
        :rtype: bool
        """
        return self._destinations_excluded

    @destinations_excluded.setter
    def destinations_excluded(self, destinations_excluded):
        """Sets the destinations_excluded of this DSRule.

        Negation of the destination.  # noqa: E501

        :param destinations_excluded: The destinations_excluded of this DSRule.  # noqa: E501
        :type: bool
        """

        self._destinations_excluded = destinations_excluded

    @property
    def destinations(self):
        """Gets the destinations of this DSRule.  # noqa: E501

        List of the destinations. Null will be treated as any.  # noqa: E501

        :return: The destinations of this DSRule.  # noqa: E501
        :rtype: list[ResourceReference]
        """
        return self._destinations

    @destinations.setter
    def destinations(self, destinations):
        """Sets the destinations of this DSRule.

        List of the destinations. Null will be treated as any.  # noqa: E501

        :param destinations: The destinations of this DSRule.  # noqa: E501
        :type: list[ResourceReference]
        """

        self._destinations = destinations

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(DSRule, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DSRule):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
