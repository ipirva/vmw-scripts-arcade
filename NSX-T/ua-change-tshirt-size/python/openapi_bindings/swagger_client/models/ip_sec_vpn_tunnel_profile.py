# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.managed_resource import ManagedResource  # noqa: F401,E501

class IPSecVPNTunnelProfile(ManagedResource):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'encapsulation_mode': 'str',
        'transform_protocol': 'str',
        'digest_algorithms': 'list[str]',
        'encryption_algorithms': 'list[str]',
        'enable_perfect_forward_secrecy': 'bool',
        'dh_groups': 'list[str]',
        'df_policy': 'str',
        'sa_life_time': 'int'
    }
    if hasattr(ManagedResource, "swagger_types"):
        swagger_types.update(ManagedResource.swagger_types)

    attribute_map = {
        'encapsulation_mode': 'encapsulation_mode',
        'transform_protocol': 'transform_protocol',
        'digest_algorithms': 'digest_algorithms',
        'encryption_algorithms': 'encryption_algorithms',
        'enable_perfect_forward_secrecy': 'enable_perfect_forward_secrecy',
        'dh_groups': 'dh_groups',
        'df_policy': 'df_policy',
        'sa_life_time': 'sa_life_time'
    }
    if hasattr(ManagedResource, "attribute_map"):
        attribute_map.update(ManagedResource.attribute_map)

    def __init__(self, encapsulation_mode='TUNNEL_MODE', transform_protocol='ESP', digest_algorithms=None, encryption_algorithms=None, enable_perfect_forward_secrecy=True, dh_groups=None, df_policy='COPY', sa_life_time=3600, *args, **kwargs):  # noqa: E501
        """IPSecVPNTunnelProfile - a model defined in Swagger"""  # noqa: E501
        self._encapsulation_mode = None
        self._transform_protocol = None
        self._digest_algorithms = None
        self._encryption_algorithms = None
        self._enable_perfect_forward_secrecy = None
        self._dh_groups = None
        self._df_policy = None
        self._sa_life_time = None
        self.discriminator = None
        if encapsulation_mode is not None:
            self.encapsulation_mode = encapsulation_mode
        if transform_protocol is not None:
            self.transform_protocol = transform_protocol
        if digest_algorithms is not None:
            self.digest_algorithms = digest_algorithms
        if encryption_algorithms is not None:
            self.encryption_algorithms = encryption_algorithms
        if enable_perfect_forward_secrecy is not None:
            self.enable_perfect_forward_secrecy = enable_perfect_forward_secrecy
        if dh_groups is not None:
            self.dh_groups = dh_groups
        if df_policy is not None:
            self.df_policy = df_policy
        if sa_life_time is not None:
            self.sa_life_time = sa_life_time
        ManagedResource.__init__(self, *args, **kwargs)

    @property
    def encapsulation_mode(self):
        """Gets the encapsulation_mode of this IPSecVPNTunnelProfile.  # noqa: E501

        Encapsulation Mode to be used for encryption of packet. Tunnel mode protects internal routing information by encrypting IP header of original packet.  # noqa: E501

        :return: The encapsulation_mode of this IPSecVPNTunnelProfile.  # noqa: E501
        :rtype: str
        """
        return self._encapsulation_mode

    @encapsulation_mode.setter
    def encapsulation_mode(self, encapsulation_mode):
        """Sets the encapsulation_mode of this IPSecVPNTunnelProfile.

        Encapsulation Mode to be used for encryption of packet. Tunnel mode protects internal routing information by encrypting IP header of original packet.  # noqa: E501

        :param encapsulation_mode: The encapsulation_mode of this IPSecVPNTunnelProfile.  # noqa: E501
        :type: str
        """
        allowed_values = ["TUNNEL_MODE"]  # noqa: E501
        if encapsulation_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `encapsulation_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(encapsulation_mode, allowed_values)
            )

        self._encapsulation_mode = encapsulation_mode

    @property
    def transform_protocol(self):
        """Gets the transform_protocol of this IPSecVPNTunnelProfile.  # noqa: E501

        IPSec transform specifies IPSec security protocol.  # noqa: E501

        :return: The transform_protocol of this IPSecVPNTunnelProfile.  # noqa: E501
        :rtype: str
        """
        return self._transform_protocol

    @transform_protocol.setter
    def transform_protocol(self, transform_protocol):
        """Sets the transform_protocol of this IPSecVPNTunnelProfile.

        IPSec transform specifies IPSec security protocol.  # noqa: E501

        :param transform_protocol: The transform_protocol of this IPSecVPNTunnelProfile.  # noqa: E501
        :type: str
        """
        allowed_values = ["ESP"]  # noqa: E501
        if transform_protocol not in allowed_values:
            raise ValueError(
                "Invalid value for `transform_protocol` ({0}), must be one of {1}"  # noqa: E501
                .format(transform_protocol, allowed_values)
            )

        self._transform_protocol = transform_protocol

    @property
    def digest_algorithms(self):
        """Gets the digest_algorithms of this IPSecVPNTunnelProfile.  # noqa: E501

        Algorithm to be used for message digest. Default digest algorithm is implicitly covered by default encryption algorithm \"AES_GCM_128\".  # noqa: E501

        :return: The digest_algorithms of this IPSecVPNTunnelProfile.  # noqa: E501
        :rtype: list[str]
        """
        return self._digest_algorithms

    @digest_algorithms.setter
    def digest_algorithms(self, digest_algorithms):
        """Sets the digest_algorithms of this IPSecVPNTunnelProfile.

        Algorithm to be used for message digest. Default digest algorithm is implicitly covered by default encryption algorithm \"AES_GCM_128\".  # noqa: E501

        :param digest_algorithms: The digest_algorithms of this IPSecVPNTunnelProfile.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["SHA1", "SHA2_256", "SHA2_384", "SHA2_512"]  # noqa: E501
        if not set(digest_algorithms).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `digest_algorithms` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(digest_algorithms) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._digest_algorithms = digest_algorithms

    @property
    def encryption_algorithms(self):
        """Gets the encryption_algorithms of this IPSecVPNTunnelProfile.  # noqa: E501

        Encryption algorithm to encrypt/decrypt the messages exchanged between IPSec VPN initiator and responder during tunnel negotiation. Default is AES_GCM_128.  # noqa: E501

        :return: The encryption_algorithms of this IPSecVPNTunnelProfile.  # noqa: E501
        :rtype: list[str]
        """
        return self._encryption_algorithms

    @encryption_algorithms.setter
    def encryption_algorithms(self, encryption_algorithms):
        """Sets the encryption_algorithms of this IPSecVPNTunnelProfile.

        Encryption algorithm to encrypt/decrypt the messages exchanged between IPSec VPN initiator and responder during tunnel negotiation. Default is AES_GCM_128.  # noqa: E501

        :param encryption_algorithms: The encryption_algorithms of this IPSecVPNTunnelProfile.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["AES_128", "AES_256", "AES_GCM_128", "AES_GCM_192", "AES_GCM_256", "NO_ENCRYPTION_AUTH_AES_GMAC_128", "NO_ENCRYPTION_AUTH_AES_GMAC_192", "NO_ENCRYPTION_AUTH_AES_GMAC_256", "NO_ENCRYPTION"]  # noqa: E501
        if not set(encryption_algorithms).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `encryption_algorithms` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(encryption_algorithms) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._encryption_algorithms = encryption_algorithms

    @property
    def enable_perfect_forward_secrecy(self):
        """Gets the enable_perfect_forward_secrecy of this IPSecVPNTunnelProfile.  # noqa: E501

        If true, perfect forward secrecy (PFS) is enabled.  # noqa: E501

        :return: The enable_perfect_forward_secrecy of this IPSecVPNTunnelProfile.  # noqa: E501
        :rtype: bool
        """
        return self._enable_perfect_forward_secrecy

    @enable_perfect_forward_secrecy.setter
    def enable_perfect_forward_secrecy(self, enable_perfect_forward_secrecy):
        """Sets the enable_perfect_forward_secrecy of this IPSecVPNTunnelProfile.

        If true, perfect forward secrecy (PFS) is enabled.  # noqa: E501

        :param enable_perfect_forward_secrecy: The enable_perfect_forward_secrecy of this IPSecVPNTunnelProfile.  # noqa: E501
        :type: bool
        """

        self._enable_perfect_forward_secrecy = enable_perfect_forward_secrecy

    @property
    def dh_groups(self):
        """Gets the dh_groups of this IPSecVPNTunnelProfile.  # noqa: E501

        Diffie-Hellman group to be used if PFS is enabled. Default is GROUP14.  # noqa: E501

        :return: The dh_groups of this IPSecVPNTunnelProfile.  # noqa: E501
        :rtype: list[str]
        """
        return self._dh_groups

    @dh_groups.setter
    def dh_groups(self, dh_groups):
        """Sets the dh_groups of this IPSecVPNTunnelProfile.

        Diffie-Hellman group to be used if PFS is enabled. Default is GROUP14.  # noqa: E501

        :param dh_groups: The dh_groups of this IPSecVPNTunnelProfile.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["GROUP2", "GROUP5", "GROUP14", "GROUP15", "GROUP16", "GROUP19", "GROUP20", "GROUP21"]  # noqa: E501
        if not set(dh_groups).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `dh_groups` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(dh_groups) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._dh_groups = dh_groups

    @property
    def df_policy(self):
        """Gets the df_policy of this IPSecVPNTunnelProfile.  # noqa: E501

        Defragmentation policy helps to handle defragmentation bit present in the inner packet. COPY copies the defragmentation bit from the inner IP packet into the outer packet. CLEAR ignores the defragmentation bit present in the inner packet.  # noqa: E501

        :return: The df_policy of this IPSecVPNTunnelProfile.  # noqa: E501
        :rtype: str
        """
        return self._df_policy

    @df_policy.setter
    def df_policy(self, df_policy):
        """Sets the df_policy of this IPSecVPNTunnelProfile.

        Defragmentation policy helps to handle defragmentation bit present in the inner packet. COPY copies the defragmentation bit from the inner IP packet into the outer packet. CLEAR ignores the defragmentation bit present in the inner packet.  # noqa: E501

        :param df_policy: The df_policy of this IPSecVPNTunnelProfile.  # noqa: E501
        :type: str
        """
        allowed_values = ["COPY", "CLEAR"]  # noqa: E501
        if df_policy not in allowed_values:
            raise ValueError(
                "Invalid value for `df_policy` ({0}), must be one of {1}"  # noqa: E501
                .format(df_policy, allowed_values)
            )

        self._df_policy = df_policy

    @property
    def sa_life_time(self):
        """Gets the sa_life_time of this IPSecVPNTunnelProfile.  # noqa: E501

        SA life time specifies the expiry time of security association. Default is 3600 seconds.   # noqa: E501

        :return: The sa_life_time of this IPSecVPNTunnelProfile.  # noqa: E501
        :rtype: int
        """
        return self._sa_life_time

    @sa_life_time.setter
    def sa_life_time(self, sa_life_time):
        """Sets the sa_life_time of this IPSecVPNTunnelProfile.

        SA life time specifies the expiry time of security association. Default is 3600 seconds.   # noqa: E501

        :param sa_life_time: The sa_life_time of this IPSecVPNTunnelProfile.  # noqa: E501
        :type: int
        """

        self._sa_life_time = sa_life_time

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(IPSecVPNTunnelProfile, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IPSecVPNTunnelProfile):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
