# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class NodeStatus(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'mpa_connectivity_status': 'str',
        'lcp_connectivity_status_details': 'list[ControlConnStatus]',
        'mpa_connectivity_status_details': 'str',
        'external_id': 'str',
        'software_version': 'str',
        'maintenance_mode': 'str',
        'inventory_sync_paused': 'bool',
        'system_status': 'NodeStatusProperties',
        'inventory_sync_reenable_time': 'int',
        'lcp_connectivity_status': 'str',
        'last_heartbeat_timestamp': 'int',
        'last_sync_time': 'int',
        'host_node_deployment_status': 'str'
    }

    attribute_map = {
        'mpa_connectivity_status': 'mpa_connectivity_status',
        'lcp_connectivity_status_details': 'lcp_connectivity_status_details',
        'mpa_connectivity_status_details': 'mpa_connectivity_status_details',
        'external_id': 'external_id',
        'software_version': 'software_version',
        'maintenance_mode': 'maintenance_mode',
        'inventory_sync_paused': 'inventory_sync_paused',
        'system_status': 'system_status',
        'inventory_sync_reenable_time': 'inventory_sync_reenable_time',
        'lcp_connectivity_status': 'lcp_connectivity_status',
        'last_heartbeat_timestamp': 'last_heartbeat_timestamp',
        'last_sync_time': 'last_sync_time',
        'host_node_deployment_status': 'host_node_deployment_status'
    }

    def __init__(self, mpa_connectivity_status=None, lcp_connectivity_status_details=None, mpa_connectivity_status_details=None, external_id=None, software_version=None, maintenance_mode=None, inventory_sync_paused=None, system_status=None, inventory_sync_reenable_time=None, lcp_connectivity_status='UNKNOWN', last_heartbeat_timestamp=None, last_sync_time=None, host_node_deployment_status=None):  # noqa: E501
        """NodeStatus - a model defined in Swagger"""  # noqa: E501
        self._mpa_connectivity_status = None
        self._lcp_connectivity_status_details = None
        self._mpa_connectivity_status_details = None
        self._external_id = None
        self._software_version = None
        self._maintenance_mode = None
        self._inventory_sync_paused = None
        self._system_status = None
        self._inventory_sync_reenable_time = None
        self._lcp_connectivity_status = None
        self._last_heartbeat_timestamp = None
        self._last_sync_time = None
        self._host_node_deployment_status = None
        self.discriminator = None
        if mpa_connectivity_status is not None:
            self.mpa_connectivity_status = mpa_connectivity_status
        if lcp_connectivity_status_details is not None:
            self.lcp_connectivity_status_details = lcp_connectivity_status_details
        if mpa_connectivity_status_details is not None:
            self.mpa_connectivity_status_details = mpa_connectivity_status_details
        if external_id is not None:
            self.external_id = external_id
        if software_version is not None:
            self.software_version = software_version
        if maintenance_mode is not None:
            self.maintenance_mode = maintenance_mode
        if inventory_sync_paused is not None:
            self.inventory_sync_paused = inventory_sync_paused
        if system_status is not None:
            self.system_status = system_status
        if inventory_sync_reenable_time is not None:
            self.inventory_sync_reenable_time = inventory_sync_reenable_time
        if lcp_connectivity_status is not None:
            self.lcp_connectivity_status = lcp_connectivity_status
        if last_heartbeat_timestamp is not None:
            self.last_heartbeat_timestamp = last_heartbeat_timestamp
        if last_sync_time is not None:
            self.last_sync_time = last_sync_time
        if host_node_deployment_status is not None:
            self.host_node_deployment_status = host_node_deployment_status

    @property
    def mpa_connectivity_status(self):
        """Gets the mpa_connectivity_status of this NodeStatus.  # noqa: E501

        Indicates the fabric node's MP&lt;-&gt;MPA channel connectivity status, UP, DOWN, UNKNOWN.  # noqa: E501

        :return: The mpa_connectivity_status of this NodeStatus.  # noqa: E501
        :rtype: str
        """
        return self._mpa_connectivity_status

    @mpa_connectivity_status.setter
    def mpa_connectivity_status(self, mpa_connectivity_status):
        """Sets the mpa_connectivity_status of this NodeStatus.

        Indicates the fabric node's MP&lt;-&gt;MPA channel connectivity status, UP, DOWN, UNKNOWN.  # noqa: E501

        :param mpa_connectivity_status: The mpa_connectivity_status of this NodeStatus.  # noqa: E501
        :type: str
        """
        allowed_values = ["UP", "DOWN", "UNKNOWN"]  # noqa: E501
        if mpa_connectivity_status not in allowed_values:
            raise ValueError(
                "Invalid value for `mpa_connectivity_status` ({0}), must be one of {1}"  # noqa: E501
                .format(mpa_connectivity_status, allowed_values)
            )

        self._mpa_connectivity_status = mpa_connectivity_status

    @property
    def lcp_connectivity_status_details(self):
        """Gets the lcp_connectivity_status_details of this NodeStatus.  # noqa: E501

        Details, if any, about the current LCP&lt;-&gt;CCP channel connectivity status of the fabric node.  # noqa: E501

        :return: The lcp_connectivity_status_details of this NodeStatus.  # noqa: E501
        :rtype: list[ControlConnStatus]
        """
        return self._lcp_connectivity_status_details

    @lcp_connectivity_status_details.setter
    def lcp_connectivity_status_details(self, lcp_connectivity_status_details):
        """Sets the lcp_connectivity_status_details of this NodeStatus.

        Details, if any, about the current LCP&lt;-&gt;CCP channel connectivity status of the fabric node.  # noqa: E501

        :param lcp_connectivity_status_details: The lcp_connectivity_status_details of this NodeStatus.  # noqa: E501
        :type: list[ControlConnStatus]
        """

        self._lcp_connectivity_status_details = lcp_connectivity_status_details

    @property
    def mpa_connectivity_status_details(self):
        """Gets the mpa_connectivity_status_details of this NodeStatus.  # noqa: E501

        Details, if any, about the current MP&lt;-&gt;MPA channel connectivity status of the fabric node.  # noqa: E501

        :return: The mpa_connectivity_status_details of this NodeStatus.  # noqa: E501
        :rtype: str
        """
        return self._mpa_connectivity_status_details

    @mpa_connectivity_status_details.setter
    def mpa_connectivity_status_details(self, mpa_connectivity_status_details):
        """Sets the mpa_connectivity_status_details of this NodeStatus.

        Details, if any, about the current MP&lt;-&gt;MPA channel connectivity status of the fabric node.  # noqa: E501

        :param mpa_connectivity_status_details: The mpa_connectivity_status_details of this NodeStatus.  # noqa: E501
        :type: str
        """

        self._mpa_connectivity_status_details = mpa_connectivity_status_details

    @property
    def external_id(self):
        """Gets the external_id of this NodeStatus.  # noqa: E501

        HostNode external id  # noqa: E501

        :return: The external_id of this NodeStatus.  # noqa: E501
        :rtype: str
        """
        return self._external_id

    @external_id.setter
    def external_id(self, external_id):
        """Sets the external_id of this NodeStatus.

        HostNode external id  # noqa: E501

        :param external_id: The external_id of this NodeStatus.  # noqa: E501
        :type: str
        """

        self._external_id = external_id

    @property
    def software_version(self):
        """Gets the software_version of this NodeStatus.  # noqa: E501

        Software version of the fabric node.  # noqa: E501

        :return: The software_version of this NodeStatus.  # noqa: E501
        :rtype: str
        """
        return self._software_version

    @software_version.setter
    def software_version(self, software_version):
        """Sets the software_version of this NodeStatus.

        Software version of the fabric node.  # noqa: E501

        :param software_version: The software_version of this NodeStatus.  # noqa: E501
        :type: str
        """

        self._software_version = software_version

    @property
    def maintenance_mode(self):
        """Gets the maintenance_mode of this NodeStatus.  # noqa: E501

        Indicates the fabric node's status of maintenance mode, OFF, ENTERING, ON, EXITING.  # noqa: E501

        :return: The maintenance_mode of this NodeStatus.  # noqa: E501
        :rtype: str
        """
        return self._maintenance_mode

    @maintenance_mode.setter
    def maintenance_mode(self, maintenance_mode):
        """Sets the maintenance_mode of this NodeStatus.

        Indicates the fabric node's status of maintenance mode, OFF, ENTERING, ON, EXITING.  # noqa: E501

        :param maintenance_mode: The maintenance_mode of this NodeStatus.  # noqa: E501
        :type: str
        """
        allowed_values = ["OFF", "ENTERING", "ON", "EXITING"]  # noqa: E501
        if maintenance_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `maintenance_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(maintenance_mode, allowed_values)
            )

        self._maintenance_mode = maintenance_mode

    @property
    def inventory_sync_paused(self):
        """Gets the inventory_sync_paused of this NodeStatus.  # noqa: E501

        Is true if inventory sync is paused else false  # noqa: E501

        :return: The inventory_sync_paused of this NodeStatus.  # noqa: E501
        :rtype: bool
        """
        return self._inventory_sync_paused

    @inventory_sync_paused.setter
    def inventory_sync_paused(self, inventory_sync_paused):
        """Sets the inventory_sync_paused of this NodeStatus.

        Is true if inventory sync is paused else false  # noqa: E501

        :param inventory_sync_paused: The inventory_sync_paused of this NodeStatus.  # noqa: E501
        :type: bool
        """

        self._inventory_sync_paused = inventory_sync_paused

    @property
    def system_status(self):
        """Gets the system_status of this NodeStatus.  # noqa: E501


        :return: The system_status of this NodeStatus.  # noqa: E501
        :rtype: NodeStatusProperties
        """
        return self._system_status

    @system_status.setter
    def system_status(self, system_status):
        """Sets the system_status of this NodeStatus.


        :param system_status: The system_status of this NodeStatus.  # noqa: E501
        :type: NodeStatusProperties
        """

        self._system_status = system_status

    @property
    def inventory_sync_reenable_time(self):
        """Gets the inventory_sync_reenable_time of this NodeStatus.  # noqa: E501

        Inventory sync auto re-enable target time, in epoch milis  # noqa: E501

        :return: The inventory_sync_reenable_time of this NodeStatus.  # noqa: E501
        :rtype: int
        """
        return self._inventory_sync_reenable_time

    @inventory_sync_reenable_time.setter
    def inventory_sync_reenable_time(self, inventory_sync_reenable_time):
        """Sets the inventory_sync_reenable_time of this NodeStatus.

        Inventory sync auto re-enable target time, in epoch milis  # noqa: E501

        :param inventory_sync_reenable_time: The inventory_sync_reenable_time of this NodeStatus.  # noqa: E501
        :type: int
        """

        self._inventory_sync_reenable_time = inventory_sync_reenable_time

    @property
    def lcp_connectivity_status(self):
        """Gets the lcp_connectivity_status of this NodeStatus.  # noqa: E501

        Indicates the fabric node's LCP&lt;-&gt;CCP channel connectivity status, UP, DOWN, DEGRADED, UNKNOWN.  # noqa: E501

        :return: The lcp_connectivity_status of this NodeStatus.  # noqa: E501
        :rtype: str
        """
        return self._lcp_connectivity_status

    @lcp_connectivity_status.setter
    def lcp_connectivity_status(self, lcp_connectivity_status):
        """Sets the lcp_connectivity_status of this NodeStatus.

        Indicates the fabric node's LCP&lt;-&gt;CCP channel connectivity status, UP, DOWN, DEGRADED, UNKNOWN.  # noqa: E501

        :param lcp_connectivity_status: The lcp_connectivity_status of this NodeStatus.  # noqa: E501
        :type: str
        """
        allowed_values = ["UP", "DOWN", "DEGRADED", "UNKNOWN"]  # noqa: E501
        if lcp_connectivity_status not in allowed_values:
            raise ValueError(
                "Invalid value for `lcp_connectivity_status` ({0}), must be one of {1}"  # noqa: E501
                .format(lcp_connectivity_status, allowed_values)
            )

        self._lcp_connectivity_status = lcp_connectivity_status

    @property
    def last_heartbeat_timestamp(self):
        """Gets the last_heartbeat_timestamp of this NodeStatus.  # noqa: E501

        Timestamp of the last heartbeat status change, in epoch milliseconds.  # noqa: E501

        :return: The last_heartbeat_timestamp of this NodeStatus.  # noqa: E501
        :rtype: int
        """
        return self._last_heartbeat_timestamp

    @last_heartbeat_timestamp.setter
    def last_heartbeat_timestamp(self, last_heartbeat_timestamp):
        """Sets the last_heartbeat_timestamp of this NodeStatus.

        Timestamp of the last heartbeat status change, in epoch milliseconds.  # noqa: E501

        :param last_heartbeat_timestamp: The last_heartbeat_timestamp of this NodeStatus.  # noqa: E501
        :type: int
        """

        self._last_heartbeat_timestamp = last_heartbeat_timestamp

    @property
    def last_sync_time(self):
        """Gets the last_sync_time of this NodeStatus.  # noqa: E501

        Timestamp of the last successful update of Inventory, in epoch milliseconds.  # noqa: E501

        :return: The last_sync_time of this NodeStatus.  # noqa: E501
        :rtype: int
        """
        return self._last_sync_time

    @last_sync_time.setter
    def last_sync_time(self, last_sync_time):
        """Sets the last_sync_time of this NodeStatus.

        Timestamp of the last successful update of Inventory, in epoch milliseconds.  # noqa: E501

        :param last_sync_time: The last_sync_time of this NodeStatus.  # noqa: E501
        :type: int
        """

        self._last_sync_time = last_sync_time

    @property
    def host_node_deployment_status(self):
        """Gets the host_node_deployment_status of this NodeStatus.  # noqa: E501

        This enum specifies the current nsx install state for host node or current deployment and ready state for edge node. The ready status 'NODE_READY' indicates whether edge node is ready to become a transport node. The status 'EDGE_CONFIG_ERROR' indicates that edge hardware or underlying host is not supported. After all fabric level operations are done for an edge node, this value indicates transport node related configuration issues and state as relevant.   # noqa: E501

        :return: The host_node_deployment_status of this NodeStatus.  # noqa: E501
        :rtype: str
        """
        return self._host_node_deployment_status

    @host_node_deployment_status.setter
    def host_node_deployment_status(self, host_node_deployment_status):
        """Sets the host_node_deployment_status of this NodeStatus.

        This enum specifies the current nsx install state for host node or current deployment and ready state for edge node. The ready status 'NODE_READY' indicates whether edge node is ready to become a transport node. The status 'EDGE_CONFIG_ERROR' indicates that edge hardware or underlying host is not supported. After all fabric level operations are done for an edge node, this value indicates transport node related configuration issues and state as relevant.   # noqa: E501

        :param host_node_deployment_status: The host_node_deployment_status of this NodeStatus.  # noqa: E501
        :type: str
        """
        allowed_values = ["NOT_PREPARED", "INSTALL_IN_PROGRESS", "INSTALL_FAILED", "INSTALL_SUCCESSFUL", "INSTALL_SKIPPED", "UNINSTALL_IN_PROGRESS", "UNINSTALL_FAILED", "UNINSTALL_SUCCESSFUL", "UNINSTALL_SCHEDULED", "UNINSTALL_SKIPPED", "UPGRADE_IN_PROGRESS", "UPGRADE_FAILED", "PENDING_UPGRADE", "NOT_AVAILABLE", "VM_DEPLOYMENT_QUEUED", "VM_DEPLOYMENT_IN_PROGRESS", "VM_DEPLOYMENT_FAILED", "VM_POWER_ON_IN_PROGRESS", "VM_POWER_ON_FAILED", "REGISTRATION_PENDING", "NODE_NOT_READY", "NODE_READY", "VM_POWER_OFF_IN_PROGRESS", "VM_POWER_OFF_FAILED", "VM_UNDEPLOY_IN_PROGRESS", "VM_UNDEPLOY_FAILED", "VM_UNDEPLOY_SUCCESSFUL", "EDGE_CONFIG_ERROR", "VM_DEPLOYMENT_RESTARTED", "REGISTRATION_FAILED", "HOST_DISCONNECTED", "POWERED_OFF", "TRANSPORT_NODE_SYNC_PENDING", "TRANSPORT_NODE_CONFIGURATION_MISSING", "EDGE_HARDWARE_NOT_SUPPORTED", "MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED", "TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER", "TZ_ENDPOINTS_NOT_SPECIFIED", "NO_PNIC_PREPARED_IN_EDGE", "APPLIANCE_INTERNAL_ERROR", "VTEP_DHCP_NOT_SUPPORTED", "UNSUPPORTED_HOST_SWITCH_PROFILE", "UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED", "HOSTSWITCH_PROFILE_NOT_FOUND", "LLDP_SEND_ENABLED_NOT_SUPPORTED", "UNSUPPORTED_NAMED_TEAMING_POLICY", "MULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING", "LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM", "LACP_NOT_SUPPORTED_FOR_EDGE_VM", "STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM", "MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE", "UNSUPPORTED_LACP_LB_ALGO_FOR_NODE", "EDGE_NODE_VERSION_NOT_SUPPORTED", "NO_PNIC_SPECIFIED_IN_TN", "INVALID_PNIC_DEVICE_NAME", "TRANSPORT_NODE_READY", "UNSUPPORTED_DEFAULT_TEAMING_POLICY", "MPA_DISCONNECTED", "VM_NETWORK_EDIT_PENDING", "VM_RENAME_PENDING", "VM_CONFIG_EDIT_PENDING", "VM_NETWORK_EDIT_FAILED", "VM_RENAME_FAILED", "VM_CONFIG_EDIT_FAILED", "VM_CONFIG_DISCREPANCY", "VM_NODE_REFRESH_FAILED", "VM_PLACEMENT_REFRESH_FAILED", "REGISTRATION_TIMEDOUT", "LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING", "UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED", "REPLACE_FAILED", "DELETE_VM_IN_REDEPLOY_FAILED", "DEPLOY_VM_IN_REDEPLOY_FAILED", "INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE"]  # noqa: E501
        if host_node_deployment_status not in allowed_values:
            raise ValueError(
                "Invalid value for `host_node_deployment_status` ({0}), must be one of {1}"  # noqa: E501
                .format(host_node_deployment_status, allowed_values)
            )

        self._host_node_deployment_status = host_node_deployment_status

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(NodeStatus, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, NodeStatus):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
