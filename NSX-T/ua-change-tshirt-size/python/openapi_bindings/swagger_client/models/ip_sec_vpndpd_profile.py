# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.managed_resource import ManagedResource  # noqa: F401,E501

class IPSecVPNDPDProfile(ManagedResource):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'retry_count': 'int',
        'enabled': 'bool',
        'dpd_probe_mode': 'str',
        'dpd_probe_interval': 'int'
    }
    if hasattr(ManagedResource, "swagger_types"):
        swagger_types.update(ManagedResource.swagger_types)

    attribute_map = {
        'retry_count': 'retry_count',
        'enabled': 'enabled',
        'dpd_probe_mode': 'dpd_probe_mode',
        'dpd_probe_interval': 'dpd_probe_interval'
    }
    if hasattr(ManagedResource, "attribute_map"):
        attribute_map.update(ManagedResource.attribute_map)

    def __init__(self, retry_count=5, enabled=True, dpd_probe_mode='PERIODIC', dpd_probe_interval=None, *args, **kwargs):  # noqa: E501
        """IPSecVPNDPDProfile - a model defined in Swagger"""  # noqa: E501
        self._retry_count = None
        self._enabled = None
        self._dpd_probe_mode = None
        self._dpd_probe_interval = None
        self.discriminator = None
        if retry_count is not None:
            self.retry_count = retry_count
        if enabled is not None:
            self.enabled = enabled
        if dpd_probe_mode is not None:
            self.dpd_probe_mode = dpd_probe_mode
        if dpd_probe_interval is not None:
            self.dpd_probe_interval = dpd_probe_interval
        ManagedResource.__init__(self, *args, **kwargs)

    @property
    def retry_count(self):
        """Gets the retry_count of this IPSecVPNDPDProfile.  # noqa: E501

        Maximum number of DPD messages retry attempts. This value is applicable for both dpd probe modes, periodic and on-demand.  # noqa: E501

        :return: The retry_count of this IPSecVPNDPDProfile.  # noqa: E501
        :rtype: int
        """
        return self._retry_count

    @retry_count.setter
    def retry_count(self, retry_count):
        """Sets the retry_count of this IPSecVPNDPDProfile.

        Maximum number of DPD messages retry attempts. This value is applicable for both dpd probe modes, periodic and on-demand.  # noqa: E501

        :param retry_count: The retry_count of this IPSecVPNDPDProfile.  # noqa: E501
        :type: int
        """

        self._retry_count = retry_count

    @property
    def enabled(self):
        """Gets the enabled of this IPSecVPNDPDProfile.  # noqa: E501

        If true, enable dead peer detection.  # noqa: E501

        :return: The enabled of this IPSecVPNDPDProfile.  # noqa: E501
        :rtype: bool
        """
        return self._enabled

    @enabled.setter
    def enabled(self, enabled):
        """Sets the enabled of this IPSecVPNDPDProfile.

        If true, enable dead peer detection.  # noqa: E501

        :param enabled: The enabled of this IPSecVPNDPDProfile.  # noqa: E501
        :type: bool
        """

        self._enabled = enabled

    @property
    def dpd_probe_mode(self):
        """Gets the dpd_probe_mode of this IPSecVPNDPDProfile.  # noqa: E501

        DPD probe mode is used to query the liveliness of the peer. Two modes are possible - PERIODIC - is used to query the liveliness of the peer at regular intervals (dpd_probe_interval). It does not take into consideration traffic coming from the peer. The benefit of this mode over the on-demand mode is earlier detection of dead peers. However, use of periodic DPD incurs extra overhead. When communicating to large numbers of peers, please consider using on-demand DPD instead. ON_DEMAND - is used to query the liveliness of the peer by instructing the local endpoint to send DPD message to a peer if there is traffic to send to the peer AND the peer was idle for dpd_probe_interval seconds (i.e. there was no traffic from the peer for dpd_probe_interval seconds)   # noqa: E501

        :return: The dpd_probe_mode of this IPSecVPNDPDProfile.  # noqa: E501
        :rtype: str
        """
        return self._dpd_probe_mode

    @dpd_probe_mode.setter
    def dpd_probe_mode(self, dpd_probe_mode):
        """Sets the dpd_probe_mode of this IPSecVPNDPDProfile.

        DPD probe mode is used to query the liveliness of the peer. Two modes are possible - PERIODIC - is used to query the liveliness of the peer at regular intervals (dpd_probe_interval). It does not take into consideration traffic coming from the peer. The benefit of this mode over the on-demand mode is earlier detection of dead peers. However, use of periodic DPD incurs extra overhead. When communicating to large numbers of peers, please consider using on-demand DPD instead. ON_DEMAND - is used to query the liveliness of the peer by instructing the local endpoint to send DPD message to a peer if there is traffic to send to the peer AND the peer was idle for dpd_probe_interval seconds (i.e. there was no traffic from the peer for dpd_probe_interval seconds)   # noqa: E501

        :param dpd_probe_mode: The dpd_probe_mode of this IPSecVPNDPDProfile.  # noqa: E501
        :type: str
        """
        allowed_values = ["PERIODIC", "ON_DEMAND"]  # noqa: E501
        if dpd_probe_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `dpd_probe_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(dpd_probe_mode, allowed_values)
            )

        self._dpd_probe_mode = dpd_probe_mode

    @property
    def dpd_probe_interval(self):
        """Gets the dpd_probe_interval of this IPSecVPNDPDProfile.  # noqa: E501

        When the DPD probe mode is periodic, this interval is the number of seconds between DPD messages. When the DPD probe mode is on-demand, this interval is the number of seconds during which traffic is not received from the peer before DPD retry messages are sent if there is IPSec traffic to send. For PERIODIC Mode:    Minimum: 3    Maximum: 360    Default: 60 For ON_DEMAND Mode:    Minimum: 1    Maximum: 10    Default: 3   # noqa: E501

        :return: The dpd_probe_interval of this IPSecVPNDPDProfile.  # noqa: E501
        :rtype: int
        """
        return self._dpd_probe_interval

    @dpd_probe_interval.setter
    def dpd_probe_interval(self, dpd_probe_interval):
        """Sets the dpd_probe_interval of this IPSecVPNDPDProfile.

        When the DPD probe mode is periodic, this interval is the number of seconds between DPD messages. When the DPD probe mode is on-demand, this interval is the number of seconds during which traffic is not received from the peer before DPD retry messages are sent if there is IPSec traffic to send. For PERIODIC Mode:    Minimum: 3    Maximum: 360    Default: 60 For ON_DEMAND Mode:    Minimum: 1    Maximum: 10    Default: 3   # noqa: E501

        :param dpd_probe_interval: The dpd_probe_interval of this IPSecVPNDPDProfile.  # noqa: E501
        :type: int
        """

        self._dpd_probe_interval = dpd_probe_interval

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(IPSecVPNDPDProfile, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IPSecVPNDPDProfile):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
