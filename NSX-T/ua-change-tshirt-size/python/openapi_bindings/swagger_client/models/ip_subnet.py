# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class IPSubnet(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'ip_addresses': 'list[str]',
        'prefix_length': 'int'
    }

    attribute_map = {
        'ip_addresses': 'ip_addresses',
        'prefix_length': 'prefix_length'
    }

    def __init__(self, ip_addresses=None, prefix_length=None):  # noqa: E501
        """IPSubnet - a model defined in Swagger"""  # noqa: E501
        self._ip_addresses = None
        self._prefix_length = None
        self.discriminator = None
        self.ip_addresses = ip_addresses
        self.prefix_length = prefix_length

    @property
    def ip_addresses(self):
        """Gets the ip_addresses of this IPSubnet.  # noqa: E501

        All IP addresses, some of which  may be automatically configured. When updating this field, the payload may contain only the IP addresses that should be changed, or may contain the IP addresses to change as well as the automatically assigned addresses. Currently, only one updatable address and one system-maintained address are supported. Currently, the system-maintained address supported is Extended Unique Identifier(EUI)-64 address. EUI-64 address is generated by the system only when user configured ip-subnet has prefix length less than or equal to 64.   # noqa: E501

        :return: The ip_addresses of this IPSubnet.  # noqa: E501
        :rtype: list[str]
        """
        return self._ip_addresses

    @ip_addresses.setter
    def ip_addresses(self, ip_addresses):
        """Sets the ip_addresses of this IPSubnet.

        All IP addresses, some of which  may be automatically configured. When updating this field, the payload may contain only the IP addresses that should be changed, or may contain the IP addresses to change as well as the automatically assigned addresses. Currently, only one updatable address and one system-maintained address are supported. Currently, the system-maintained address supported is Extended Unique Identifier(EUI)-64 address. EUI-64 address is generated by the system only when user configured ip-subnet has prefix length less than or equal to 64.   # noqa: E501

        :param ip_addresses: The ip_addresses of this IPSubnet.  # noqa: E501
        :type: list[str]
        """
        if ip_addresses is None:
            raise ValueError("Invalid value for `ip_addresses`, must not be `None`")  # noqa: E501

        self._ip_addresses = ip_addresses

    @property
    def prefix_length(self):
        """Gets the prefix_length of this IPSubnet.  # noqa: E501

        Subnet Prefix Length  # noqa: E501

        :return: The prefix_length of this IPSubnet.  # noqa: E501
        :rtype: int
        """
        return self._prefix_length

    @prefix_length.setter
    def prefix_length(self, prefix_length):
        """Sets the prefix_length of this IPSubnet.

        Subnet Prefix Length  # noqa: E501

        :param prefix_length: The prefix_length of this IPSubnet.  # noqa: E501
        :type: int
        """
        if prefix_length is None:
            raise ValueError("Invalid value for `prefix_length`, must not be `None`")  # noqa: E501

        self._prefix_length = prefix_length

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(IPSubnet, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IPSubnet):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
