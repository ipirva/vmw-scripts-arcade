# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class LogicalRouterConfig(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'internal_transit_network': 'str',
        'transport_zone_id': 'str',
        'ha_vip_configs': 'list[HaVipConfig]',
        'external_transit_networks': 'list[str]'
    }

    attribute_map = {
        'internal_transit_network': 'internal_transit_network',
        'transport_zone_id': 'transport_zone_id',
        'ha_vip_configs': 'ha_vip_configs',
        'external_transit_networks': 'external_transit_networks'
    }

    def __init__(self, internal_transit_network=None, transport_zone_id=None, ha_vip_configs=None, external_transit_networks=None):  # noqa: E501
        """LogicalRouterConfig - a model defined in Swagger"""  # noqa: E501
        self._internal_transit_network = None
        self._transport_zone_id = None
        self._ha_vip_configs = None
        self._external_transit_networks = None
        self.discriminator = None
        if internal_transit_network is not None:
            self.internal_transit_network = internal_transit_network
        if transport_zone_id is not None:
            self.transport_zone_id = transport_zone_id
        if ha_vip_configs is not None:
            self.ha_vip_configs = ha_vip_configs
        if external_transit_networks is not None:
            self.external_transit_networks = external_transit_networks

    @property
    def internal_transit_network(self):
        """Gets the internal_transit_network of this LogicalRouterConfig.  # noqa: E501

        CIDR block defining service router to distributed router links. If the value for this field is not provided, then it will be considered as default IPv4 CIDR- \"169.254.0.0/28\" for logical router with ACTIVE_STANDBY HA mode \"169.254.0.0/24\" for logical router with ACTIVE_ACTIVE HA mode   # noqa: E501

        :return: The internal_transit_network of this LogicalRouterConfig.  # noqa: E501
        :rtype: str
        """
        return self._internal_transit_network

    @internal_transit_network.setter
    def internal_transit_network(self, internal_transit_network):
        """Sets the internal_transit_network of this LogicalRouterConfig.

        CIDR block defining service router to distributed router links. If the value for this field is not provided, then it will be considered as default IPv4 CIDR- \"169.254.0.0/28\" for logical router with ACTIVE_STANDBY HA mode \"169.254.0.0/24\" for logical router with ACTIVE_ACTIVE HA mode   # noqa: E501

        :param internal_transit_network: The internal_transit_network of this LogicalRouterConfig.  # noqa: E501
        :type: str
        """

        self._internal_transit_network = internal_transit_network

    @property
    def transport_zone_id(self):
        """Gets the transport_zone_id of this LogicalRouterConfig.  # noqa: E501

        Transport zone of the logical router. If specified then all downlink switches should belong to this transport zone and an error will be thrown if transport zone of the downlink switch doesn't match with this transport zone. All internal and external transit switches will be created in this transport zone.  # noqa: E501

        :return: The transport_zone_id of this LogicalRouterConfig.  # noqa: E501
        :rtype: str
        """
        return self._transport_zone_id

    @transport_zone_id.setter
    def transport_zone_id(self, transport_zone_id):
        """Sets the transport_zone_id of this LogicalRouterConfig.

        Transport zone of the logical router. If specified then all downlink switches should belong to this transport zone and an error will be thrown if transport zone of the downlink switch doesn't match with this transport zone. All internal and external transit switches will be created in this transport zone.  # noqa: E501

        :param transport_zone_id: The transport_zone_id of this LogicalRouterConfig.  # noqa: E501
        :type: str
        """

        self._transport_zone_id = transport_zone_id

    @property
    def ha_vip_configs(self):
        """Gets the ha_vip_configs of this LogicalRouterConfig.  # noqa: E501

        This configuration can be defined only for Active-Standby LogicalRouter to provide | redundancy. For mulitple uplink ports, multiple HaVipConfigs must be defined | and each config will pair exactly two uplink ports. The VIP will move and will | always be owned by the Active node. Note - when HaVipConfig[s] are defined, | configuring dynamic-routing is disallowed.  # noqa: E501

        :return: The ha_vip_configs of this LogicalRouterConfig.  # noqa: E501
        :rtype: list[HaVipConfig]
        """
        return self._ha_vip_configs

    @ha_vip_configs.setter
    def ha_vip_configs(self, ha_vip_configs):
        """Sets the ha_vip_configs of this LogicalRouterConfig.

        This configuration can be defined only for Active-Standby LogicalRouter to provide | redundancy. For mulitple uplink ports, multiple HaVipConfigs must be defined | and each config will pair exactly two uplink ports. The VIP will move and will | always be owned by the Active node. Note - when HaVipConfig[s] are defined, | configuring dynamic-routing is disallowed.  # noqa: E501

        :param ha_vip_configs: The ha_vip_configs of this LogicalRouterConfig.  # noqa: E501
        :type: list[HaVipConfig]
        """

        self._ha_vip_configs = ha_vip_configs

    @property
    def external_transit_networks(self):
        """Gets the external_transit_networks of this LogicalRouterConfig.  # noqa: E501

        CIDR block defining addresses for Tier0 to Tier1 links. If the value for this field is not provided, then it will be considered as default IPv4 CIDR \"100.64.0.0/16\"   # noqa: E501

        :return: The external_transit_networks of this LogicalRouterConfig.  # noqa: E501
        :rtype: list[str]
        """
        return self._external_transit_networks

    @external_transit_networks.setter
    def external_transit_networks(self, external_transit_networks):
        """Sets the external_transit_networks of this LogicalRouterConfig.

        CIDR block defining addresses for Tier0 to Tier1 links. If the value for this field is not provided, then it will be considered as default IPv4 CIDR \"100.64.0.0/16\"   # noqa: E501

        :param external_transit_networks: The external_transit_networks of this LogicalRouterConfig.  # noqa: E501
        :type: list[str]
        """

        self._external_transit_networks = external_transit_networks

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LogicalRouterConfig, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LogicalRouterConfig):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
