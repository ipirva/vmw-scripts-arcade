# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class PacketData(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'routed': 'bool',
        'transport_type': 'str',
        'resource_type': 'str',
        'frame_size': 'int'
    }

    attribute_map = {
        'routed': 'routed',
        'transport_type': 'transport_type',
        'resource_type': 'resource_type',
        'frame_size': 'frame_size'
    }

    discriminator_value_class_map = {
          'FieldsPacketData': 'FieldsPacketData',
'BinaryPacketData': 'BinaryPacketData'    }

    def __init__(self, routed=None, transport_type='UNICAST', resource_type=None, frame_size=128):  # noqa: E501
        """PacketData - a model defined in Swagger"""  # noqa: E501
        self._routed = None
        self._transport_type = None
        self._resource_type = None
        self._frame_size = None
        self.discriminator = 'resource_type'
        if routed is not None:
            self.routed = routed
        if transport_type is not None:
            self.transport_type = transport_type
        self.resource_type = resource_type
        if frame_size is not None:
            self.frame_size = frame_size

    @property
    def routed(self):
        """Gets the routed of this PacketData.  # noqa: E501

        A flag, when set true, indicates that the traceflow packet is of L3 routing.  # noqa: E501

        :return: The routed of this PacketData.  # noqa: E501
        :rtype: bool
        """
        return self._routed

    @routed.setter
    def routed(self, routed):
        """Sets the routed of this PacketData.

        A flag, when set true, indicates that the traceflow packet is of L3 routing.  # noqa: E501

        :param routed: The routed of this PacketData.  # noqa: E501
        :type: bool
        """

        self._routed = routed

    @property
    def transport_type(self):
        """Gets the transport_type of this PacketData.  # noqa: E501

        transport type of the traceflow packet  # noqa: E501

        :return: The transport_type of this PacketData.  # noqa: E501
        :rtype: str
        """
        return self._transport_type

    @transport_type.setter
    def transport_type(self, transport_type):
        """Sets the transport_type of this PacketData.

        transport type of the traceflow packet  # noqa: E501

        :param transport_type: The transport_type of this PacketData.  # noqa: E501
        :type: str
        """
        allowed_values = ["BROADCAST", "UNICAST", "MULTICAST", "UNKNOWN"]  # noqa: E501
        if transport_type not in allowed_values:
            raise ValueError(
                "Invalid value for `transport_type` ({0}), must be one of {1}"  # noqa: E501
                .format(transport_type, allowed_values)
            )

        self._transport_type = transport_type

    @property
    def resource_type(self):
        """Gets the resource_type of this PacketData.  # noqa: E501

        Packet configuration  # noqa: E501

        :return: The resource_type of this PacketData.  # noqa: E501
        :rtype: str
        """
        return self._resource_type

    @resource_type.setter
    def resource_type(self, resource_type):
        """Sets the resource_type of this PacketData.

        Packet configuration  # noqa: E501

        :param resource_type: The resource_type of this PacketData.  # noqa: E501
        :type: str
        """
        if resource_type is None:
            raise ValueError("Invalid value for `resource_type`, must not be `None`")  # noqa: E501
        allowed_values = ["BinaryPacketData", "FieldsPacketData"]  # noqa: E501
        if resource_type not in allowed_values:
            raise ValueError(
                "Invalid value for `resource_type` ({0}), must be one of {1}"  # noqa: E501
                .format(resource_type, allowed_values)
            )

        self._resource_type = resource_type

    @property
    def frame_size(self):
        """Gets the frame_size of this PacketData.  # noqa: E501

        If the requested frame_size is too small (given the payload and traceflow metadata requirement of 16 bytes), the traceflow request will fail with an appropriate message.  The frame will be zero padded to the requested size.  # noqa: E501

        :return: The frame_size of this PacketData.  # noqa: E501
        :rtype: int
        """
        return self._frame_size

    @frame_size.setter
    def frame_size(self, frame_size):
        """Sets the frame_size of this PacketData.

        If the requested frame_size is too small (given the payload and traceflow metadata requirement of 16 bytes), the traceflow request will fail with an appropriate message.  The frame will be zero padded to the requested size.  # noqa: E501

        :param frame_size: The frame_size of this PacketData.  # noqa: E501
        :type: int
        """

        self._frame_size = frame_size

    def get_real_child_model(self, data):
        """Returns the real base class specified by the discriminator"""
        discriminator_value = data[self.discriminator].lower()
        return self.discriminator_value_class_map.get(discriminator_value)

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(PacketData, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PacketData):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
