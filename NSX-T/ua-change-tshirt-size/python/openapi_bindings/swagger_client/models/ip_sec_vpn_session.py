# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.managed_resource import ManagedResource  # noqa: F401,E501

class IPSecVPNSession(ManagedResource):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'peer_endpoint_id': 'str',
        'ipsec_vpn_service_id': 'str',
        'local_endpoint_id': 'str',
        'tcp_mss_clamping': 'TcpMssClamping',
        'enabled': 'bool',
        'resource_type': 'str'
    }
    if hasattr(ManagedResource, "swagger_types"):
        swagger_types.update(ManagedResource.swagger_types)

    attribute_map = {
        'peer_endpoint_id': 'peer_endpoint_id',
        'ipsec_vpn_service_id': 'ipsec_vpn_service_id',
        'local_endpoint_id': 'local_endpoint_id',
        'tcp_mss_clamping': 'tcp_mss_clamping',
        'enabled': 'enabled',
        'resource_type': 'resource_type'
    }
    if hasattr(ManagedResource, "attribute_map"):
        attribute_map.update(ManagedResource.attribute_map)

    discriminator_value_class_map = {
          'RouteBasedIPSecVPNSession': 'RouteBasedIPSecVPNSession',
'PolicyBasedIPSecVPNSession': 'PolicyBasedIPSecVPNSession'    }

    def __init__(self, peer_endpoint_id=None, ipsec_vpn_service_id=None, local_endpoint_id=None, tcp_mss_clamping=None, enabled=True, resource_type=None, *args, **kwargs):  # noqa: E501
        """IPSecVPNSession - a model defined in Swagger"""  # noqa: E501
        self._peer_endpoint_id = None
        self._ipsec_vpn_service_id = None
        self._local_endpoint_id = None
        self._tcp_mss_clamping = None
        self._enabled = None
        self._resource_type = None
        self.discriminator = 'resource_type'
        self.peer_endpoint_id = peer_endpoint_id
        if ipsec_vpn_service_id is not None:
            self.ipsec_vpn_service_id = ipsec_vpn_service_id
        self.local_endpoint_id = local_endpoint_id
        if tcp_mss_clamping is not None:
            self.tcp_mss_clamping = tcp_mss_clamping
        if enabled is not None:
            self.enabled = enabled
        self.resource_type = resource_type
        ManagedResource.__init__(self, *args, **kwargs)

    @property
    def peer_endpoint_id(self):
        """Gets the peer_endpoint_id of this IPSecVPNSession.  # noqa: E501

        Peer endpoint identifier.  # noqa: E501

        :return: The peer_endpoint_id of this IPSecVPNSession.  # noqa: E501
        :rtype: str
        """
        return self._peer_endpoint_id

    @peer_endpoint_id.setter
    def peer_endpoint_id(self, peer_endpoint_id):
        """Sets the peer_endpoint_id of this IPSecVPNSession.

        Peer endpoint identifier.  # noqa: E501

        :param peer_endpoint_id: The peer_endpoint_id of this IPSecVPNSession.  # noqa: E501
        :type: str
        """
        if peer_endpoint_id is None:
            raise ValueError("Invalid value for `peer_endpoint_id`, must not be `None`")  # noqa: E501

        self._peer_endpoint_id = peer_endpoint_id

    @property
    def ipsec_vpn_service_id(self):
        """Gets the ipsec_vpn_service_id of this IPSecVPNSession.  # noqa: E501

        Identifier of VPN Service linked with local endpoint.  # noqa: E501

        :return: The ipsec_vpn_service_id of this IPSecVPNSession.  # noqa: E501
        :rtype: str
        """
        return self._ipsec_vpn_service_id

    @ipsec_vpn_service_id.setter
    def ipsec_vpn_service_id(self, ipsec_vpn_service_id):
        """Sets the ipsec_vpn_service_id of this IPSecVPNSession.

        Identifier of VPN Service linked with local endpoint.  # noqa: E501

        :param ipsec_vpn_service_id: The ipsec_vpn_service_id of this IPSecVPNSession.  # noqa: E501
        :type: str
        """

        self._ipsec_vpn_service_id = ipsec_vpn_service_id

    @property
    def local_endpoint_id(self):
        """Gets the local_endpoint_id of this IPSecVPNSession.  # noqa: E501

        Local endpoint identifier.  # noqa: E501

        :return: The local_endpoint_id of this IPSecVPNSession.  # noqa: E501
        :rtype: str
        """
        return self._local_endpoint_id

    @local_endpoint_id.setter
    def local_endpoint_id(self, local_endpoint_id):
        """Sets the local_endpoint_id of this IPSecVPNSession.

        Local endpoint identifier.  # noqa: E501

        :param local_endpoint_id: The local_endpoint_id of this IPSecVPNSession.  # noqa: E501
        :type: str
        """
        if local_endpoint_id is None:
            raise ValueError("Invalid value for `local_endpoint_id`, must not be `None`")  # noqa: E501

        self._local_endpoint_id = local_endpoint_id

    @property
    def tcp_mss_clamping(self):
        """Gets the tcp_mss_clamping of this IPSecVPNSession.  # noqa: E501


        :return: The tcp_mss_clamping of this IPSecVPNSession.  # noqa: E501
        :rtype: TcpMssClamping
        """
        return self._tcp_mss_clamping

    @tcp_mss_clamping.setter
    def tcp_mss_clamping(self, tcp_mss_clamping):
        """Sets the tcp_mss_clamping of this IPSecVPNSession.


        :param tcp_mss_clamping: The tcp_mss_clamping of this IPSecVPNSession.  # noqa: E501
        :type: TcpMssClamping
        """

        self._tcp_mss_clamping = tcp_mss_clamping

    @property
    def enabled(self):
        """Gets the enabled of this IPSecVPNSession.  # noqa: E501

        Enable/Disable IPSec VPN session.  # noqa: E501

        :return: The enabled of this IPSecVPNSession.  # noqa: E501
        :rtype: bool
        """
        return self._enabled

    @enabled.setter
    def enabled(self, enabled):
        """Sets the enabled of this IPSecVPNSession.

        Enable/Disable IPSec VPN session.  # noqa: E501

        :param enabled: The enabled of this IPSecVPNSession.  # noqa: E501
        :type: bool
        """

        self._enabled = enabled

    @property
    def resource_type(self):
        """Gets the resource_type of this IPSecVPNSession.  # noqa: E501

        A Policy Based VPN requires to define protect rules that match   local and peer subnets. IPSec security associations is   negotiated for each pair of local and peer subnet. A Route Based VPN is more flexible, more powerful and recommended over   policy based VPN. IP Tunnel port is created and all traffic routed via   tunnel port is protected. Routes can be configured statically   or can be learned through BGP. A route based VPN is must for establishing   redundant VPN session to remote site.   # noqa: E501

        :return: The resource_type of this IPSecVPNSession.  # noqa: E501
        :rtype: str
        """
        return self._resource_type

    @resource_type.setter
    def resource_type(self, resource_type):
        """Sets the resource_type of this IPSecVPNSession.

        A Policy Based VPN requires to define protect rules that match   local and peer subnets. IPSec security associations is   negotiated for each pair of local and peer subnet. A Route Based VPN is more flexible, more powerful and recommended over   policy based VPN. IP Tunnel port is created and all traffic routed via   tunnel port is protected. Routes can be configured statically   or can be learned through BGP. A route based VPN is must for establishing   redundant VPN session to remote site.   # noqa: E501

        :param resource_type: The resource_type of this IPSecVPNSession.  # noqa: E501
        :type: str
        """
        if resource_type is None:
            raise ValueError("Invalid value for `resource_type`, must not be `None`")  # noqa: E501
        allowed_values = ["PolicyBasedIPSecVPNSession", "RouteBasedIPSecVPNSession"]  # noqa: E501
        if resource_type not in allowed_values:
            raise ValueError(
                "Invalid value for `resource_type` ({0}), must be one of {1}"  # noqa: E501
                .format(resource_type, allowed_values)
            )

        self._resource_type = resource_type

    def get_real_child_model(self, data):
        """Returns the real base class specified by the discriminator"""
        discriminator_value = data[self.discriminator].lower()
        return self.discriminator_value_class_map.get(discriminator_value)

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(IPSecVPNSession, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IPSecVPNSession):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
