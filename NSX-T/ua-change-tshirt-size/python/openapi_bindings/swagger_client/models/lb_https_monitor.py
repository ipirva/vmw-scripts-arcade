# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.lb_active_monitor import LbActiveMonitor  # noqa: F401,E501

class LbHttpsMonitor(LbActiveMonitor):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'response_status_codes': 'list[int]',
        'server_auth_crl_ids': 'list[str]',
        'server_auth_ca_ids': 'list[str]',
        'server_auth': 'str',
        'request_body': 'str',
        'response_body': 'str',
        'ciphers': 'list[str]',
        'request_headers': 'list[LbHttpRequestHeader]',
        'client_certificate_id': 'str',
        'request_method': 'str',
        'is_fips': 'bool',
        'certificate_chain_depth': 'int',
        'is_secure': 'bool',
        'request_url': 'str',
        'cipher_group_label': 'str',
        'request_version': 'str',
        'protocols': 'list[str]'
    }
    if hasattr(LbActiveMonitor, "swagger_types"):
        swagger_types.update(LbActiveMonitor.swagger_types)

    attribute_map = {
        'response_status_codes': 'response_status_codes',
        'server_auth_crl_ids': 'server_auth_crl_ids',
        'server_auth_ca_ids': 'server_auth_ca_ids',
        'server_auth': 'server_auth',
        'request_body': 'request_body',
        'response_body': 'response_body',
        'ciphers': 'ciphers',
        'request_headers': 'request_headers',
        'client_certificate_id': 'client_certificate_id',
        'request_method': 'request_method',
        'is_fips': 'is_fips',
        'certificate_chain_depth': 'certificate_chain_depth',
        'is_secure': 'is_secure',
        'request_url': 'request_url',
        'cipher_group_label': 'cipher_group_label',
        'request_version': 'request_version',
        'protocols': 'protocols'
    }
    if hasattr(LbActiveMonitor, "attribute_map"):
        attribute_map.update(LbActiveMonitor.attribute_map)

    def __init__(self, response_status_codes=None, server_auth_crl_ids=None, server_auth_ca_ids=None, server_auth='IGNORE', request_body=None, response_body=None, ciphers=None, request_headers=None, client_certificate_id=None, request_method='GET', is_fips=None, certificate_chain_depth=3, is_secure=None, request_url=None, cipher_group_label=None, request_version='HTTP_VERSION_1_1', protocols=None, *args, **kwargs):  # noqa: E501
        """LbHttpsMonitor - a model defined in Swagger"""  # noqa: E501
        self._response_status_codes = None
        self._server_auth_crl_ids = None
        self._server_auth_ca_ids = None
        self._server_auth = None
        self._request_body = None
        self._response_body = None
        self._ciphers = None
        self._request_headers = None
        self._client_certificate_id = None
        self._request_method = None
        self._is_fips = None
        self._certificate_chain_depth = None
        self._is_secure = None
        self._request_url = None
        self._cipher_group_label = None
        self._request_version = None
        self._protocols = None
        self.discriminator = None
        if response_status_codes is not None:
            self.response_status_codes = response_status_codes
        if server_auth_crl_ids is not None:
            self.server_auth_crl_ids = server_auth_crl_ids
        if server_auth_ca_ids is not None:
            self.server_auth_ca_ids = server_auth_ca_ids
        if server_auth is not None:
            self.server_auth = server_auth
        if request_body is not None:
            self.request_body = request_body
        if response_body is not None:
            self.response_body = response_body
        if ciphers is not None:
            self.ciphers = ciphers
        if request_headers is not None:
            self.request_headers = request_headers
        if client_certificate_id is not None:
            self.client_certificate_id = client_certificate_id
        if request_method is not None:
            self.request_method = request_method
        if is_fips is not None:
            self.is_fips = is_fips
        if certificate_chain_depth is not None:
            self.certificate_chain_depth = certificate_chain_depth
        if is_secure is not None:
            self.is_secure = is_secure
        if request_url is not None:
            self.request_url = request_url
        if cipher_group_label is not None:
            self.cipher_group_label = cipher_group_label
        if request_version is not None:
            self.request_version = request_version
        if protocols is not None:
            self.protocols = protocols
        LbActiveMonitor.__init__(self, *args, **kwargs)

    @property
    def response_status_codes(self):
        """Gets the response_status_codes of this LbHttpsMonitor.  # noqa: E501

        The HTTP response status code should be a valid HTTP status code.   # noqa: E501

        :return: The response_status_codes of this LbHttpsMonitor.  # noqa: E501
        :rtype: list[int]
        """
        return self._response_status_codes

    @response_status_codes.setter
    def response_status_codes(self, response_status_codes):
        """Sets the response_status_codes of this LbHttpsMonitor.

        The HTTP response status code should be a valid HTTP status code.   # noqa: E501

        :param response_status_codes: The response_status_codes of this LbHttpsMonitor.  # noqa: E501
        :type: list[int]
        """

        self._response_status_codes = response_status_codes

    @property
    def server_auth_crl_ids(self):
        """Gets the server_auth_crl_ids of this LbHttpsMonitor.  # noqa: E501

        A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates.   # noqa: E501

        :return: The server_auth_crl_ids of this LbHttpsMonitor.  # noqa: E501
        :rtype: list[str]
        """
        return self._server_auth_crl_ids

    @server_auth_crl_ids.setter
    def server_auth_crl_ids(self, server_auth_crl_ids):
        """Sets the server_auth_crl_ids of this LbHttpsMonitor.

        A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates.   # noqa: E501

        :param server_auth_crl_ids: The server_auth_crl_ids of this LbHttpsMonitor.  # noqa: E501
        :type: list[str]
        """

        self._server_auth_crl_ids = server_auth_crl_ids

    @property
    def server_auth_ca_ids(self):
        """Gets the server_auth_ca_ids of this LbHttpsMonitor.  # noqa: E501

        If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified.   # noqa: E501

        :return: The server_auth_ca_ids of this LbHttpsMonitor.  # noqa: E501
        :rtype: list[str]
        """
        return self._server_auth_ca_ids

    @server_auth_ca_ids.setter
    def server_auth_ca_ids(self, server_auth_ca_ids):
        """Sets the server_auth_ca_ids of this LbHttpsMonitor.

        If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified.   # noqa: E501

        :param server_auth_ca_ids: The server_auth_ca_ids of this LbHttpsMonitor.  # noqa: E501
        :type: list[str]
        """

        self._server_auth_ca_ids = server_auth_ca_ids

    @property
    def server_auth(self):
        """Gets the server_auth of this LbHttpsMonitor.  # noqa: E501

        server authentication mode  # noqa: E501

        :return: The server_auth of this LbHttpsMonitor.  # noqa: E501
        :rtype: str
        """
        return self._server_auth

    @server_auth.setter
    def server_auth(self, server_auth):
        """Sets the server_auth of this LbHttpsMonitor.

        server authentication mode  # noqa: E501

        :param server_auth: The server_auth of this LbHttpsMonitor.  # noqa: E501
        :type: str
        """
        allowed_values = ["REQUIRED", "IGNORE"]  # noqa: E501
        if server_auth not in allowed_values:
            raise ValueError(
                "Invalid value for `server_auth` ({0}), must be one of {1}"  # noqa: E501
                .format(server_auth, allowed_values)
            )

        self._server_auth = server_auth

    @property
    def request_body(self):
        """Gets the request_body of this LbHttpsMonitor.  # noqa: E501

        String to send as part of HTTP health check request body. Valid only for certain HTTP methods like POST.   # noqa: E501

        :return: The request_body of this LbHttpsMonitor.  # noqa: E501
        :rtype: str
        """
        return self._request_body

    @request_body.setter
    def request_body(self, request_body):
        """Sets the request_body of this LbHttpsMonitor.

        String to send as part of HTTP health check request body. Valid only for certain HTTP methods like POST.   # noqa: E501

        :param request_body: The request_body of this LbHttpsMonitor.  # noqa: E501
        :type: str
        """

        self._request_body = request_body

    @property
    def response_body(self):
        """Gets the response_body of this LbHttpsMonitor.  # noqa: E501

        If HTTP response body match string (regular expressions not supported) is specified (using LbHttpMonitor.response_body) then the healthcheck HTTP response body is matched against the specified string and server is considered healthy only if there is a match. If the response body string is not specified, HTTP healthcheck is considered successful if the HTTP response status code is 2xx, but it can be configured to accept other status codes as successful.   # noqa: E501

        :return: The response_body of this LbHttpsMonitor.  # noqa: E501
        :rtype: str
        """
        return self._response_body

    @response_body.setter
    def response_body(self, response_body):
        """Sets the response_body of this LbHttpsMonitor.

        If HTTP response body match string (regular expressions not supported) is specified (using LbHttpMonitor.response_body) then the healthcheck HTTP response body is matched against the specified string and server is considered healthy only if there is a match. If the response body string is not specified, HTTP healthcheck is considered successful if the HTTP response status code is 2xx, but it can be configured to accept other status codes as successful.   # noqa: E501

        :param response_body: The response_body of this LbHttpsMonitor.  # noqa: E501
        :type: str
        """

        self._response_body = response_body

    @property
    def ciphers(self):
        """Gets the ciphers of this LbHttpsMonitor.  # noqa: E501

        supported SSL cipher list to servers  # noqa: E501

        :return: The ciphers of this LbHttpsMonitor.  # noqa: E501
        :rtype: list[str]
        """
        return self._ciphers

    @ciphers.setter
    def ciphers(self, ciphers):
        """Sets the ciphers of this LbHttpsMonitor.

        supported SSL cipher list to servers  # noqa: E501

        :param ciphers: The ciphers of this LbHttpsMonitor.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA", "TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_3DES_EDE_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", "TLS_RSA_WITH_AES_128_CBC_SHA256", "TLS_RSA_WITH_AES_128_GCM_SHA256", "TLS_RSA_WITH_AES_256_CBC_SHA256", "TLS_RSA_WITH_AES_256_GCM_SHA384", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"]  # noqa: E501
        if not set(ciphers).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `ciphers` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(ciphers) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._ciphers = ciphers

    @property
    def request_headers(self):
        """Gets the request_headers of this LbHttpsMonitor.  # noqa: E501

        Array of HTTP request headers  # noqa: E501

        :return: The request_headers of this LbHttpsMonitor.  # noqa: E501
        :rtype: list[LbHttpRequestHeader]
        """
        return self._request_headers

    @request_headers.setter
    def request_headers(self, request_headers):
        """Sets the request_headers of this LbHttpsMonitor.

        Array of HTTP request headers  # noqa: E501

        :param request_headers: The request_headers of this LbHttpsMonitor.  # noqa: E501
        :type: list[LbHttpRequestHeader]
        """

        self._request_headers = request_headers

    @property
    def client_certificate_id(self):
        """Gets the client_certificate_id of this LbHttpsMonitor.  # noqa: E501

        client certificate can be specified to support client authentication.   # noqa: E501

        :return: The client_certificate_id of this LbHttpsMonitor.  # noqa: E501
        :rtype: str
        """
        return self._client_certificate_id

    @client_certificate_id.setter
    def client_certificate_id(self, client_certificate_id):
        """Sets the client_certificate_id of this LbHttpsMonitor.

        client certificate can be specified to support client authentication.   # noqa: E501

        :param client_certificate_id: The client_certificate_id of this LbHttpsMonitor.  # noqa: E501
        :type: str
        """

        self._client_certificate_id = client_certificate_id

    @property
    def request_method(self):
        """Gets the request_method of this LbHttpsMonitor.  # noqa: E501

        the health check method for HTTP monitor type  # noqa: E501

        :return: The request_method of this LbHttpsMonitor.  # noqa: E501
        :rtype: str
        """
        return self._request_method

    @request_method.setter
    def request_method(self, request_method):
        """Sets the request_method of this LbHttpsMonitor.

        the health check method for HTTP monitor type  # noqa: E501

        :param request_method: The request_method of this LbHttpsMonitor.  # noqa: E501
        :type: str
        """
        allowed_values = ["GET", "OPTIONS", "POST", "HEAD", "PUT"]  # noqa: E501
        if request_method not in allowed_values:
            raise ValueError(
                "Invalid value for `request_method` ({0}), must be one of {1}"  # noqa: E501
                .format(request_method, allowed_values)
            )

        self._request_method = request_method

    @property
    def is_fips(self):
        """Gets the is_fips of this LbHttpsMonitor.  # noqa: E501

        This flag is set to true when all the ciphers and protocols are FIPS compliant. It is set to false when one of the ciphers or protocols are not FIPS compliant..   # noqa: E501

        :return: The is_fips of this LbHttpsMonitor.  # noqa: E501
        :rtype: bool
        """
        return self._is_fips

    @is_fips.setter
    def is_fips(self, is_fips):
        """Sets the is_fips of this LbHttpsMonitor.

        This flag is set to true when all the ciphers and protocols are FIPS compliant. It is set to false when one of the ciphers or protocols are not FIPS compliant..   # noqa: E501

        :param is_fips: The is_fips of this LbHttpsMonitor.  # noqa: E501
        :type: bool
        """

        self._is_fips = is_fips

    @property
    def certificate_chain_depth(self):
        """Gets the certificate_chain_depth of this LbHttpsMonitor.  # noqa: E501

        authentication depth is used to set the verification depth in the server certificates chain.   # noqa: E501

        :return: The certificate_chain_depth of this LbHttpsMonitor.  # noqa: E501
        :rtype: int
        """
        return self._certificate_chain_depth

    @certificate_chain_depth.setter
    def certificate_chain_depth(self, certificate_chain_depth):
        """Sets the certificate_chain_depth of this LbHttpsMonitor.

        authentication depth is used to set the verification depth in the server certificates chain.   # noqa: E501

        :param certificate_chain_depth: The certificate_chain_depth of this LbHttpsMonitor.  # noqa: E501
        :type: int
        """

        self._certificate_chain_depth = certificate_chain_depth

    @property
    def is_secure(self):
        """Gets the is_secure of this LbHttpsMonitor.  # noqa: E501

        This flag is set to true when all the ciphers and protocols are secure. It is set to false when one of the ciphers or protocols is insecure.   # noqa: E501

        :return: The is_secure of this LbHttpsMonitor.  # noqa: E501
        :rtype: bool
        """
        return self._is_secure

    @is_secure.setter
    def is_secure(self, is_secure):
        """Sets the is_secure of this LbHttpsMonitor.

        This flag is set to true when all the ciphers and protocols are secure. It is set to false when one of the ciphers or protocols is insecure.   # noqa: E501

        :param is_secure: The is_secure of this LbHttpsMonitor.  # noqa: E501
        :type: bool
        """

        self._is_secure = is_secure

    @property
    def request_url(self):
        """Gets the request_url of this LbHttpsMonitor.  # noqa: E501

        URL used for HTTP monitor  # noqa: E501

        :return: The request_url of this LbHttpsMonitor.  # noqa: E501
        :rtype: str
        """
        return self._request_url

    @request_url.setter
    def request_url(self, request_url):
        """Sets the request_url of this LbHttpsMonitor.

        URL used for HTTP monitor  # noqa: E501

        :param request_url: The request_url of this LbHttpsMonitor.  # noqa: E501
        :type: str
        """

        self._request_url = request_url

    @property
    def cipher_group_label(self):
        """Gets the cipher_group_label of this LbHttpsMonitor.  # noqa: E501

        It is a label of cipher group which is mostly consumed by GUI.   # noqa: E501

        :return: The cipher_group_label of this LbHttpsMonitor.  # noqa: E501
        :rtype: str
        """
        return self._cipher_group_label

    @cipher_group_label.setter
    def cipher_group_label(self, cipher_group_label):
        """Sets the cipher_group_label of this LbHttpsMonitor.

        It is a label of cipher group which is mostly consumed by GUI.   # noqa: E501

        :param cipher_group_label: The cipher_group_label of this LbHttpsMonitor.  # noqa: E501
        :type: str
        """
        allowed_values = ["BALANCED", "HIGH_SECURITY", "HIGH_COMPATIBILITY", "CUSTOM"]  # noqa: E501
        if cipher_group_label not in allowed_values:
            raise ValueError(
                "Invalid value for `cipher_group_label` ({0}), must be one of {1}"  # noqa: E501
                .format(cipher_group_label, allowed_values)
            )

        self._cipher_group_label = cipher_group_label

    @property
    def request_version(self):
        """Gets the request_version of this LbHttpsMonitor.  # noqa: E501

        HTTP request version  # noqa: E501

        :return: The request_version of this LbHttpsMonitor.  # noqa: E501
        :rtype: str
        """
        return self._request_version

    @request_version.setter
    def request_version(self, request_version):
        """Sets the request_version of this LbHttpsMonitor.

        HTTP request version  # noqa: E501

        :param request_version: The request_version of this LbHttpsMonitor.  # noqa: E501
        :type: str
        """
        allowed_values = ["HTTP_VERSION_1_0", "HTTP_VERSION_1_1"]  # noqa: E501
        if request_version not in allowed_values:
            raise ValueError(
                "Invalid value for `request_version` ({0}), must be one of {1}"  # noqa: E501
                .format(request_version, allowed_values)
            )

        self._request_version = request_version

    @property
    def protocols(self):
        """Gets the protocols of this LbHttpsMonitor.  # noqa: E501

        SSL versions TLS1.1 and TLS1.2 are supported and enabled by default. SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default.   # noqa: E501

        :return: The protocols of this LbHttpsMonitor.  # noqa: E501
        :rtype: list[str]
        """
        return self._protocols

    @protocols.setter
    def protocols(self, protocols):
        """Sets the protocols of this LbHttpsMonitor.

        SSL versions TLS1.1 and TLS1.2 are supported and enabled by default. SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default.   # noqa: E501

        :param protocols: The protocols of this LbHttpsMonitor.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["SSL_V2", "SSL_V3", "TLS_V1", "TLS_V1_1", "TLS_V1_2"]  # noqa: E501
        if not set(protocols).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `protocols` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(protocols) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._protocols = protocols

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LbHttpsMonitor, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LbHttpsMonitor):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
