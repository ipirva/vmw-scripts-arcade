# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.managed_resource import ManagedResource  # noqa: F401,E501

class LogicalSwitch(ManagedResource):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'switch_type': 'str',
        'replication_mode': 'str',
        'extra_configs': 'list[ExtraConfig]',
        'uplink_teaming_policy_name': 'str',
        'address_bindings': 'list[PacketAddressClassifier]',
        'ip_pool_id': 'str',
        'vlan': 'int',
        'hybrid': 'bool',
        'mac_pool_id': 'str',
        'vni': 'int',
        'vlan_trunk_spec': 'VlanTrunkSpec',
        'admin_state': 'str',
        'transport_zone_id': 'str',
        'span': 'list[str]',
        'switching_profile_ids': 'list[SwitchingProfileTypeIdEntry]',
        'global_vni': 'int'
    }
    if hasattr(ManagedResource, "swagger_types"):
        swagger_types.update(ManagedResource.swagger_types)

    attribute_map = {
        'switch_type': 'switch_type',
        'replication_mode': 'replication_mode',
        'extra_configs': 'extra_configs',
        'uplink_teaming_policy_name': 'uplink_teaming_policy_name',
        'address_bindings': 'address_bindings',
        'ip_pool_id': 'ip_pool_id',
        'vlan': 'vlan',
        'hybrid': 'hybrid',
        'mac_pool_id': 'mac_pool_id',
        'vni': 'vni',
        'vlan_trunk_spec': 'vlan_trunk_spec',
        'admin_state': 'admin_state',
        'transport_zone_id': 'transport_zone_id',
        'span': 'span',
        'switching_profile_ids': 'switching_profile_ids',
        'global_vni': 'global_vni'
    }
    if hasattr(ManagedResource, "attribute_map"):
        attribute_map.update(ManagedResource.attribute_map)

    def __init__(self, switch_type=None, replication_mode=None, extra_configs=None, uplink_teaming_policy_name=None, address_bindings=None, ip_pool_id=None, vlan=None, hybrid=False, mac_pool_id=None, vni=None, vlan_trunk_spec=None, admin_state=None, transport_zone_id=None, span=None, switching_profile_ids=None, global_vni=None, *args, **kwargs):  # noqa: E501
        """LogicalSwitch - a model defined in Swagger"""  # noqa: E501
        self._switch_type = None
        self._replication_mode = None
        self._extra_configs = None
        self._uplink_teaming_policy_name = None
        self._address_bindings = None
        self._ip_pool_id = None
        self._vlan = None
        self._hybrid = None
        self._mac_pool_id = None
        self._vni = None
        self._vlan_trunk_spec = None
        self._admin_state = None
        self._transport_zone_id = None
        self._span = None
        self._switching_profile_ids = None
        self._global_vni = None
        self.discriminator = None
        if switch_type is not None:
            self.switch_type = switch_type
        if replication_mode is not None:
            self.replication_mode = replication_mode
        if extra_configs is not None:
            self.extra_configs = extra_configs
        if uplink_teaming_policy_name is not None:
            self.uplink_teaming_policy_name = uplink_teaming_policy_name
        if address_bindings is not None:
            self.address_bindings = address_bindings
        if ip_pool_id is not None:
            self.ip_pool_id = ip_pool_id
        if vlan is not None:
            self.vlan = vlan
        if hybrid is not None:
            self.hybrid = hybrid
        if mac_pool_id is not None:
            self.mac_pool_id = mac_pool_id
        if vni is not None:
            self.vni = vni
        if vlan_trunk_spec is not None:
            self.vlan_trunk_spec = vlan_trunk_spec
        self.admin_state = admin_state
        self.transport_zone_id = transport_zone_id
        if span is not None:
            self.span = span
        if switching_profile_ids is not None:
            self.switching_profile_ids = switching_profile_ids
        if global_vni is not None:
            self.global_vni = global_vni
        ManagedResource.__init__(self, *args, **kwargs)

    @property
    def switch_type(self):
        """Gets the switch_type of this LogicalSwitch.  # noqa: E501

        This field indicates purpose of a LogicalSwitch. It is set by manager internally or user can provide this field. If not set, DEFAULT type is assigned. NSX components can use this field to create LogicalSwitch that provides component specific functionality. DEFAULT type LogicalSwitches are created for basic L2 connectivity by API users. SERVICE_PLANE type LogicalSwitches are system created service plane LogicalSwitches for Service Insertion service. User can not create SERVICE_PLANE type of LogicalSwitch. DHCP_RELAY type LogicalSwitches are created by external user like Policy with special permissions or by system and will be treated as internal LogicalSwitches. Such LogicalSwitch will not be exposed to vSphere user. GLOBAL type LogicalSwitches are created to span multiple NSX domains to connect multiple remote sites. INTER_ROUTER type LogicalSwitches are policy-created LogicalSwitches which provide inter-router connectivity   # noqa: E501

        :return: The switch_type of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._switch_type

    @switch_type.setter
    def switch_type(self, switch_type):
        """Sets the switch_type of this LogicalSwitch.

        This field indicates purpose of a LogicalSwitch. It is set by manager internally or user can provide this field. If not set, DEFAULT type is assigned. NSX components can use this field to create LogicalSwitch that provides component specific functionality. DEFAULT type LogicalSwitches are created for basic L2 connectivity by API users. SERVICE_PLANE type LogicalSwitches are system created service plane LogicalSwitches for Service Insertion service. User can not create SERVICE_PLANE type of LogicalSwitch. DHCP_RELAY type LogicalSwitches are created by external user like Policy with special permissions or by system and will be treated as internal LogicalSwitches. Such LogicalSwitch will not be exposed to vSphere user. GLOBAL type LogicalSwitches are created to span multiple NSX domains to connect multiple remote sites. INTER_ROUTER type LogicalSwitches are policy-created LogicalSwitches which provide inter-router connectivity   # noqa: E501

        :param switch_type: The switch_type of this LogicalSwitch.  # noqa: E501
        :type: str
        """
        allowed_values = ["DEFAULT", "SERVICE_PLANE", "DHCP_RELAY", "GLOBAL", "INTER_ROUTER", "EVPN"]  # noqa: E501
        if switch_type not in allowed_values:
            raise ValueError(
                "Invalid value for `switch_type` ({0}), must be one of {1}"  # noqa: E501
                .format(switch_type, allowed_values)
            )

        self._switch_type = switch_type

    @property
    def replication_mode(self):
        """Gets the replication_mode of this LogicalSwitch.  # noqa: E501

        Replication mode of the Logical Switch  # noqa: E501

        :return: The replication_mode of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._replication_mode

    @replication_mode.setter
    def replication_mode(self, replication_mode):
        """Sets the replication_mode of this LogicalSwitch.

        Replication mode of the Logical Switch  # noqa: E501

        :param replication_mode: The replication_mode of this LogicalSwitch.  # noqa: E501
        :type: str
        """
        allowed_values = ["MTEP", "SOURCE"]  # noqa: E501
        if replication_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `replication_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(replication_mode, allowed_values)
            )

        self._replication_mode = replication_mode

    @property
    def extra_configs(self):
        """Gets the extra_configs of this LogicalSwitch.  # noqa: E501

        This property could be used for vendor specific configuration in key value string pairs, the setting in extra_configs will be automatically inheritted by logical ports in the logical switch.   # noqa: E501

        :return: The extra_configs of this LogicalSwitch.  # noqa: E501
        :rtype: list[ExtraConfig]
        """
        return self._extra_configs

    @extra_configs.setter
    def extra_configs(self, extra_configs):
        """Sets the extra_configs of this LogicalSwitch.

        This property could be used for vendor specific configuration in key value string pairs, the setting in extra_configs will be automatically inheritted by logical ports in the logical switch.   # noqa: E501

        :param extra_configs: The extra_configs of this LogicalSwitch.  # noqa: E501
        :type: list[ExtraConfig]
        """

        self._extra_configs = extra_configs

    @property
    def uplink_teaming_policy_name(self):
        """Gets the uplink_teaming_policy_name of this LogicalSwitch.  # noqa: E501

        This name has to be one of the switching uplink teaming policy names listed inside the logical switch's TransportZone. If this field is not specified, the logical switch will not have a teaming policy associated with it and the host switch's default teaming policy will be used.  # noqa: E501

        :return: The uplink_teaming_policy_name of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._uplink_teaming_policy_name

    @uplink_teaming_policy_name.setter
    def uplink_teaming_policy_name(self, uplink_teaming_policy_name):
        """Sets the uplink_teaming_policy_name of this LogicalSwitch.

        This name has to be one of the switching uplink teaming policy names listed inside the logical switch's TransportZone. If this field is not specified, the logical switch will not have a teaming policy associated with it and the host switch's default teaming policy will be used.  # noqa: E501

        :param uplink_teaming_policy_name: The uplink_teaming_policy_name of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._uplink_teaming_policy_name = uplink_teaming_policy_name

    @property
    def address_bindings(self):
        """Gets the address_bindings of this LogicalSwitch.  # noqa: E501

        Address bindings for the Logical switch  # noqa: E501

        :return: The address_bindings of this LogicalSwitch.  # noqa: E501
        :rtype: list[PacketAddressClassifier]
        """
        return self._address_bindings

    @address_bindings.setter
    def address_bindings(self, address_bindings):
        """Sets the address_bindings of this LogicalSwitch.

        Address bindings for the Logical switch  # noqa: E501

        :param address_bindings: The address_bindings of this LogicalSwitch.  # noqa: E501
        :type: list[PacketAddressClassifier]
        """

        self._address_bindings = address_bindings

    @property
    def ip_pool_id(self):
        """Gets the ip_pool_id of this LogicalSwitch.  # noqa: E501

        IP pool id that associated with a LogicalSwitch.  # noqa: E501

        :return: The ip_pool_id of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._ip_pool_id

    @ip_pool_id.setter
    def ip_pool_id(self, ip_pool_id):
        """Sets the ip_pool_id of this LogicalSwitch.

        IP pool id that associated with a LogicalSwitch.  # noqa: E501

        :param ip_pool_id: The ip_pool_id of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._ip_pool_id = ip_pool_id

    @property
    def vlan(self):
        """Gets the vlan of this LogicalSwitch.  # noqa: E501

        This property is dedicated to VLAN based network, to set VLAN of logical network. It is mutually exclusive with 'vlan_trunk_spec'.   # noqa: E501

        :return: The vlan of this LogicalSwitch.  # noqa: E501
        :rtype: int
        """
        return self._vlan

    @vlan.setter
    def vlan(self, vlan):
        """Sets the vlan of this LogicalSwitch.

        This property is dedicated to VLAN based network, to set VLAN of logical network. It is mutually exclusive with 'vlan_trunk_spec'.   # noqa: E501

        :param vlan: The vlan of this LogicalSwitch.  # noqa: E501
        :type: int
        """

        self._vlan = vlan

    @property
    def hybrid(self):
        """Gets the hybrid of this LogicalSwitch.  # noqa: E501

        If this flag is set to true, then all the logical switch ports attached to this logical switch will behave in a hybrid fashion. The hybrid logical switch port indicates to NSX that the VM intends to operate in underlay mode, but retains the ability to forward egress traffic to the NSX overlay network. This flag can be enabled only for the logical switches in the overlay type transport zone which has host switch mode as STANDARD and also has either CrossCloud or CloudScope tag scopes. Only the NSX public cloud gateway (PCG) uses this flag, other host agents like ESX, KVM and Edge will ignore it. This property cannot be modified once the logical switch is created.   # noqa: E501

        :return: The hybrid of this LogicalSwitch.  # noqa: E501
        :rtype: bool
        """
        return self._hybrid

    @hybrid.setter
    def hybrid(self, hybrid):
        """Sets the hybrid of this LogicalSwitch.

        If this flag is set to true, then all the logical switch ports attached to this logical switch will behave in a hybrid fashion. The hybrid logical switch port indicates to NSX that the VM intends to operate in underlay mode, but retains the ability to forward egress traffic to the NSX overlay network. This flag can be enabled only for the logical switches in the overlay type transport zone which has host switch mode as STANDARD and also has either CrossCloud or CloudScope tag scopes. Only the NSX public cloud gateway (PCG) uses this flag, other host agents like ESX, KVM and Edge will ignore it. This property cannot be modified once the logical switch is created.   # noqa: E501

        :param hybrid: The hybrid of this LogicalSwitch.  # noqa: E501
        :type: bool
        """

        self._hybrid = hybrid

    @property
    def mac_pool_id(self):
        """Gets the mac_pool_id of this LogicalSwitch.  # noqa: E501

        Mac pool id that associated with a LogicalSwitch.  # noqa: E501

        :return: The mac_pool_id of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._mac_pool_id

    @mac_pool_id.setter
    def mac_pool_id(self, mac_pool_id):
        """Sets the mac_pool_id of this LogicalSwitch.

        Mac pool id that associated with a LogicalSwitch.  # noqa: E501

        :param mac_pool_id: The mac_pool_id of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._mac_pool_id = mac_pool_id

    @property
    def vni(self):
        """Gets the vni of this LogicalSwitch.  # noqa: E501

        Only for OVERLAY network. A VNI will be auto-allocated from the default VNI pool if not given; otherwise the given VNI has to be inside the default pool and not used by any other LogicalSwitch.   # noqa: E501

        :return: The vni of this LogicalSwitch.  # noqa: E501
        :rtype: int
        """
        return self._vni

    @vni.setter
    def vni(self, vni):
        """Sets the vni of this LogicalSwitch.

        Only for OVERLAY network. A VNI will be auto-allocated from the default VNI pool if not given; otherwise the given VNI has to be inside the default pool and not used by any other LogicalSwitch.   # noqa: E501

        :param vni: The vni of this LogicalSwitch.  # noqa: E501
        :type: int
        """

        self._vni = vni

    @property
    def vlan_trunk_spec(self):
        """Gets the vlan_trunk_spec of this LogicalSwitch.  # noqa: E501


        :return: The vlan_trunk_spec of this LogicalSwitch.  # noqa: E501
        :rtype: VlanTrunkSpec
        """
        return self._vlan_trunk_spec

    @vlan_trunk_spec.setter
    def vlan_trunk_spec(self, vlan_trunk_spec):
        """Sets the vlan_trunk_spec of this LogicalSwitch.


        :param vlan_trunk_spec: The vlan_trunk_spec of this LogicalSwitch.  # noqa: E501
        :type: VlanTrunkSpec
        """

        self._vlan_trunk_spec = vlan_trunk_spec

    @property
    def admin_state(self):
        """Gets the admin_state of this LogicalSwitch.  # noqa: E501

        Represents Desired state of the Logical Switch  # noqa: E501

        :return: The admin_state of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._admin_state

    @admin_state.setter
    def admin_state(self, admin_state):
        """Sets the admin_state of this LogicalSwitch.

        Represents Desired state of the Logical Switch  # noqa: E501

        :param admin_state: The admin_state of this LogicalSwitch.  # noqa: E501
        :type: str
        """
        if admin_state is None:
            raise ValueError("Invalid value for `admin_state`, must not be `None`")  # noqa: E501
        allowed_values = ["UP", "DOWN"]  # noqa: E501
        if admin_state not in allowed_values:
            raise ValueError(
                "Invalid value for `admin_state` ({0}), must be one of {1}"  # noqa: E501
                .format(admin_state, allowed_values)
            )

        self._admin_state = admin_state

    @property
    def transport_zone_id(self):
        """Gets the transport_zone_id of this LogicalSwitch.  # noqa: E501

        Id of the TransportZone to which this LogicalSwitch is associated  # noqa: E501

        :return: The transport_zone_id of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._transport_zone_id

    @transport_zone_id.setter
    def transport_zone_id(self, transport_zone_id):
        """Sets the transport_zone_id of this LogicalSwitch.

        Id of the TransportZone to which this LogicalSwitch is associated  # noqa: E501

        :param transport_zone_id: The transport_zone_id of this LogicalSwitch.  # noqa: E501
        :type: str
        """
        if transport_zone_id is None:
            raise ValueError("Invalid value for `transport_zone_id`, must not be `None`")  # noqa: E501

        self._transport_zone_id = transport_zone_id

    @property
    def span(self):
        """Gets the span of this LogicalSwitch.  # noqa: E501

        Each manager ID represents the NSX Local Manager the logical switch connects. This will be populated by the manager.  # noqa: E501

        :return: The span of this LogicalSwitch.  # noqa: E501
        :rtype: list[str]
        """
        return self._span

    @span.setter
    def span(self, span):
        """Sets the span of this LogicalSwitch.

        Each manager ID represents the NSX Local Manager the logical switch connects. This will be populated by the manager.  # noqa: E501

        :param span: The span of this LogicalSwitch.  # noqa: E501
        :type: list[str]
        """

        self._span = span

    @property
    def switching_profile_ids(self):
        """Gets the switching_profile_ids of this LogicalSwitch.  # noqa: E501


        :return: The switching_profile_ids of this LogicalSwitch.  # noqa: E501
        :rtype: list[SwitchingProfileTypeIdEntry]
        """
        return self._switching_profile_ids

    @switching_profile_ids.setter
    def switching_profile_ids(self, switching_profile_ids):
        """Sets the switching_profile_ids of this LogicalSwitch.


        :param switching_profile_ids: The switching_profile_ids of this LogicalSwitch.  # noqa: E501
        :type: list[SwitchingProfileTypeIdEntry]
        """

        self._switching_profile_ids = switching_profile_ids

    @property
    def global_vni(self):
        """Gets the global_vni of this LogicalSwitch.  # noqa: E501

        The VNI is used for intersite traffic and the global logical switch ID. The global VNI pool is agnostic of the local VNI pool, and there is no need to have an exclusive VNI range. For example, VNI x can be the global VNI for logical switch B and the local VNI for logical switch A.  # noqa: E501

        :return: The global_vni of this LogicalSwitch.  # noqa: E501
        :rtype: int
        """
        return self._global_vni

    @global_vni.setter
    def global_vni(self, global_vni):
        """Sets the global_vni of this LogicalSwitch.

        The VNI is used for intersite traffic and the global logical switch ID. The global VNI pool is agnostic of the local VNI pool, and there is no need to have an exclusive VNI range. For example, VNI x can be the global VNI for logical switch B and the local VNI for logical switch A.  # noqa: E501

        :param global_vni: The global_vni of this LogicalSwitch.  # noqa: E501
        :type: int
        """

        self._global_vni = global_vni

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LogicalSwitch, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LogicalSwitch):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
