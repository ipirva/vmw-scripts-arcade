# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 3.1.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from swagger_client.models.managed_resource import ManagedResource  # noqa: F401,E501

class DnsForwarder(ManagedResource):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'conditional_forwarders': 'list[ConditionalForwarderZone]',
        'logical_router_id': 'str',
        'cache_size': 'int',
        'default_forwarder': 'ForwarderZone',
        'log_level': 'str',
        'enabled': 'bool',
        'listener_ip': 'str'
    }
    if hasattr(ManagedResource, "swagger_types"):
        swagger_types.update(ManagedResource.swagger_types)

    attribute_map = {
        'conditional_forwarders': 'conditional_forwarders',
        'logical_router_id': 'logical_router_id',
        'cache_size': 'cache_size',
        'default_forwarder': 'default_forwarder',
        'log_level': 'log_level',
        'enabled': 'enabled',
        'listener_ip': 'listener_ip'
    }
    if hasattr(ManagedResource, "attribute_map"):
        attribute_map.update(ManagedResource.attribute_map)

    def __init__(self, conditional_forwarders=None, logical_router_id=None, cache_size=1024, default_forwarder=None, log_level='INFO', enabled=True, listener_ip=None, *args, **kwargs):  # noqa: E501
        """DnsForwarder - a model defined in Swagger"""  # noqa: E501
        self._conditional_forwarders = None
        self._logical_router_id = None
        self._cache_size = None
        self._default_forwarder = None
        self._log_level = None
        self._enabled = None
        self._listener_ip = None
        self.discriminator = None
        if conditional_forwarders is not None:
            self.conditional_forwarders = conditional_forwarders
        self.logical_router_id = logical_router_id
        if cache_size is not None:
            self.cache_size = cache_size
        self.default_forwarder = default_forwarder
        if log_level is not None:
            self.log_level = log_level
        if enabled is not None:
            self.enabled = enabled
        self.listener_ip = listener_ip
        ManagedResource.__init__(self, *args, **kwargs)

    @property
    def conditional_forwarders(self):
        """Gets the conditional_forwarders of this DnsForwarder.  # noqa: E501

        The conditional zone forwarders. During matching a zone forwarder, the DNS forwarder will use the conditional fowarder with the longest domain name that matches the query.   # noqa: E501

        :return: The conditional_forwarders of this DnsForwarder.  # noqa: E501
        :rtype: list[ConditionalForwarderZone]
        """
        return self._conditional_forwarders

    @conditional_forwarders.setter
    def conditional_forwarders(self, conditional_forwarders):
        """Sets the conditional_forwarders of this DnsForwarder.

        The conditional zone forwarders. During matching a zone forwarder, the DNS forwarder will use the conditional fowarder with the longest domain name that matches the query.   # noqa: E501

        :param conditional_forwarders: The conditional_forwarders of this DnsForwarder.  # noqa: E501
        :type: list[ConditionalForwarderZone]
        """

        self._conditional_forwarders = conditional_forwarders

    @property
    def logical_router_id(self):
        """Gets the logical_router_id of this DnsForwarder.  # noqa: E501

        Specify the LogicalRouter where the DnsForwarder runs. The HA mode of the hosting LogicalRouter must be Active/Standby.   # noqa: E501

        :return: The logical_router_id of this DnsForwarder.  # noqa: E501
        :rtype: str
        """
        return self._logical_router_id

    @logical_router_id.setter
    def logical_router_id(self, logical_router_id):
        """Sets the logical_router_id of this DnsForwarder.

        Specify the LogicalRouter where the DnsForwarder runs. The HA mode of the hosting LogicalRouter must be Active/Standby.   # noqa: E501

        :param logical_router_id: The logical_router_id of this DnsForwarder.  # noqa: E501
        :type: str
        """
        if logical_router_id is None:
            raise ValueError("Invalid value for `logical_router_id`, must not be `None`")  # noqa: E501

        self._logical_router_id = logical_router_id

    @property
    def cache_size(self):
        """Gets the cache_size of this DnsForwarder.  # noqa: E501

        One DNS answer cache entry will consume ~120 bytes. Hence 1 KB cache size can cache ~8 DNS answer entries, and the default 1024 KB cache size can hold ~8k DNS answer entries.   # noqa: E501

        :return: The cache_size of this DnsForwarder.  # noqa: E501
        :rtype: int
        """
        return self._cache_size

    @cache_size.setter
    def cache_size(self, cache_size):
        """Sets the cache_size of this DnsForwarder.

        One DNS answer cache entry will consume ~120 bytes. Hence 1 KB cache size can cache ~8 DNS answer entries, and the default 1024 KB cache size can hold ~8k DNS answer entries.   # noqa: E501

        :param cache_size: The cache_size of this DnsForwarder.  # noqa: E501
        :type: int
        """

        self._cache_size = cache_size

    @property
    def default_forwarder(self):
        """Gets the default_forwarder of this DnsForwarder.  # noqa: E501


        :return: The default_forwarder of this DnsForwarder.  # noqa: E501
        :rtype: ForwarderZone
        """
        return self._default_forwarder

    @default_forwarder.setter
    def default_forwarder(self, default_forwarder):
        """Sets the default_forwarder of this DnsForwarder.


        :param default_forwarder: The default_forwarder of this DnsForwarder.  # noqa: E501
        :type: ForwarderZone
        """
        if default_forwarder is None:
            raise ValueError("Invalid value for `default_forwarder`, must not be `None`")  # noqa: E501

        self._default_forwarder = default_forwarder

    @property
    def log_level(self):
        """Gets the log_level of this DnsForwarder.  # noqa: E501

        Log level of the DNS forwarder  # noqa: E501

        :return: The log_level of this DnsForwarder.  # noqa: E501
        :rtype: str
        """
        return self._log_level

    @log_level.setter
    def log_level(self, log_level):
        """Sets the log_level of this DnsForwarder.

        Log level of the DNS forwarder  # noqa: E501

        :param log_level: The log_level of this DnsForwarder.  # noqa: E501
        :type: str
        """
        allowed_values = ["DEBUG", "INFO", "WARNING", "ERROR", "FATAL"]  # noqa: E501
        if log_level not in allowed_values:
            raise ValueError(
                "Invalid value for `log_level` ({0}), must be one of {1}"  # noqa: E501
                .format(log_level, allowed_values)
            )

        self._log_level = log_level

    @property
    def enabled(self):
        """Gets the enabled of this DnsForwarder.  # noqa: E501

        Flag to enable/disable the forwarder  # noqa: E501

        :return: The enabled of this DnsForwarder.  # noqa: E501
        :rtype: bool
        """
        return self._enabled

    @enabled.setter
    def enabled(self, enabled):
        """Sets the enabled of this DnsForwarder.

        Flag to enable/disable the forwarder  # noqa: E501

        :param enabled: The enabled of this DnsForwarder.  # noqa: E501
        :type: bool
        """

        self._enabled = enabled

    @property
    def listener_ip(self):
        """Gets the listener_ip of this DnsForwarder.  # noqa: E501

        The ip address the DNS forwarder listens on. It can be an ip address already owned by the logical-router uplink port or router-link, or a loopback port ip address. But it can not be a downlink port address. User needs to ensure the address is reachable via router or NAT from both client VMs and upstream servers. User will need to create Firewall rules if needed to allow such traffic on a Tier-1 or Tier-0.   # noqa: E501

        :return: The listener_ip of this DnsForwarder.  # noqa: E501
        :rtype: str
        """
        return self._listener_ip

    @listener_ip.setter
    def listener_ip(self, listener_ip):
        """Sets the listener_ip of this DnsForwarder.

        The ip address the DNS forwarder listens on. It can be an ip address already owned by the logical-router uplink port or router-link, or a loopback port ip address. But it can not be a downlink port address. User needs to ensure the address is reachable via router or NAT from both client VMs and upstream servers. User will need to create Firewall rules if needed to allow such traffic on a Tier-1 or Tier-0.   # noqa: E501

        :param listener_ip: The listener_ip of this DnsForwarder.  # noqa: E501
        :type: str
        """
        if listener_ip is None:
            raise ValueError("Invalid value for `listener_ip`, must not be `None`")  # noqa: E501

        self._listener_ip = listener_ip

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(DnsForwarder, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DnsForwarder):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
